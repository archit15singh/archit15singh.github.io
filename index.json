[{"content":"For more detailed essays, you can explore the collection directly from the 97 Things Every Programmer Should Know collection. This collection provides valuable lessons and practical tips that can benefit both novices and experienced professionals in their respective fields.\nCode Quality and Maintenance Code Readability and Documentation\nCode Design Code Is Design Encapsulate Behavior, not Just State Code Layout Code Layout Matters Comment Only What the Code Cannot Say Writing Maintainable Code Write Code as If You Had to Support It for the Rest of Your Life Write Small Functions Using Examples Code Review and Refactoring\nCode Reviews Code Reviews Refactoring Practices Improve Code by Removing It The Boy Scout Rule Own (and Refactor) the Build Automation in Refactoring Automate Your Coding Standard Testing and Debugging Automated Testing Practices\nBehavioral Testing Test for Required Behavior, not Incidental Behavior Precision in Testing Test Precisely and Concretely Continuous Testing Test While You Sleep (and over Weekends) Write Tests for People Debugging Techniques and Error Handling\nLogging and Error Handling Verbose Logging Will Disturb Your Sleep Don\u0026rsquo;t Ignore that Error! Prevent Errors Debugging Tools and Techniques How to Use a Bug Tracker News of the Weird: Testers Are Your Friends Design Principles Modularity and Reusability\nSingle Responsibility and Modularity The Single Responsibility Principle Don\u0026rsquo;t Repeat Yourself Encapsulation and Types Encapsulate Behavior, not Just State Prefer Domain-Specific Types to Primitive Types Missing Opportunities for Polymorphism API and Interface Design\nAPI Design The Golden Rule of API Design Interface Usability Make Interfaces Easy to Use Correctly and Hard to Use Incorrectly Development Practices Agile and Iterative Development\nEarly and Frequent Releases Deploy Early and Often Practice and Feedback Do Lots of Deliberate Practice Step Back and Automate, Automate, Automate Version Control Put Everything Under Version Control Prudence in Development Act with Prudence Risk-Taking Don\u0026rsquo;t Be Afraid to Break Things Commit Practices Know Your Next Commit Tooling and Environment\nCommand-line Tools Know How to Use Command-line Tools Integrated Development Environment (IDE) Know Your IDE Analysis Tools Take Advantage of Code Analysis Tools Unix Tools The Unix Tools Are Your Friends Performance and Optimization Optimization Techniques\nReduction in Complexity Simplicity Comes from Reduction Algorithm and Data Structure Selection Use the Right Algorithm and Data Structure Performance Issues The Road to Performance Is Littered with Dirty Code Bombs Concurrency and Scalability\nMessage Passing Message Passing Leads to Better Scalability in Parallel Systems Inter-Process Communication Inter-Process Communication Affects Application Response Time Professional Development Learning and Growth\nContinuous Improvement Continuous Learning Reinvent the Wheel Often Openness to Opportunities Start from Yes Language Skills Learn Foreign Languages Know Well More than Two Programming Languages Estimation and Planning\nProject Estimation Learn to Estimate Prudent Actions Act with Prudence Broad Learning Read the Humanities Collaboration and Communication Teamwork and Pair Programming\nPair Programming Pair Program and Feel the Flow Collaborative Problem-Solving Two Heads Are Often Better than One When Programmers and Testers Collaborate Customer Interaction and Requirements\nCustomer Communication Your Customers Do not Mean What They Say Project Advocacy Let Your Project Speak for Itself Code Reading Read Code Defensive Programming Error Handling and Prevention\nPreventive Measures Prevent Errors Error Handling Practices Don\u0026rsquo;t Rely on \u0026ldquo;Magic Happens Here\u0026rdquo; Don\u0026rsquo;t Be Cute with Your Test Data Interim Solutions The Longevity of Interim Solutions Safe Code Modifications\nCode Changes Don\u0026rsquo;t Touch that Code! Build Management Own (and Refactor) the Build Culture and Philosophy Programming Philosophy\nRole and Mythology The Guru Myth Hard Work Does not Pay Off Cultural Understanding Don\u0026rsquo;t Just Learn the Language, Understand its Culture Community Coding Ubuntu Coding for Your Friends Behavior and Attitude\nSelf-awareness Know Your Limits Work-Life Balance Put the Mouse Down and Step Away from the Keyboard Ethical Coding You Gotta Care about the Code Technical Concepts Fundamental Concepts Numerical Accuracy Floating-point Numbers Aren\u0026rsquo;t Real Data Management Large Interconnected Data Belongs to a Database Build and Linking The Linker Is not a Magical Program Deployment One Binary Specific Practices and Tools Version Control and Build Management Version Control Put Everything Under Version Control Build Practices Own (and Refactor) the Build Keep the Build Clean Know Your Next Commit ","permalink":"https://archit15singh.github.io/posts/2024-07-12-god-programmer/","summary":"\u003cp\u003eFor more detailed essays, you can explore the collection directly from the \u003ca href=\"https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/\"\u003e97 Things Every Programmer Should Know\u003c/a\u003e collection.\nThis collection provides valuable lessons and practical tips that can benefit both novices and experienced professionals in their respective fields.\u003c/p\u003e\n\u003ch3 id=\"code-quality-and-maintenance\"\u003eCode Quality and Maintenance\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eCode Readability and Documentation\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCode Design\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eCode Is Design\u003c/li\u003e\n\u003cli\u003eEncapsulate Behavior, not Just State\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCode Layout\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eCode Layout Matters\u003c/li\u003e\n\u003cli\u003eComment Only What the Code Cannot Say\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eWriting Maintainable Code\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eWrite Code as If You Had to Support It for the Rest of Your Life\u003c/li\u003e\n\u003cli\u003eWrite Small Functions Using Examples\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eCode Review and Refactoring\u003c/strong\u003e\u003c/p\u003e","title":"God Programmer Traits"},{"content":"Asyncio is a powerful library in Python that enables writing concurrent code using the async/await syntax. It provides a framework for managing I/O-bound and high-level structured network code. Asyncio is widely used in web servers, database drivers, network protocols, and other applications that require concurrency without the complexity of traditional threading or multiprocessing.\nIntroduction to Asyncio Asyncio has become a cornerstone for modern Python applications that need to handle asynchronous tasks efficiently. Its ability to manage multiple tasks simultaneously makes it an ideal choice for various real-world scenarios.\nTopics Introduction to Asyncio\nOverview Importance in modern applications Core Concepts and Components\nEvent Loop Coroutines Tasks Futures Gather and Wait Exception Handling Asyncio Primitives\nLocks Events Conditions Semaphores Real-World Use Cases\nWeb Scraping Web Servers Microservices Network Clients and Servers Periodic Tasks Asynchronous Database Operations Advanced Features\nCustom Event Loops Subprocess Management Signal Handling Thread and Process Integration Best Practices and Patterns\nError Handling and Debugging Performance Optimization Testing Asynchronous Code Comparisons with Other Concurrency Models\nThreads vs Asyncio Multiprocessing vs Asyncio Asyncio vs Concurrent.Futures Core Concepts and Components Event Loop The event loop is the heart of asyncio. It runs asynchronous tasks and callbacks, handles I/O operations, and schedules tasks.\nCoroutines Coroutines are special functions defined with async def and can be paused and resumed, allowing other code to run during their execution.\nTasks Tasks are used to schedule coroutines concurrently. They are created using asyncio.create_task().\nFutures Futures represent the result of an asynchronous operation. They are usually not created directly but returned by asyncio APIs.\nGather and Wait asyncio.gather() runs multiple coroutines concurrently and waits for them all to complete. asyncio.wait() waits for the completion of Futures or coroutines.\nException Handling Proper exception handling in asyncio is crucial for robust applications. Use try/except blocks within coroutines and handle task exceptions using add_done_callback() or asyncio.wait().\nAsyncio Primitives Locks Asyncio provides Lock for synchronizing access to shared resources.\nEvents Event is a simple mechanism for communication between coroutines.\nConditions Condition is used for complex synchronization patterns involving multiple coroutines.\nSemaphores Semaphore limits access to a resource by a specific number of coroutines.\nReal-World Use Cases Web Scraping Asyncio is excellent for web scraping due to its ability to handle multiple I/O-bound tasks concurrently.\nimport asyncio import aiohttp async def fetch_url(session, url): async with session.get(url) as response: return await response.text() async def main(urls): async with aiohttp.ClientSession() as session: tasks = [fetch_url(session, url) for url in urls] return await asyncio.gather(*tasks) urls = [\u0026#39;https://example.com\u0026#39;, \u0026#39;https://example.org\u0026#39;] results = asyncio.run(main(urls)) Web Servers Frameworks like FastAPI leverage asyncio to build high-performance web servers.\nfrom fastapi import FastAPI app = FastAPI() @app.get(\u0026#34;/\u0026#34;) async def read_root(): return {\u0026#34;Hello\u0026#34;: \u0026#34;World\u0026#34;} Microservices Asyncio is used in microservices for handling high-throughput, low-latency services.\nNetwork Clients and Servers Asyncio\u0026rsquo;s StreamReader and StreamWriter are used for creating network clients and servers.\nimport asyncio async def handle_echo(reader, writer): data = await reader.read(100) message = data.decode() writer.write(data) await writer.drain() writer.close() async def main(): server = await asyncio.start_server(handle_echo, \u0026#39;127.0.0.1\u0026#39;, 8888) async with server: await server.serve_forever() asyncio.run(main()) Periodic Tasks Using asyncio.sleep() to create periodic tasks.\nasync def periodic(): while True: print(\u0026#34;Task running...\u0026#34;) await asyncio.sleep(5) asyncio.run(periodic()) Asynchronous Database Operations Async libraries like aiomysql and asyncpg allow for asynchronous database interactions.\nimport asyncio import asyncpg async def fetch_data(): conn = await asyncpg.connect(\u0026#39;postgresql://user:password@localhost/dbname\u0026#39;) values = await conn.fetch(\u0026#39;SELECT * FROM table_name\u0026#39;) await conn.close() return values asyncio.run(fetch_data()) Advanced Features Custom Event Loops Creating custom event loops for specific use cases.\nSubprocess Management Managing subprocesses with asyncio.\nSignal Handling Handling OS signals with asyncio.\nThread and Process Integration Combining threads and processes with asyncio using loop.run_in_executor().\nBest Practices and Patterns Error Handling and Debugging Effective strategies for handling errors and debugging asyncio applications.\nPerformance Optimization Techniques for optimizing the performance of asyncio applications.\nTesting Asynchronous Code Approaches to testing asyncio code.\nComparisons with Other Concurrency Models Threads vs Asyncio Comparison of threading and asyncio, highlighting the strengths and weaknesses of each.\nMultiprocessing vs Asyncio Comparison of multiprocessing and asyncio, focusing on use cases and performance.\nAsyncio vs Concurrent.Futures Comparison of asyncio with the concurrent.futures module.\nConclusion Asyncio is a versatile and powerful library for writing concurrent code in Python. Its ability to handle a wide range of tasks, from web servers to network clients, makes it an essential tool for modern Python developers. By understanding the core concepts, real-world use cases, and best practices, you can harness the full potential of asyncio in your applications.\n","permalink":"https://archit15singh.github.io/posts/2024-05-07-asyncio-in-real-world-applications-a-comprehensive-guide/","summary":"\u003cp\u003eAsyncio is a powerful library in Python that enables writing concurrent code using the async/await syntax. It provides a framework for managing I/O-bound and high-level structured network code. Asyncio is widely used in web servers, database drivers, network protocols, and other applications that require concurrency without the complexity of traditional threading or multiprocessing.\u003c/p\u003e\n\u003ch2 id=\"introduction-to-asyncio\"\u003eIntroduction to Asyncio\u003c/h2\u003e\n\u003cp\u003eAsyncio has become a cornerstone for modern Python applications that need to handle asynchronous tasks efficiently. Its ability to manage multiple tasks simultaneously makes it an ideal choice for various real-world scenarios.\u003c/p\u003e","title":"Asyncio in Real-World Applications: A Comprehensive Guide"},{"content":"This is a test post content.\n","permalink":"https://archit15singh.github.io/posts/minimal-test-post/","summary":"\u003cp\u003eThis is a test post content.\u003c/p\u003e","title":"Minimal Test Post"},{"content":"How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive) 🚀 What This Series Will Teach You This blog post is the first step of a multi-part deep dive into the JS execution model. You’ll learn:\nHow JavaScript handles synchronous and asynchronous code What the call stack, job queue, microtasks, and event loop really are How realms, agents, and execution contexts work together How engines like V8 optimize while staying spec-compliant Why seemingly simple code can behave unexpectedly — and how to reason through it Each section will build your mental model — with visuals, real code traces, intuitive metaphors, and runtime behavior breakdowns.\n📌 Whether you\u0026rsquo;re building a single-page app, debugging race conditions, or writing high-performance server-side JS — knowing how JS really runs is your ultimate superpower.\n1. 🎯 Introduction: What is the JavaScript Execution Model? JavaScript might look simple — you write let x = 10, it runs. You call a function, it executes. But under the hood, a sophisticated system choreographs every line you write. That system is called the JavaScript execution model.\n🧠 So… what is it? At its core, the JavaScript execution model defines how JavaScript code runs:\nHow the engine interprets your code How memory is allocated and freed How functions get stacked and unstacked How asynchronous code (like setTimeout or fetch) is managed How multiple “threads” (agents) interact — or don’t It’s like the operating system of JavaScript — the abstract machine that governs how your code behaves, step-by-step.\n🧩 Why should developers care? You don’t need to know every VM optimization trick to write JavaScript…\nBut if you want to:\nFix timing bugs Master Promises, async/await, and the event loop Avoid race conditions and memory leaks Write responsive apps that never freeze the UI Debug async issues like “Why does this log after that?” \u0026hellip;then understanding the execution model isn\u0026rsquo;t optional — it’s essential.\nIt’s the foundation beneath everything from simple loops to complex front-end architectures to performance-critical backends.\n🆚 Spec vs Reality: Goals of the Execution Model The ECMAScript specification (the official language definition) defines the execution model in a platform-neutral, abstract way.\nThis spec outlines the rules all JavaScript engines must follow, regardless of environment:\nBrowsers (Chrome/V8, Firefox/SpiderMonkey, Safari/JavaScriptCore) Servers (Node.js, Deno) Embedded runtimes (e.g. IoT devices) However, real engines are free to optimize — just like how chess players can use different tactics, but must follow the same rules.\nFor example:\nV8 (Chrome/Node.js) uses Just-In-Time (JIT) compilation, inline caching, and memory optimizations. But it still follows the logical model the spec describes: same rules, different execution speed. 💡 TL;DR: The spec defines what must happen, not how fast or how exactly an engine does it.\n🎭 Real-World Metaphor: Actor, Stage, Script Let’s break it down with a metaphor:\nYour code = the script The JavaScript engine = the actor The host environment (browser, Node) = the stage, lighting, props, audience The execution model = the stage manager — orchestrating who enters when, what lines are spoken, and how long each actor gets to perform The actor (engine) can’t improvise wildly — it must follow the script (your code) — but the stage manager decides when scenes start, what props are ready, and how long each act lasts.\nAnd just like in theater: no actor can speak two lines at the same time. JavaScript, too, is single-threaded — one line at a time, unless you start spinning off background actors (Web Workers, Service Workers).\n🧩 2. Core Architecture of JavaScript Runtime To understand how JavaScript runs your code, we need to dissect what components make up the JS runtime.\nAt the core, JavaScript doesn\u0026rsquo;t run in a vacuum — it needs an engine to interpret the code, and a host environment to provide real-world capabilities like networking, timers, and file access.\nLet’s peel this layer by layer.\n🔹 2.1. The JavaScript Engine ✅ Literal meaning: The engine is the heart of the JavaScript runtime. It\u0026rsquo;s the software that understands and executes ECMAScript — the official JavaScript language specification.\n🧠 What it provides: Parsing: Reads and interprets JS source code (e.g., turns function foo() {} into a syntax tree). Execution: Runs your code step-by-step, managing memory, stack, scopes, etc. Optimization: Applies techniques like JIT (Just-In-Time) compilation, inline caching, dead code elimination for speed. 🛠 Examples of engines: V8 (Chrome, Node.js) SpiderMonkey (Firefox) JavaScriptCore (Safari) Chakra (deprecated, formerly in Edge) 🧬 Mental model: Think of the engine like a brain that knows how to read JavaScript, understand it, and run it — but it’s stuck in a box. It can\u0026rsquo;t talk to the outside world unless someone wires it up.\n// This is purely engine territory: const x = 5 + 3; const doubled = x * 2; No DOM. No timers. No file I/O. Just language-level stuff.\n🔹 2.2. The Host Environment ✅ Literal meaning: This is the external system embedding the JS engine.\nIt provides platform-specific APIs and functionalities that the engine alone cannot offer.\n🌍 Common host environments: Web browsers: Chrome, Firefox, Safari Node.js: Server-side JS runtime Deno: Secure, modern runtime for JS/TS React Native: JS inside mobile apps Adobe After Effects: JS for scripting animation! 🛠 Host-provided APIs: These aren’t part of the JS language — they’re provided by the host:\nAPI / Feature Provided by setTimeout() Browser / Node document.querySelector() Browser fs.readFile() Node.js fetch() Browser / Node (polyfilled) postMessage() Web Worker context navigator.geolocation Browser 💻 Example: console.log(\u0026#34;Hello\u0026#34;); // Host provides the \u0026#39;console\u0026#39; object setTimeout(() =\u0026gt; { alert(\u0026#34;Hi\u0026#34;); }, 1000); // \u0026#39;setTimeout\u0026#39; is NOT part of JS — it\u0026#39;s host API 🧬 Real-world analogy: The JS engine is the actor. The host environment is the stage, lighting, props, and audience. The actor can memorize lines (JavaScript), but can\u0026rsquo;t do anything — like turn on a spotlight or play sound — unless the stage supports it.\n🔹 2.3. Engine vs Host: Division of Concerns ✅ Literal meaning: JavaScript engines and host environments play distinct but collaborative roles.\nConcern Handled by let, const, class, =\u0026gt; JavaScript Engine console.log, setTimeout Host Environment document.getElementById Host (Browser) fs.readFileSync Host (Node.js) 🧠 Why this matters: JavaScript isn’t “browser-only” — it’s a language, not a platform. This is why you can run JS in: a browser (with DOM), a server (Node.js), an embedded device (e.g. Espruino), or even in a text editor plugin (VS Code extensions). Each context offers different tools — but the engine stays the same.\n🧪 Code Comparison: // Runs in browser setTimeout(() =\u0026gt; console.log(\u0026#34;Hi\u0026#34;), 1000); document.body.style.background = \u0026#34;black\u0026#34;; // Runs in Node setTimeout(() =\u0026gt; console.log(\u0026#34;Hi\u0026#34;), 1000); const fs = require(\u0026#34;fs\u0026#34;); fs.readFileSync(\u0026#34;./file.txt\u0026#34;); Same JS engine (V8), totally different capabilities, because of the host.\n⚠️ Gotcha: “Why does JS code fail in Node but not in the browser?” // This fails in Node.js: document.getElementById(\u0026#34;app\u0026#34;); Because document is a host-provided object, and Node doesn’t include a DOM.\n💡 Same JavaScript. Different host. Different powers.\n🔗 Related Concept: Polyfills and Environment Detection Because hosts vary:\nWe need feature detection (typeof window, if ('fetch' in globalThis)) We write polyfills (e.g., implement fetch in Node if it’s missing) 🧠 TL;DR Mental Model Layer Role JavaScript Engine Understands and executes ECMAScript code Host Environment Provides platform-specific capabilities JS Runtime Combination of engine + host (aka “JS in the wild”) 🧩 Summary Table Concept Engine or Host? Example Promise, Map Engine ECMAScript features setTimeout() Host Timer API (browser/Node) document Host (Browser) Web page interaction fs Host (Node.js) File system access console Host Logging (defined per host) function, =\u0026gt; Engine Language-level syntax 3. 🧠 Agent Execution Model — The Secret Engine Behind JavaScript’s Run-Time JavaScript may look like a language, but it runs like a machine. Under the hood, every line of your JavaScript code is managed by a tiny execution engine called an agent.\nLet’s crack open the hood and understand:\nWhat an agent actually is The key data structures that power it The lifecycle that makes async, generators, and tasks tick 3.1 🚀 What is an Agent? In the JavaScript spec, an agent is a self-contained execution environment — like a virtual CPU.\nIt has its own memory (heap) Its own call stack Its own event/job queue If you\u0026rsquo;re running JavaScript in a browser tab, that\u0026rsquo;s an agent.\nIf you\u0026rsquo;re running a Web Worker, that’s another agent.\nEach agent is isolated from the others (unless explicitly connected via SharedArrayBuffer).\n🧠 Think of an agent as: A single thread of execution with all the gears it needs to process JavaScript independently.\n🔬 Metaphor: If your code is a cooking recipe, an agent is the chef executing it — with its own kitchen, ingredients, and clipboard of instructions.\n3.2 ⚙️ Agent Data Structures: The Triad Every agent internally runs three major data structures — the holy trinity of JS execution:\n🧠 1. Heap 📦 Where objects and functions live — long-term storage.\nEvery time you create an object ({}), array ([]), or function, it’s allocated on the heap. Think of the heap as your warehouse of live objects. const user = { name: \u0026#34;Ada\u0026#34; }; // lives in the heap This is unstructured memory — managed automatically by the garbage collector.\n🧠 2. Call Stack 🧾 Where functions are executed, tracked, and returned — one frame at a time.\nJavaScript uses a stack (LIFO) to manage function calls. Each function call creates an execution context (aka stack frame). When a function finishes, the frame is popped off. function outer() { inner(); } function inner() { console.log(\u0026#34;Hi\u0026#34;); } outer(); Stack:\nouter() inner() console.log(...) Return, return, done ✅ 🔬 Metaphor: Like opening nested boxes. You can’t close box A until you’ve closed box B inside it.\n🧠 3. Job/Task Queue 🕓 A FIFO queue of pending asynchronous callbacks to run when the stack is empty.\nUsed by async actions: setTimeout, fetch, Promises Part of the event loop mechanism Each “job” is a callback waiting to be pulled onto the stack console.log(\u0026#34;A\u0026#34;); setTimeout(() =\u0026gt; console.log(\u0026#34;B\u0026#34;)); console.log(\u0026#34;C\u0026#34;); Output: A → C → B\nBecause setTimeout schedules B on the task queue, which runs after the current stack empties.\n🔬 All Together: Structure Type Role Heap Memory Stores all objects, functions Stack LIFO Tracks current function calls Queue FIFO Stores async jobs to run next 3.3 ⏳ Agent Lifecycle — How Code Actually Runs The life of a JavaScript agent is a predictable cycle:\n🔄 Step 1: A Job Begins A new job is pulled from the queue (e.g., a setTimeout callback) A new execution context is pushed onto the stack JS starts running the code in that callback 📈 Step 2: Stack Fills Up The function may call other functions More execution contexts are added The call stack grows 📉 Step 3: Stack Empties Each function finishes and returns The stack pops back down to empty Once empty, the agent picks the next job from the queue 💤 Step 4: Idle or Re-entry If the queue is empty → agent waits If the code yields (e.g. with a generator or async function), the context is paused It can later be resumed with the same state function* steps() { console.log(\u0026#34;Start\u0026#34;); yield; console.log(\u0026#34;Resumed\u0026#34;); } const g = steps(); g.next(); // Start g.next(); // Resumed 🧠 The function isn’t restarted — it’s resumed from where it left off.\n🧠 Why It Matters Understanding the agent model gives you deep insight into:\nWhy JS is single-threaded (per agent) Why async functions return promises Why await doesn\u0026rsquo;t block the thread Why stack overflows happen (Recursion!) 💡 Bonus: Multi-Agent Systems You can have multiple agents running concurrently (e.g., Web Workers) Each has its own stack, heap, and queue They can only communicate via: postMessage (copying data) SharedArrayBuffer + Atomics (shared memory) ✅ Recap: Agent Model Mental Picture Part Role Behavior Agent The JS “runtime engine” Runs JS code sequentially Heap Stores objects Grows dynamically, managed by GC Stack Manages function calls LIFO — grows and shrinks Queue Schedules async jobs FIFO — drives the event loop Lifecycle Pull job → execute → finish → repeat Enables async flow ✨ Real-World Debugging Tip When your UI freezes or console.log appears out of order — you’re seeing the agent lifecycle in action.\nIf you understand how the stack and queue interact, you can predict and control the timing of your code.\n4. 📦 Execution Contexts \u0026amp; Call Stack 4.1. 🧠 What is an Execution Context? An execution context (also called a stack frame) is the smallest unit of JS code execution.\nWhenever JavaScript runs any code—be it global, a function, or an eval—it wraps it in an execution context.\n🔍 It contains: 🧾 The currently executing function or script 📦 Its Lexical Environment (all its declared variables, parameters, inner functions) 🔗 The associated Realm (global scope + intrinsics like Array) 💬 Special bindings like this, arguments, and super 🧭 The return address (where to go back once the function completes) 🧬 Mental Model: Like a stack of sticky notes: each time a function is called, a new note (context) is added. It tracks what to do and where to return. Once done, it peels off.\n💻 Example: function add(a, b) { return a + b; } function compute(x) { const y = 2; return add(x, y); } compute(5); // Execution Contexts created: global -\u0026gt; compute -\u0026gt; add Each function call creates a new context with its own scope, this, and state.\n🧩 Lexical Environment Every execution context has a Lexical Environment, which stores:\nLocal variable bindings (let, const, var) Function declarations Inner scopes (closures) It\u0026rsquo;s called lexical because it\u0026rsquo;s determined by where the code is written, not how it is called.\n🔁 Closures: When a function is defined, it \u0026ldquo;remembers\u0026rdquo; the Lexical Environment it was created in. This is what powers closures:\nfunction outer() { let count = 0; return function inner() { count++; return count; } } The inner function holds on to the outer\u0026rsquo;s lexical environment even after outer has returned.\n🌐 Realm Association Each execution context is tied to a Realm, which determines:\nThe version of intrinsics like Array, Function, etc. The globalThis value Identity rules (e.g., x instanceof Array fails across realms) ⚠️ Gotcha: // If `arr` is created in iframe arr instanceof Array; // ❌ false (different realm\u0026#39;s Array) Array.isArray(arr); // ✅ works (uses internal tag) ⚙️ this, arguments, and Bindings Each context stores runtime-bound values:\nthis — depends on how the function is called (object method, arrow, etc.) arguments — array-like object for parameters (non-arrow functions) super — relevant in class methods New private class fields/methods also bind per context 4.2. 🔁 Function Invocation \u0026amp; Stack Frames When a function is invoked:\nJS creates a new execution context (stack frame) Pushes it onto the call stack Begins executing it 📤 When the function finishes: It returns a value or throws an error Its frame is popped off the stack Execution continues where it left off 💻 Code Trace: function foo() { const x = 10; return bar(x); } function bar(n) { return n + 5; } foo(); 🧱 Stack trace:\n[global] → foo() ← pushed → bar(10) ← pushed ← return 15 ← bar popped ← return 15 ← foo popped 🎯 Key behaviors: Return unwinds one frame Throw can unwind multiple frames up the stack (via try/catch or crash) Recursion builds up frames until base case or overflow ⚡ 4.3. Tail Call Optimization (TCO) Tail Call = when a function returns the result of calling another function directly\n(i.e., no more work left to do after the call).\nfunction a() { return b(); // ← tail position } If supported, JS engines can reuse the current stack frame rather than creating a new one.\n🎯 Benefits: Prevents stack overflow in tail-recursive functions Improves memory efficiency for deeply nested calls 🔥 Example (ideal for TCO): function factorial(n, acc = 1) { if (n \u0026lt;= 1) return acc; return factorial(n - 1, acc * n); // tail call } 🔁 Without TCO → Stack grows with n\n✅ With TCO → Constant memory usage\n⚠️ Engine Support Caveats: ECMAScript 2015 specifies proper TCO. Only Safari implements it (as of now). V8, SpiderMonkey, Chakra do not support it due to debugging \u0026amp; stack trace concerns. 🧠 Summary Table Concept Meaning \u0026amp; Purpose Execution Context Metadata + bindings for running code Stack Frame Unit of execution pushed onto the call stack Lexical Environment Local scope: variables, closures, declarations Realm JS \u0026ldquo;universe\u0026rdquo; for built-ins, globalThis, etc. Call Stack LIFO structure tracking nested calls Return / Throw Unwinds stack frames (1 or more) Tail Call Optimization Reuses stack frame for tail calls (not widely supported) 5. 🌀 Understanding Realms: The Hidden Worlds of JavaScript Execution When we talk about JavaScript execution, we often focus on the call stack, the event loop, or async jobs. But there’s a deeper architectural layer that rarely gets discussed—Realms.\nThink of realms as self-contained universes within a single JavaScript agent. If you\u0026rsquo;re debugging why instanceof mysteriously returns false, or why your iframe’s Array behaves strangely, you\u0026rsquo;re bumping up against realms—without even knowing it.\nLet’s unpack this critical concept with surgical depth and practical clarity.\n📦 What Is a Realm? A realm is a sandboxed execution environment in JavaScript.\nEach realm has its own global object and its own copies of built-in constructors like Object, Array, Function, and so on.\nIn simpler terms:\nA realm is a complete JS world—with its own set of laws (built-ins), and its own sky (global object). It exists within an agent (a JS thread), and multiple realms can coexist inside a single agent. 🧠 Mental Model: 🧵 Agent = one JS thread\n🌍 Realm = one JS environment (one globalThis)\n💡 Real-World Examples: Your main browser tab → 1 realm. A same-origin \u0026lt;iframe\u0026gt; → another realm (but in the same agent). A Web Worker → a separate agent with its own realm. 🔬 Realm Internals Let’s zoom into what makes up a realm:\n1. 🧬 Intrinsic Objects Each realm creates fresh copies of all intrinsic JS constructors and prototypes:\nArray !== iframe.contentWindow.Array; // ✅ true Object !== iframe.contentWindow.Object; // ✅ true These aren\u0026rsquo;t just shallow copies — they’re entirely different objects in memory. This is what leads to one of the most notorious bugs in cross-realm JS…\n⚠️ Gotcha: instanceof fails across realms const iframeArray = iframe.contentWindow.eval(\u0026#34;[]\u0026#34;); iframeArray instanceof Array; // ❌ false Array.isArray(iframeArray); // ✅ true Why? Because iframeArray\u0026rsquo;s prototype chain points to iframe’s Array.prototype, not yours.\nThis is why you should always use:\nArray.isArray(obj) Object.prototype.toString.call(obj) …and never rely on instanceof when realms might be involved.\n2. 🪐 Global Object and globalThis Each realm gets its own global object, which defines the top-level scope.\nDepending on the context, this global object could be:\nA Window (in a tab or iframe) A WorkerGlobalScope (in a worker) A WorkletGlobalScope (in an audio or paint worklet) window.globalThis === window; // ✅ in a tab self.globalThis === self; // ✅ in a worker Each realm has a unique globalThis — they don’t bleed into each other.\n3. 🧠 Template Literal Cache Tagged template literals reuse the same array object on repeated calls within the same realm:\nfunction tag(strings) { console.log(strings); // same object each time } tag`hello`; // strings === [\u0026#34;hello\u0026#34;] tag`hello`; // strings is the same object But that cache is per-realm. Use a different realm (like an iframe), and you\u0026rsquo;ll get a different array object, even with the same template.\n🧩 Realms vs Agents Let’s clarify the distinction:\nConcept Realm Agent What it is A JS environment with its own global scope \u0026amp; built-ins A JS thread (executor of code) Count Multiple per agent One per thread Global object Unique per realm (window, self, etc.) Not shared across agents Memory Shared heap (within same agent) Isolated between agents unless using SharedArrayBuffer 🔁 Realms Can Talk (if in same agent) If you have:\n\u0026lt;iframe src=\u0026#34;same-origin.html\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; You can synchronously access the iframe’s realm:\niframe.contentWindow.document.title; // ✅ works But remember: it\u0026rsquo;s a different realm. So be cautious with identity checks.\n🔐 Why Realms Matter in the Real World 1. Security and Isolation Realms provide containment: Each realm is sandboxed with its own set of built-ins and globals. Cross-origin iframes get different agents and different realms, enforcing strict separation. 2. Framework \u0026amp; Testing Tooling Tools like Jest, JSDOM, or sandboxed evaluators often run code in isolated realms to prevent global pollution. 3. Micro-frontend Architecture In advanced front-end architectures, teams load independent apps in iframes or ShadowRealms to prevent conflicts. 4. Cross-Realm Bugs If you\u0026rsquo;re building libraries, especially polyfills or type-checking utils, you must account for realm differences. // Anti-pattern value instanceof Object; // ❌ not safe across realms // Safe alternative Object.prototype.toString.call(value) === \u0026#34;[object Object]\u0026#34;; // ✅ 🧠 Takeaways A realm is a self-contained JS universe — with its own global scope and its own versions of built-in types. Realms can coexist inside a single agent, but their built-ins and identity checks do not overlap. Always prefer realm-safe methods (Array.isArray, Object.prototype.toString.call) over instanceof. Understand realms if you\u0026rsquo;re working with: iframes workers multi-app frontends testing sandboxes serialization/deserialization across origins 📌 Bonus: ShadowRealm (TC39 Stage 3) A new JS feature, ShadowRealm, allows you to create a new realm programmatically without using iframes:\nconst realm = new ShadowRealm(); const result = realm.evaluate(`1 + 1`); // 2 This is realm-level isolation, but still within the same agent. Great for security, testing, or plugin systems.\n✍️ Final Word JavaScript realms are like alternate realities — isolated yet interconnected in subtle ways. They influence how your objects behave, how identity is checked, and how memory is managed.\nUnderstanding realms is a superpower — especially if you’re debugging strange prototype issues or building frameworks and platforms. Master this layer, and you’re one step closer to mastering the entire JavaScript execution model.\n6. 🌐 Agent Types in the Web Platform 6.1. Main Window Agent 6.2. Dedicated Worker Agent 6.3. Shared Worker Agent 6.4. Service Worker Agent 6.5. Worklet Agent Each has its own heap, stack, queue Communication model (postMessage, SharedArrayBuffer) 6. 🌐 Agent Types in the Web Platform The web isn\u0026rsquo;t just one giant thread where all JavaScript code runs together. Instead, it\u0026rsquo;s composed of multiple agents — isolated, independent runtimes that can each execute JS code with their own heap, call stack, and event loop. Understanding these agent types is crucial for mastering concurrency, memory isolation, and performance design patterns in modern web development.\nLet’s break down the main types of agents and why they matter:\n6.1 🪟 Main Window Agent This is the agent you interact with most — the tab in your browser running HTML, CSS, and JavaScript. It includes:\nThe global window object Access to the DOM Full access to browser APIs (e.g., document, alert, fetch) Multiple same-origin iframes can share the same agent, meaning they share the call stack and can synchronously call each other’s functions and access each other’s memory (within security limits).\n📌 Key traits:\nHas direct DOM access Can synchronously communicate with same-origin iframes Cannot be blocked via Atomics.wait() 🧠 Mental model: A control room managing user interaction, UI rendering, and input events — all on one thread.\n6.2 👷 Dedicated Worker Agent Created via new Worker(), a Dedicated Worker runs JS in a completely separate agent — its own isolated thread. It doesn’t have access to the DOM, but can perform heavy computations without blocking the main thread.\n📦 Separate agent = separate memory:\nOwn heap Own call stack Own event loop 🧠 Think of it like spawning a specialized assistant: you give it instructions via postMessage(), and it replies asynchronously.\n✅ Can use SharedArrayBuffer for shared memory (with proper CORS and COOP/COEP headers)\n💻\nconst worker = new Worker(\u0026#34;worker.js\u0026#34;); worker.postMessage({ task: \u0026#34;compute\u0026#34; }); 6.3 🤝 Shared Worker Agent Shared Workers are like Dedicated Workers, but shared across multiple same-origin contexts — tabs, iframes, or windows. They persist beyond a single page and can maintain shared state (like a single WebSocket connection).\n📌 Key distinction: They do not share memory with their clients. All communication is through postMessage() using structured cloning.\n🧠 Metaphor: A shared database or message bus multiple clients talk to, but no one can directly poke into its memory.\n6.4 🛰 Service Worker Agent A Service Worker is a proxy-like agent that sits between your web app and the network. It doesn’t have a UI and cannot touch the DOM, but it can:\nIntercept network requests Serve cached assets Enable offline experiences Run even when the page is closed 📦 It has its own agent — its own heap, stack, and event queue — and doesn’t share memory with any window.\n🧠 Think of it as a background daemon that acts as a programmable router.\n💡 Bonus: Service workers are essential for building Progressive Web Apps (PWAs).\n6.5 🎨 Worklet Agent Worklets are ultra-lightweight, low-latency agents used for frame-by-frame operations in:\nAudioWorklet (real-time DSP) PaintWorklet (CSS custom painting) LayoutWorklet (custom layout logic) These agents are stripped down for speed — no DOM, no network access, but real-time-safe execution.\n🧠 Imagine a tiny artist or sound engineer working just fast enough to keep up with your browser’s 60FPS heartbeat.\n📌 They run inside their own agent and can be memory-shared with their creators using SharedArrayBuffer.\n🧬 All Agent Types Have: ✅ Their own execution context:\nHeap: where objects live Call stack: for function execution Job queue: for async callbacks (event loop) ✅ Communication model:\n🔁 postMessage() for asynchronous messaging (structured cloning) 🔗 SharedArrayBuffer + Atomics for shared memory and synchronization (if in the same agent cluster) 🧠 Summary Table Agent Type DOM Access Memory Sharing Shared Across Tabs? Use Case Main Window Agent ✅ Yes ✅ with same-origin iframes ❌ UI logic, DOM interaction Dedicated Worker ❌ No ✅ via SharedArrayBuffer ❌ Heavy computation, parallel tasks Shared Worker ❌ No ❌ ✅ Cross-tab state sync, WebSocket hub Service Worker ❌ No ❌ ✅ Offline support, request caching Worklet ❌ No ✅ (when configured) ❌ Real-time audio/visual processing 🔗 Related Concepts: Agent Cluster: A group of agents that can share memory (SharedArrayBuffer) and synchronize with Atomics. Structured Cloning: Default communication method — objects are copied, not shared. Heap / Stack / Queue: Every agent gets their own — enabling safe, parallel, isolated execution. 📣 Takeaway:\nModern JavaScript isn’t single-threaded anymore — it’s multi-agent.\nYou, as a developer, control which type of agent runs your code — and how they communicate. Choose wisely based on memory safety, responsiveness, and your app’s architecture.\n7. 🔁 Job Queue \u0026amp; Event Loop Modern JavaScript feels synchronous — but behaves asynchronously. That paradox is powered by one of the most elegant constructs in programming: the event loop.\nLet’s dive deep into how JavaScript keeps your code non-blocking, predictable, and responsive — using jobs, queues, and a beautiful bit of choreography called the run-to-completion model.\n7.1 🔧 What is a Job? Callback + Execution Context = Job\nEvery time your code hands off a function to be called later — say, via setTimeout, a Promise, or a DOM event — you\u0026rsquo;re scheduling a job. Think of it as a tiny program JS will run once it’s done with the current one.\nThese jobs are stored in queues and executed one at a time, with guaranteed order and isolation.\n🧠 Mental Model:\nEach job is like a fully wrapped meal order — a recipe (callback) bundled with ingredients (execution context). JS cooks them one-by-one, never two at once.\n7.2 🔄 Event Loop: The Scheduler-in-Chief At the heart of this system is the event loop, the mechanism that:\nWaits for the stack to be empty Pulls the next job from the queue Executes it entirely before moving on This is the run-to-completion guarantee.\n💡 Why it matters:\nNo two callbacks ever run at the same time Shared variables are safe during a job Your program stays predictable and easy to reason about console.log(\u0026#34;A\u0026#34;); setTimeout(() =\u0026gt; console.log(\u0026#34;B\u0026#34;), 0); console.log(\u0026#34;C\u0026#34;); // Output: // A // C // B 🔍 Even though the timer is 0ms, it gets queued as a job and only runs after current code finishes.\n7.3 ⚖️ Microtasks vs Macrotasks Not all jobs are equal. The queue is actually two queues:\nType Examples Priority Microtasks Promise.then, queueMicrotask() 🔥 High (drained first) Macrotasks setTimeout, setInterval, DOM events ⏳ Lower After every job (macro or otherwise), the event loop drains all microtasks before running the next macro task.\nconsole.log(\u0026#34;Start\u0026#34;); setTimeout(() =\u0026gt; console.log(\u0026#34;Timeout\u0026#34;), 0); Promise.resolve().then(() =\u0026gt; console.log(\u0026#34;Promise\u0026#34;)); console.log(\u0026#34;End\u0026#34;); // Output: // Start // End // Promise // Timeout 📌 Microtasks are prioritized — even over timers.\n🧠 Metaphor:\nMicrotasks are sticky notes on your desk. Macrotasks are meetings. After finishing a job (macro), JS clears all sticky notes (micro) before going to the next meeting.\n7.4 🧵 Blocking vs Non-Blocking JS\u0026rsquo;s single-threaded nature means blocking is dangerous — if your code stalls, your UI freezes, your app becomes unresponsive.\n✅ Async I/O — like fetch, setTimeout, readFile — is non-blocking by design.\n🚫 But legacy APIs can block the agent entirely:\nAPI Behavior alert() Blocks entire tab confirm() Blocking XMLHttpRequest (sync) Blocking 💡 Even while(true){} loops will freeze your app.\n🔍 Modern JavaScript avoids blocking at all costs by using:\nThe event loop The job queue And a non-blocking I/O model 💡 Final Mental Model Visualize JavaScript as a factory:\n🏗️ Call Stack: The active workstation (only one at a time) 📬 Job Queue: A mailbox full of tasks to run 🔁 Event Loop: A robot that: Waits for the workstation to be free Picks the next job from the mailbox Ensures no job starts until the last one finishes And among the jobs:\n📝 Microtasks are urgent memos — always read before any new mail. ⏰ Macrotasks are full packages — scheduled deliveries that wait their turn. This model gives JS its magic mix of simplicity + power:\nSingle-threaded but never frozen (if you follow the rules) Predictable execution with async capabilities Safe by default, powerful when needed Next time you wonder why Promises beat timers, or why your UI freezes, or why console.log shows up before your setTimeout, remember:\nYou’re not just writing code — you’re orchestrating a symphony of jobs in a beautifully synchronized single-threaded engine.\n8. 🧠 Concurrency \u0026amp; Memory Sharing In the world of JavaScript, we often talk about single-threaded execution, the event loop, and asynchronous callbacks. But what happens when multiple threads—agents, in ECMAScript speak—need to share memory and coordinate? That’s where agent clusters, shared memory, and atomic operations come in.\nThis section dives into JavaScript’s low-level concurrency primitives, showing how modern engines manage parallelism safely using shared memory, and how developers can reason about memory consistency, data races, and synchronization.\n8.1 ⚡ Agent Clusters: Who Can Share Memory with Whom? In JavaScript, every independent execution context—like a tab, worker, or iframe—is called an agent. But not all agents are created equal. Only some can share memory.\nAgents that can share memory form what\u0026rsquo;s called an agent cluster.\n🧠 Core Rule: If two agents can share a SharedArrayBuffer, they belong to the same cluster. If not, they are completely isolated.\n✅ In the Same Cluster (can share memory): A Window and the Dedicated Worker it creates A Worker and the Dedicated Worker it spawns A Window and a same-origin iframe A Window and a same-origin opener window A Window and its Worklet ❌ Different Clusters (can’t share memory): A Window and a SharedWorker A Window and a ServiceWorker A Worker and a SharedWorker Two unrelated same-origin Window objects A Window and a cross-origin iframe Think of agent clusters like secure bubbles. If two agents are in the same bubble, they can point to the same memory. If not, even passing a reference is forbidden.\n8.2 🧠 Shared Memory with SharedArrayBuffer JavaScript is traditionally copy-by-value when agents communicate. That’s how postMessage() works: it sends a structured clone of the data.\nBut there’s one exception: SharedArrayBuffer.\n🧬 Metaphor: Normally, you\u0026rsquo;re emailing someone a photocopy of your notebook. With SharedArrayBuffer, you\u0026rsquo;re giving them the same notebook, and now you both can write in it—simultaneously.\n🔗 How It Works: const sab = new SharedArrayBuffer(1024); // shared memory const view = new Int32Array(sab); // typed view worker.postMessage(sab); // no clone — both now point to the same memory Now both the main thread and the worker share that memory. But shared access means concurrent access, and that leads us to…\n8.3 🔒 Synchronizing with Atomics Just because memory is shared doesn’t mean it’s safe.\n🧠 Regular JS assignments like arr[0] = arr[0] + 1 are not atomic and can be torn apart when run from two agents at once.\nThat’s why ECMAScript gives us Atomics: a namespace of operations that guarantee safe, lock-free memory coordination.\n🛠 Tools in the Atomics toolbox: Atomics.load(view, index) — safely read Atomics.store(view, index, value) — safely write Atomics.add, sub, and, or, xor, etc. — read-modify-write Atomics.wait(view, index, value) — block until value changes Atomics.notify(view, index, count) — wake up blocked agents // Thread 1 while (Atomics.load(view, 0) !== 1) { Atomics.wait(view, 0, 0); // wait until someone sets it to 1 } // Thread 2 Atomics.store(view, 0, 1); Atomics.notify(view, 0); This pattern enables thread-style coordination between agents — like building your own semaphores or locks.\n⚠️ Only dedicated or shared workers can be blocked using Atomics.wait(). Windows and service workers are never allowed to block.\n8.4 📏 Memory Consistency and Data Races JavaScript’s memory model ensures predictable behavior only if you follow certain rules.\n✅ Data race–free = safe, consistent, sequential semantics\n❌ Data races = torn values, weird bugs, and undefined behavior\n⚠️ What’s a Data Race? When two agents access the same memory location at the same time, and at least one of them writes, without proper synchronization.\n🧪 Example of value tearing: // One agent writes a 32-bit int arr[0] = 0x12345678; // Another agent reads only the first 16 bits mid-write Result? You read a garbage value like 0x12340000. That’s value tearing.\n🔒 Rule of Thumb: Always access shared memory via Atomics. Use the same access size and typed array across all agents. Avoid mixing atomic and non-atomic operations on the same memory cell. 🧠 Why This Matters Shared memory gives us high-performance parallelism in JavaScript — without blocking the main thread.\nBut it comes with the responsibility of:\nDefining clear communication patterns Designing for race-freedom Understanding that postMessage() ≠ shared memory unless you use SharedArrayBuffer Avoiding subtle bugs from cross-agent memory inconsistencies 📦 In Summary Concept Description Agent Cluster Group of JS agents that can share memory SharedArrayBuffer Enables memory sharing between agents Atomics Enables safe, lock-free communication on shared memory Data Race When agents read/write same memory without sync Sequential Consistency All agents see memory changes in the same order if no races 💭 Final Thought The introduction of shared memory and Atomics fundamentally changes what JavaScript is capable of — enabling parallel algorithms, real-time audio processing, and high-throughput computation. But it also demands a new level of rigor. Just as Promise taught us to think about time, SharedArrayBuffer and Atomics teach us to think about space — and how multiple minds can share the same thoughts without stepping on each other’s toes.\nWelcome to the world of concurrent JavaScript — where your variables can now live in more than one mind at once.\n9. 🚧 Cluster Lifecycle \u0026amp; Blocking Modern JavaScript engines have evolved into distributed runtimes. And yet, most developers still think in terms of \u0026ldquo;single-threaded async code\u0026rdquo;. But under the hood, agents, clusters, and shared memory enable fine-grained concurrency.\nThis section explores what really happens when JS environments start talking — and blocking — across boundaries.\n9.1. 🧱 Blocking APIs (Atomics.wait) 🧠 What does \u0026ldquo;blocking\u0026rdquo; actually mean in JavaScript? We’re used to await yielding control — letting the event loop breathe. But Atomics.wait()? That’s a different beast.\nAtomics.wait(int32Array, 0, 0); // 💥 BLOCKS the agent This is not like Promises. It completely freezes the thread.\n✅ Promise = async yield Returns control to the event loop Lets other jobs run while waiting ❌ Atomics.wait = sync block Halts everything in that agent (no event loop progress) Nothing else in that thread runs until another agent calls Atomics.notify 🧬 Mental Model:\nA waiter (Promise) steps aside while the kitchen runs. A locked door (Atomics.wait) freezes the kitchen until someone unlocks it.\n9.2. 🛡 Forward Progress Guarantees Concurrency is dangerous — race conditions, deadlocks, and starvation are real risks.\nThat’s why ECMAScript enforces forward progress guarantees, even in multi-agent systems.\nIf multiple agents share the same thread, the runtime must ensure no agent starves forever.\n💡 Fairness by design: The engine cannot ignore one agent just because another is busy. Even if two agents are blocking each other via Atomics, the spec mandates that some agent makes progress. 📦 Why this matters: Imagine two workers sharing memory. If worker A holds a lock and gets suspended forever, and worker B is waiting to acquire it — you’ve just created a distributed deadlock.\nThe JavaScript memory model prevents that scenario by ensuring all agents in a cluster eventually get time to run.\n🧠 Intuition: Even in tight concurrency loops, JavaScript won’t let one agent monopolize the thread indefinitely.\n9.3. 💥 Agent Termination: The Cluster Is a Single Failure Domain Terminate one agent in a cluster, and you kill them all.\nThis is one of the lesser-known — but crucial — constraints of agent clusters.\n✅ If agents share memory, they’re in the same cluster. 🔥 If one crashes, they all go down. Why?\nBecause allowing a shared-memory cluster to continue operating with a missing participant would:\nRisk memory corruption Break lock semantics Violate deterministic state models 🧬 System-level analogy: Imagine a nuclear power grid with interdependent control units. If one node goes offline during a write, the entire system must halt to avoid undefined behavior.\n🧪 What about fault-tolerance? Interestingly, the ECMAScript spec mentions a second strategy: detect a terminated agent and let others recover.\nBut:\n🔒 It’s not implemented in any browser 🛠 Still a theoretical model — not production-grade yet ⚠️ Takeaways for System Builders If you’re using SharedArrayBuffer, Atomics, or any worker model with shared memory:\n✅ Understand agent clusters: memory sharing defines membership 🧠 Don’t rely on postMessage for real concurrency — use SAB + Atomics intentionally 🛑 Avoid assuming you can recover from crashes inside a cluster — you can’t (yet) 🧵 Be aware of blocking: Promises = cooperative, Atomics = hard locks 📌 Final Thought:\nShared memory brings power — and responsibility. You’re no longer in JavaScript’s comfy async sandbox. You’re in systems-land now — where deadlocks, race conditions, and cluster-wide failure are real threats.\nUse the power. Know the cost.\n🔗 10. Putting It All Together 🎯 Why this section matters: Everything we’ve explored — stacks, heaps, queues, jobs, realms, agents, workers, shared memory — now comes together into a unified execution trace. This is where theory meets runtime. This is where your intuition levels up.\n10.1 ⚙️ Full Execution Trace Let’s simulate a complete run of a JavaScript program involving:\n🧠 Synchronous execution (stack) ⏰ setTimeout (macro-task queue) 💬 Promise (microtask queue) 🔁 Nested function calls 🔄 Event loop orchestration 💻 Code Example: console.log(\u0026#34;Start\u0026#34;); setTimeout(() =\u0026gt; { console.log(\u0026#34;Timeout 1\u0026#34;); }, 0); Promise.resolve().then(() =\u0026gt; { console.log(\u0026#34;Promise 1\u0026#34;); }); console.log(\u0026#34;End\u0026#34;); 🔁 Execution Timeline Step Stack Microtask Queue Task Queue Output 1 global() 2 log(\u0026ldquo;Start\u0026rdquo;) Start 3 setTimeout(\u0026hellip;) [Timeout callback] 4 Promise.then(\u0026hellip;) [Promise callback] [Timeout callback] 5 log(\u0026ldquo;End\u0026rdquo;) [Promise callback] [Timeout callback] End 6 Execute microtask [] [Timeout callback] Promise 1 7 Execute macro task [] [] Timeout 1 🧠 Metaphor: Call stack is your desk — only one function open at a time. Microtasks are sticky notes stuck to the monitor — you handle them after the current task, but before picking a new one from the task queue. Macro-tasks (setTimeout) are tasks waiting in your inbox — they only get attention after all microtasks are done. 🔗 Connections Stack: Tracks what code is currently running. Heap: Stores Promise, callback functions. Job Queue: Schedules promise callbacks (microtasks). Task Queue: Schedules setTimeout, events (macro-tasks). Event Loop: Pulls from microtask → then macro → repeat. 🧬 Subtle Gotchas Promise.then always runs before setTimeout, even if setTimeout has 0ms delay. This is because microtask queue is prioritized over macro-task queue. 10.2 🧠 Mental Models \u0026amp; Visuals 📊 Timeline Diagram Time → | Stack: log(\u0026#34;Start\u0026#34;) → log(\u0026#34;End\u0026#34;) → [Empty] | Microtask: → Promise.then() → [Empty] | Task: setTimeout() → → setTimeout() Output: Start End Promise 1 Timeout 1 🧩 Stack–Heap–Queue Visualization ┌──────────────────────┐ │ Call Stack │ ← Runs synchronous code (one frame at a time) ├──────────────────────┤ │ Global Execution │ └──────────────────────┘ ┌──────────────────────┐ │ Heap │ ← Stores objects, closures, promises ├──────────────────────┤ │ Promise, callbacks… │ └──────────────────────┘ ┌──────────────────────┐ │ Microtask Q │ ← Promise callbacks (then, catch) ├──────────────────────┤ │ () =\u0026gt; console.log… │ └──────────────────────┘ ┌──────────────────────┐ │ Task Queue │ ← Timers, UI events ├──────────────────────┤ │ setTimeout cb… │ └──────────────────────┘ 🧭 Cross-Realm \u0026amp; Agent Flowchart [ Window (Agent A) ] │ ├─ setTimeout() → Task Queue ├─ Promise.then() → Microtask Queue ├─ Web Worker (Agent B) │ ├─ Own Heap │ ├─ Own Stack │ └─ Communicates via postMessage or SharedArrayBuffer │ └─ iframe (Realm B, same agent) ├─ Own GlobalThis └─ Shared Stack/Queue (if same-origin) 🎯 Interview Insight If you truly understand this unified flow, you can:\nPredict async code output reliably. Avoid callback hell and race conditions. Understand Node.js concurrency patterns. Handle shared memory in web workers safely. ✅ Final Thought JavaScript isn’t just “single-threaded.”\nIt’s a coordinated choreography of:\nAgents (runners) Realms (universes) Heaps (long-term memory) Stacks (call trace) Queues (scheduling) Event loop (the director) Master this mental model, and you\u0026rsquo;re not just writing JS — you\u0026rsquo;re orchestrating time.\n","permalink":"https://archit15singh.github.io/posts/2022-07-29-js-execution-model-in-depth/","summary":"\u003ch1 id=\"how-javascript-really-runs-from-engines-to-event-loop-execution-model-deep-dive\"\u003eHow JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive)\u003c/h1\u003e\n\u003chr\u003e\n\u003ch2 id=\"-what-this-series-will-teach-you\"\u003e🚀 What This Series Will Teach You\u003c/h2\u003e\n\u003cp\u003eThis blog post is the first step of a \u003cstrong\u003emulti-part deep dive\u003c/strong\u003e into the JS execution model. You’ll learn:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHow JavaScript handles synchronous and asynchronous code\u003c/li\u003e\n\u003cli\u003eWhat the call stack, job queue, microtasks, and event loop really are\u003c/li\u003e\n\u003cli\u003eHow realms, agents, and execution contexts work together\u003c/li\u003e\n\u003cli\u003eHow engines like V8 optimize while staying spec-compliant\u003c/li\u003e\n\u003cli\u003eWhy seemingly simple code can behave unexpectedly — and how to reason through it\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eEach section will build your mental model — with visuals, real code traces, intuitive metaphors, and runtime behavior breakdowns.\u003c/p\u003e","title":"How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive)"},{"content":"This is just a test post!\nTesting quotes\nItalics\nBold!\nHeading 1 Heading 2 Heading 3 Heading 4 Heading 5 Heading 6 Bulleted list 1 Bulleted list 2 Bulleterd list 3 Ordered list Ordered list Ordered list ","permalink":"https://archit15singh.github.io/posts/2022-07-29-test-post/","summary":"\u003cp\u003eThis is just a test post!\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eTesting quotes\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e\u003cem\u003eItalics\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eBold!\u003c/strong\u003e\u003c/p\u003e\n\u003ch1 id=\"heading-1\"\u003e\u003cstrong\u003eHeading 1\u003c/strong\u003e\u003c/h1\u003e\n\u003ch2 id=\"heading-2\"\u003eHeading 2\u003c/h2\u003e\n\u003ch3 id=\"heading-3\"\u003eHeading 3\u003c/h3\u003e\n\u003ch4 id=\"heading-4\"\u003eHeading 4\u003c/h4\u003e\n\u003ch5 id=\"heading-5\"\u003eHeading 5\u003c/h5\u003e\n\u003ch6 id=\"heading-6\"\u003eHeading 6\u003c/h6\u003e\n\u003cul\u003e\n\u003cli\u003eBulleted list 1\u003c/li\u003e\n\u003cli\u003eBulleted list 2\u003c/li\u003e\n\u003cli\u003eBulleterd list 3\u003c/li\u003e\n\u003c/ul\u003e\n\u003col\u003e\n\u003cli\u003eOrdered list\u003c/li\u003e\n\u003cli\u003eOrdered list\u003c/li\u003e\n\u003cli\u003eOrdered list\u003c/li\u003e\n\u003c/ol\u003e","title":"Test Post"},{"content":"Social Icons Name Platform Link 123rf 123rf.com adobestock stock.adobe.com apple music music.apple.com behance behance.net bilibili bilibili.com bitcoin - buymeacoffee buymeacoffee.com codepen codepen.io cryptohack cryptohack.org ctftime ctftime.org cv - deezer deezer.com dev dev.to discogs discogs.com discord discord.com dreamstime dreamstime.com dribbble dribbble.com email - facebook facebook.com flickr flickr.com freepik freepik.com gitea gitea.io github github.com gitlab gitlab.com goodreads goodreads.com googlescholar scholar.google.com guruShots gurushots.com hackerone hackerone.com hackerrank hackerrank.com hackthebox hackthebox.eu instagram instagram.com itchio itch.io kaggle - kakaotalk kakaocorp.com/service/KakaoTalk key - keybase keybase.io kofi ko-fi.com komoot - lastfm last.fm letterboxd - liberapay liberapay.com linkedin linkedin.com mastodon mastodon.social matrix matrix.org medium medium.com monero - mixcloud mixcloud.com nuget nuget.org paypal paypal.com peertube - pgp - phone - ploywork ploywork.com qq qq.com reddit reddit.com researchgate researchgate.net rss - serverfault serverfault.com soundcloud soundcloud.com shutterstock shutterstock.com slack slack.com snapchat snapchat.com/add spotify spotify.com stackoverflow stackoverflow.com steam steampowered.com strava strava.com telegram telegram.org `tiktok tiktok.com twitch twitch.tv twitter twitter.com unsplash unsplash.com xda xda-developers.com xing xing.com ycombinator ycombinator.com youtube youtube.com other - Usage :\nsocialIcons: - name: \u0026#34;kofi\u0026#34; url: \u0026#34;https://kofi.com\u0026#34; - name: \u0026#34;twitter\u0026#34; url: \u0026#34;https://twitter.com\u0026#34; Share Icons No. Platform twitter (also generates hash tags from tags linked with post) linkedin reddit facebook whatsapp telegram Usage:\nparams: ShowShareButtons: true params: ShareButtons: [\u0026#34;linkedin\u0026#34;, \u0026#34;twitter\u0026#34;] # To customize which share buttons to be enabled on page ","permalink":"https://archit15singh.github.io/posts/papermod-icons/","summary":"List of all Icons supported by PaperMod","title":"Icons"},{"content":"Below are variables used with this theme\u0026hellip;\nSite Variables under Params name type example Description env string \u0026lsquo;production\u0026rsquo; To set env to production title string \u0026lsquo;My Blog\u0026rsquo; To set title description string \u0026lsquo;This is a blog of mine\u0026rsquo; To set site description author string |list \u0026lsquo;Me\u0026rsquo; | [\u0026lsquo;Me\u0026rsquo;,\u0026lsquo;You\u0026rsquo;] To show multiple Authors images string \u0026lsquo;myimage.png\u0026rsquo; Link or path of image for opengraph, twitter-cards keywords list [blog, page] Add keywords for Home page DateFormat string \u0026ldquo;January 2, 2006\u0026rdquo; The format of date strings in the website. Details languageAltTitle string \u0026ldquo;English\u0026rdquo; Alternate title in Multilingual Mode ShowReadingTime boolean true | false To show read time in post meta ShowShareButtons boolean true | false To show/hide share buttons under post ShowCodeCopyButtons boolean true | false To show/hide Code Copy button ShowFullTextinRSS boolean true | false To show Content in RSS feed defaultTheme string light | dark | auto To set default theme disableThemeToggle boolean true | false To disable theme toggle icon shown besides label disableSpecial1stPost boolean true | false To disable no-card special appearance of 1st post disableScrollToTop boolean true | false To disable ScrollToTop button disableAnchoredHeadings boolean true | false To disable Anchored Headings hideMeta boolean true | false To Hide meta elements : date, read-time, author and available-translations for page hideSummary boolean true | false To Hide summary being shown in list pages showtoc boolean true | false To show/hide Table of Contents tocopen boolean true | false To keep open ToC by default on page load ShowPostNavLinks boolean true | false Show Previous and Next Posts below a Post ShowBreadCrumbs boolean true | false Show BreadCrumb Navigation above single post/page ShareButtons list [\u0026ldquo;linkedin\u0026rdquo;, \u0026ldquo;twitter\u0026rdquo;] To customize which share buttons to be enabled on page ShowWordCount boolean true | false To word count to metadata ShowRssButtonInSectionTermList boolean true | false To show RSS icon in Section, Term and List pages UseHugoToc boolean true | false To use Hugo\u0026rsquo;s default Toc instead of custom comments boolean true | false To show/hide comments hideFooter boolean true | false To Hide Footer Text om the end of page CanonicalLinkText string \u0026lsquo;Originally published at\u0026rsquo; To show text before canonical URL\u0026rsquo;s hostname analytics.google.SiteVerificationTag string \u0026ldquo;XYZabc\u0026rdquo; Site Verification Tag for Google Analytics analytics.bing.SiteVerificationTag string \u0026ldquo;XYZabc\u0026rdquo; Site Verification Tag for Bing analytics.yandex.SiteVerificationTag string \u0026ldquo;XYZabc\u0026rdquo; Site Verification Tag for Yandex schema - - Details fuseOpts - - Details socialIcons - - Details label - - Details assets - - Details cover - - Details profileMode - - Details editPost - - Details Site Variables name type example Description copyright string **[example.site](https://example.site)** This is HUGO\u0026rsquo;s site variable, which can also render markdown content label name type example Description label.text string \u0026lsquo;Home\u0026rsquo; To display different label text other than title label.icon string \u0026lsquo;/apple-touch-icon.png\u0026rsquo; To display a logo image in label label.iconHeight integer 35 To set size of label logo image profileMode name type example Description profileMode.enabled boolean true | false For enabling profileMode, needs to be explicitly set profileMode.title string \u0026ldquo;Title\u0026rdquo; Title profileMode.subtitle string \u0026ldquo;subtitle here\u0026rdquo; Subtitle profileMode.imageUrl string \u0026ldquo;image.png\u0026rdquo; | \u0026ldquo;https://example.com/image.jpg\" Image URL or Link profileMode.imageWidth string \u0026ldquo;150\u0026rdquo; Width of image profileMode.imageHeight string \u0026ldquo;150\u0026rdquo; Height of image profileMode.imageTitle string \u0026ldquo;This image is a picture of ..\u0026rdquo; Title of image profileMode.buttons - - Details profileMode.buttons profileMode: buttons: - name: Archive url: \u0026#34;/archive\u0026#34; - name: Github url: \u0026#34;https://github.com/\u0026#34; assets name type example Description assets.favicon string \u0026lsquo;icon.ico\u0026rsquo; To set favicon, can be path or external link assets.disableHLJS boolean true | false To disable Highlight.js loading assets.disableFingerprinting boolean true | false To disable Sub-Resource integrity for assets assets.theme_color string \u0026lsquo;#color\u0026rsquo; To set custom meta theme-color assets.msapplication_TileColor string \u0026lsquo;#color\u0026rsquo; To set custom msapplication_TileColor cover name type example Description cover.linkFullImages boolean true | false To open full size cover images on click on cover cover.responsiveImages boolean true | false To enable/disable generation of responsive cover images cover.hidden boolean true | false To hide everywhere but not in structured data cover.hiddenInList boolean true | false To hide on list pages and home cover.hiddenInSingle boolean true | false To hide on list pages and home schema name type example Description schema.publisherType string \u0026lsquo;Organization\u0026rsquo; https://schema.org/publisher schema.sameAs list [\u0026ldquo;URL1\u0026rdquo;, \u0026ldquo;URL2\u0026rdquo;] Set https://schema.org/sameAs fuseOpts Refer: https://fusejs.io/api/options.html\nfuseOpts: isCaseSensitive: false shouldSort: true location: 0 distance: 1000 threshold: 0.4 minMatchCharLength: 0 keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;content\u0026#34;] ## can be less but not more than shown in list socialIcons socialIcons: - name: \u0026#34;\u0026lt;platform\u0026gt;\u0026#34; url: \u0026#34;\u0026lt;link\u0026gt;\u0026#34; - name: \u0026#34;\u0026lt;platform 2\u0026gt;\u0026#34; url: \u0026#34;\u0026lt;link2\u0026gt;\u0026#34; editPost editPost: URL: \u0026#34;https://github.com/\u0026lt;path_to_repo\u0026gt;/content\u0026#34; Text: \u0026#34;Suggest Changes\u0026#34; # edit text appendFilePath: true # to append file path to Edit link Note: Same format is being used by Page Variables\nPage Variables Name Type Example Description showtoc boolean true | false To show/hide Table of Contents tocopen boolean true | false To keep open ToC by default on page load hidemeta boolean true | false To Hide meta elements : date, read-time, author and available-translations for page comments boolean true | false To show/hide comments description string \u0026lsquo;description text\u0026rsquo; Show Post Description under Title canonicalURL string \u0026ldquo;https://canonical.url/to/page\" To add canonical URL to posts ShowCanonicalLink boolean true | false To show canonical URL\u0026rsquo;s hostname CanonicalLinkText string \u0026lsquo;Originally published at\u0026rsquo; To show text before canonical URL\u0026rsquo;s hostname disableShare boolean true | false To hide/show share icons under a page disableHLJS boolean true | false To disable Highlight.js loading disableAnchoredHeadings boolean true | false To disable Anchored Headings searchHidden boolean true | false Hide page from search hideSummary boolean true | false To Hide summary being shown in list pages hideFooter boolean true | false To Hide Footer Text om the end of page ShowReadingTime boolean true | false To show read time in post meta ShowBreadCrumbs boolean true | false Show BreadCrumb Navigation above single post/page ShowPostNavLinks boolean true | false Show Previous and Next Posts below a Post ShowCodeCopyButtons boolean true | false To show/hide Code Copy button author string |list \u0026lsquo;Me\u0026rsquo; | [\u0026lsquo;Me\u0026rsquo;,\u0026lsquo;You\u0026rsquo;] To show multiple Authors cover.image string \u0026lsquo;featured.jpg\u0026rsquo; To add a cover image cover.caption string \u0026lsquo;caption for image\u0026rsquo; To add caption to cover image cover.alt string \u0026rsquo;this is cover image\u0026rsquo; Alternate text to show if image doesn\u0026rsquo;t load/show up cover.relative boolean true | false To use relative path for cover image, used in hugo Page-bundles cover.responsiveImages boolean true | false To enable/disable generation of responsive cover images cover.hidden boolean true | false To hide on current single page weight integer 5 To set page order or to pin a post to Top of list ShareButtons list [\u0026ldquo;linkedin\u0026rdquo;, \u0026ldquo;twitter\u0026rdquo;] To customize which share buttons to be enabled on page ShowWordCount boolean true | false To word count to metadata ShowRssButtonInSectionTermList boolean true | false To show RSS icon in Section, Term and List pages UseHugoToc boolean true | false To use Hugo\u0026rsquo;s default Toc instead of custom robotsNoIndex boolean true | false To hide a particular page from indexing by search engines ","permalink":"https://archit15singh.github.io/posts/papermod-variables/","summary":"List of Front Matter variables used by PaperMod","title":"Variables | Front Matter"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code Code Blocks Inline Code This is Inline Code\nOnly pre This is pre text Code block with backticks \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with backticks and language specified 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;Sample article showcasing basic Markdown syntax and formatting for HTML elements.\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Gist List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://archit15singh.github.io/posts/markdown-syntax/","summary":"\u003cp\u003eThis article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\u003c/p\u003e","title":"Markdown Syntax Guide"},{"content":"Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\nYouTube Privacy Enhanced Shortcode Twitter Simple Shortcode “In addition to being more logical, asymmetry has the advantage that its complete appearance is far more optically effective than symmetry.”\n— Jan Tschichold pic.twitter.com/gcv7SrhvJb\n\u0026mdash; Design Reviewed | Graphic Design History (@DesignReviewed) January 17, 2019 Vimeo Simple Shortcode ","permalink":"https://archit15singh.github.io/posts/rich-content/","summary":"\u003cp\u003eHugo ships with several \u003ca href=\"https://gohugo.io/content-management/shortcodes/#use-hugos-built-in-shortcodes\"\u003eBuilt-in Shortcodes\u003c/a\u003e for rich content, along with a \u003ca href=\"https://gohugo.io/about/hugo-and-gdpr/\"\u003ePrivacy Config\u003c/a\u003e and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\u003c/p\u003e","title":"Rich Content"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates (extend_head.html) like so: refer ISSUE #236 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: \\(\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…\\) Block math:\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","permalink":"https://archit15singh.github.io/posts/math-typesetting/","summary":"\u003cp\u003eMathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\u003c/p\u003e","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n.emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","permalink":"https://archit15singh.github.io/posts/emoji-support/","summary":"\u003cp\u003eEmoji can be enabled in a Hugo project in a number of ways.\u003c/p\u003e","title":"Emoji Support"}]