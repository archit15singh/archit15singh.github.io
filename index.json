[{"content":"For more detailed essays, you can explore the collection directly from the 97 Things Every Programmer Should Know collection. This collection provides valuable lessons and practical tips that can benefit both novices and experienced professionals in their respective fields.\nCode Quality and Maintenance Code Readability and Documentation\nCode Design Code Is Design Encapsulate Behavior, not Just State Code Layout Code Layout Matters Comment Only What the Code Cannot Say Writing Maintainable Code Write Code as If You Had to Support It for the Rest of Your Life Write Small Functions Using Examples Code Review and Refactoring\nCode Reviews Code Reviews Refactoring Practices Improve Code by Removing It The Boy Scout Rule Own (and Refactor) the Build Automation in Refactoring Automate Your Coding Standard Testing and Debugging Automated Testing Practices\nBehavioral Testing Test for Required Behavior, not Incidental Behavior Precision in Testing Test Precisely and Concretely Continuous Testing Test While You Sleep (and over Weekends) Write Tests for People Debugging Techniques and Error Handling\nLogging and Error Handling Verbose Logging Will Disturb Your Sleep Don\u0026rsquo;t Ignore that Error! Prevent Errors Debugging Tools and Techniques How to Use a Bug Tracker News of the Weird: Testers Are Your Friends Design Principles Modularity and Reusability\nSingle Responsibility and Modularity The Single Responsibility Principle Don\u0026rsquo;t Repeat Yourself Encapsulation and Types Encapsulate Behavior, not Just State Prefer Domain-Specific Types to Primitive Types Missing Opportunities for Polymorphism API and Interface Design\nAPI Design The Golden Rule of API Design Interface Usability Make Interfaces Easy to Use Correctly and Hard to Use Incorrectly Development Practices Agile and Iterative Development\nEarly and Frequent Releases Deploy Early and Often Practice and Feedback Do Lots of Deliberate Practice Step Back and Automate, Automate, Automate Version Control Put Everything Under Version Control Prudence in Development Act with Prudence Risk-Taking Don\u0026rsquo;t Be Afraid to Break Things Commit Practices Know Your Next Commit Tooling and Environment\nCommand-line Tools Know How to Use Command-line Tools Integrated Development Environment (IDE) Know Your IDE Analysis Tools Take Advantage of Code Analysis Tools Unix Tools The Unix Tools Are Your Friends Performance and Optimization Optimization Techniques\nReduction in Complexity Simplicity Comes from Reduction Algorithm and Data Structure Selection Use the Right Algorithm and Data Structure Performance Issues The Road to Performance Is Littered with Dirty Code Bombs Concurrency and Scalability\nMessage Passing Message Passing Leads to Better Scalability in Parallel Systems Inter-Process Communication Inter-Process Communication Affects Application Response Time Professional Development Learning and Growth\nContinuous Improvement Continuous Learning Reinvent the Wheel Often Openness to Opportunities Start from Yes Language Skills Learn Foreign Languages Know Well More than Two Programming Languages Estimation and Planning\nProject Estimation Learn to Estimate Prudent Actions Act with Prudence Broad Learning Read the Humanities Collaboration and Communication Teamwork and Pair Programming\nPair Programming Pair Program and Feel the Flow Collaborative Problem-Solving Two Heads Are Often Better than One When Programmers and Testers Collaborate Customer Interaction and Requirements\nCustomer Communication Your Customers Do not Mean What They Say Project Advocacy Let Your Project Speak for Itself Code Reading Read Code Defensive Programming Error Handling and Prevention\nPreventive Measures Prevent Errors Error Handling Practices Don\u0026rsquo;t Rely on \u0026ldquo;Magic Happens Here\u0026rdquo; Don\u0026rsquo;t Be Cute with Your Test Data Interim Solutions The Longevity of Interim Solutions Safe Code Modifications\nCode Changes Don\u0026rsquo;t Touch that Code! Build Management Own (and Refactor) the Build Culture and Philosophy Programming Philosophy\nRole and Mythology The Guru Myth Hard Work Does not Pay Off Cultural Understanding Don\u0026rsquo;t Just Learn the Language, Understand its Culture Community Coding Ubuntu Coding for Your Friends Behavior and Attitude\nSelf-awareness Know Your Limits Work-Life Balance Put the Mouse Down and Step Away from the Keyboard Ethical Coding You Gotta Care about the Code Technical Concepts Fundamental Concepts Numerical Accuracy Floating-point Numbers Aren\u0026rsquo;t Real Data Management Large Interconnected Data Belongs to a Database Build and Linking The Linker Is not a Magical Program Deployment One Binary Specific Practices and Tools Version Control and Build Management Version Control Put Everything Under Version Control Build Practices Own (and Refactor) the Build Keep the Build Clean Know Your Next Commit ","permalink":"https://archit15singh.github.io/posts/2024-07-12-god-programmer/","summary":"\u003cp\u003eFor more detailed essays, you can explore the collection directly from the \u003ca href=\"https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/\"\u003e97 Things Every Programmer Should Know\u003c/a\u003e collection.\nThis collection provides valuable lessons and practical tips that can benefit both novices and experienced professionals in their respective fields.\u003c/p\u003e\n\u003ch3 id=\"code-quality-and-maintenance\"\u003eCode Quality and Maintenance\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eCode Readability and Documentation\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCode Design\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eCode Is Design\u003c/li\u003e\n\u003cli\u003eEncapsulate Behavior, not Just State\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eCode Layout\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eCode Layout Matters\u003c/li\u003e\n\u003cli\u003eComment Only What the Code Cannot Say\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eWriting Maintainable Code\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003eWrite Code as If You Had to Support It for the Rest of Your Life\u003c/li\u003e\n\u003cli\u003eWrite Small Functions Using Examples\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003cstrong\u003eCode Review and Refactoring\u003c/strong\u003e\u003c/p\u003e","title":"God Programmer Traits"},{"content":"Asyncio is a powerful library in Python that enables writing concurrent code using the async/await syntax. It provides a framework for managing I/O-bound and high-level structured network code. Asyncio is widely used in web servers, database drivers, network protocols, and other applications that require concurrency without the complexity of traditional threading or multiprocessing.\nIntroduction to Asyncio Asyncio has become a cornerstone for modern Python applications that need to handle asynchronous tasks efficiently. Its ability to manage multiple tasks simultaneously makes it an ideal choice for various real-world scenarios.\nTopics Introduction to Asyncio\nOverview Importance in modern applications Core Concepts and Components\nEvent Loop Coroutines Tasks Futures Gather and Wait Exception Handling Asyncio Primitives\nLocks Events Conditions Semaphores Real-World Use Cases\nWeb Scraping Web Servers Microservices Network Clients and Servers Periodic Tasks Asynchronous Database Operations Advanced Features\nCustom Event Loops Subprocess Management Signal Handling Thread and Process Integration Best Practices and Patterns\nError Handling and Debugging Performance Optimization Testing Asynchronous Code Comparisons with Other Concurrency Models\nThreads vs Asyncio Multiprocessing vs Asyncio Asyncio vs Concurrent.Futures Core Concepts and Components Event Loop The event loop is the heart of asyncio. It runs asynchronous tasks and callbacks, handles I/O operations, and schedules tasks.\nCoroutines Coroutines are special functions defined with async def and can be paused and resumed, allowing other code to run during their execution.\nTasks Tasks are used to schedule coroutines concurrently. They are created using asyncio.create_task().\nFutures Futures represent the result of an asynchronous operation. They are usually not created directly but returned by asyncio APIs.\nGather and Wait asyncio.gather() runs multiple coroutines concurrently and waits for them all to complete. asyncio.wait() waits for the completion of Futures or coroutines.\nException Handling Proper exception handling in asyncio is crucial for robust applications. Use try/except blocks within coroutines and handle task exceptions using add_done_callback() or asyncio.wait().\nAsyncio Primitives Locks Asyncio provides Lock for synchronizing access to shared resources.\nEvents Event is a simple mechanism for communication between coroutines.\nConditions Condition is used for complex synchronization patterns involving multiple coroutines.\nSemaphores Semaphore limits access to a resource by a specific number of coroutines.\nReal-World Use Cases Web Scraping Asyncio is excellent for web scraping due to its ability to handle multiple I/O-bound tasks concurrently.\nimport asyncio import aiohttp async def fetch_url(session, url): async with session.get(url) as response: return await response.text() async def main(urls): async with aiohttp.ClientSession() as session: tasks = [fetch_url(session, url) for url in urls] return await asyncio.gather(*tasks) urls = [\u0026#39;https://example.com\u0026#39;, \u0026#39;https://example.org\u0026#39;] results = asyncio.run(main(urls)) Web Servers Frameworks like FastAPI leverage asyncio to build high-performance web servers.\nfrom fastapi import FastAPI app = FastAPI() @app.get(\u0026#34;/\u0026#34;) async def read_root(): return {\u0026#34;Hello\u0026#34;: \u0026#34;World\u0026#34;} Microservices Asyncio is used in microservices for handling high-throughput, low-latency services.\nNetwork Clients and Servers Asyncio\u0026rsquo;s StreamReader and StreamWriter are used for creating network clients and servers.\nimport asyncio async def handle_echo(reader, writer): data = await reader.read(100) message = data.decode() writer.write(data) await writer.drain() writer.close() async def main(): server = await asyncio.start_server(handle_echo, \u0026#39;127.0.0.1\u0026#39;, 8888) async with server: await server.serve_forever() asyncio.run(main()) Periodic Tasks Using asyncio.sleep() to create periodic tasks.\nasync def periodic(): while True: print(\u0026#34;Task running...\u0026#34;) await asyncio.sleep(5) asyncio.run(periodic()) Asynchronous Database Operations Async libraries like aiomysql and asyncpg allow for asynchronous database interactions.\nimport asyncio import asyncpg async def fetch_data(): conn = await asyncpg.connect(\u0026#39;postgresql://user:password@localhost/dbname\u0026#39;) values = await conn.fetch(\u0026#39;SELECT * FROM table_name\u0026#39;) await conn.close() return values asyncio.run(fetch_data()) Advanced Features Custom Event Loops Creating custom event loops for specific use cases.\nSubprocess Management Managing subprocesses with asyncio.\nSignal Handling Handling OS signals with asyncio.\nThread and Process Integration Combining threads and processes with asyncio using loop.run_in_executor().\nBest Practices and Patterns Error Handling and Debugging Effective strategies for handling errors and debugging asyncio applications.\nPerformance Optimization Techniques for optimizing the performance of asyncio applications.\nTesting Asynchronous Code Approaches to testing asyncio code.\nComparisons with Other Concurrency Models Threads vs Asyncio Comparison of threading and asyncio, highlighting the strengths and weaknesses of each.\nMultiprocessing vs Asyncio Comparison of multiprocessing and asyncio, focusing on use cases and performance.\nAsyncio vs Concurrent.Futures Comparison of asyncio with the concurrent.futures module.\nConclusion Asyncio is a versatile and powerful library for writing concurrent code in Python. Its ability to handle a wide range of tasks, from web servers to network clients, makes it an essential tool for modern Python developers. By understanding the core concepts, real-world use cases, and best practices, you can harness the full potential of asyncio in your applications.\n","permalink":"https://archit15singh.github.io/posts/2024-05-07-asyncio-in-real-world-applications-a-comprehensive-guide/","summary":"\u003cp\u003eAsyncio is a powerful library in Python that enables writing concurrent code using the async/await syntax. It provides a framework for managing I/O-bound and high-level structured network code. Asyncio is widely used in web servers, database drivers, network protocols, and other applications that require concurrency without the complexity of traditional threading or multiprocessing.\u003c/p\u003e\n\u003ch2 id=\"introduction-to-asyncio\"\u003eIntroduction to Asyncio\u003c/h2\u003e\n\u003cp\u003eAsyncio has become a cornerstone for modern Python applications that need to handle asynchronous tasks efficiently. Its ability to manage multiple tasks simultaneously makes it an ideal choice for various real-world scenarios.\u003c/p\u003e","title":"Asyncio in Real-World Applications: A Comprehensive Guide"},{"content":"This is a test post content.\n","permalink":"https://archit15singh.github.io/posts/minimal-test-post/","summary":"\u003cp\u003eThis is a test post content.\u003c/p\u003e","title":"Minimal Test Post"},{"content":"JS execution model Alright, letâ€™s break this down recursively and deeply, line by line, starting with the JavaScript execution model intro and progressing through the first sections. Iâ€™ll give you:\nLiteral meaning (What it says) Deeper understanding (Why it matters) Mental model / real-world analogy (To cement intuition) ğŸ“˜ \u0026ldquo;JavaScript execution model\u0026rdquo; âœ… Literal meaning: This document explains how JavaScript runs behind the scenes â€” how it processes code, manages memory, handles functions, etc.\nğŸ” Deeper understanding: Think of this as the operating system of JavaScript â€” what actually happens when you write let a = 5 or setTimeout(...).\nğŸ§  Analogy: If your code is like a script in a play, the execution model is the stage manager deciding when and how each line of the script gets read and acted upon.\nğŸ“ \u0026ldquo;This page introduces the basic infrastructure of the JavaScript runtime environment.\u0026rdquo; âœ… Literal meaning: Weâ€™re talking about the runtime â€” where JS code is executed (not compiled). This includes things like memory, stacks, event loops, etc.\nğŸ” Deeper understanding: JavaScript isnâ€™t just interpreted randomly. Thereâ€™s a whole structure that controls how code gets parsed, run, paused, resumed.\nğŸ§  Analogy: Imagine a kitchen: the runtime is the kitchen itself (countertop = stack, fridge = heap, bell = job queue). Chefs = JavaScript agents.\nğŸ›  \u0026ldquo;The model is largely theoretical and abstract, without any platform-specific or implementation-specific details.\u0026rdquo; âœ… Literal meaning: This isnâ€™t about Chromeâ€™s V8 engine or Nodeâ€™s internals â€” itâ€™s the universal, spec-level blueprint.\nğŸ” Deeper understanding: Youâ€™re learning how things should behave according to ECMAScript â€” the spec all JS engines follow (more or less).\nğŸ§  Analogy: Like learning the rules of chess, not how Magnus Carlsen plays.\nğŸ§  \u0026ldquo;Modern JavaScript engines heavily optimize the described semantics.\u0026rdquo; âœ… Literal meaning: Real engines like V8 or SpiderMonkey tweak things under the hood for speed, but they follow the same rules.\nğŸ” Deeper understanding: JS engines may compile JS to bytecode, inline functions, optimize away allocations â€” but logically, they obey this model.\nğŸ§  Analogy: Like a Formula 1 pit crew following safety rules â€” they do things super fast, but not incorrectly.\nğŸ“– \u0026ldquo;This page is a reference. It assumes you are already familiar with the execution model of other programming languages, such as C and Java.\u0026rdquo; âœ… Literal meaning: If youâ€™ve worked with languages that have stacks, heaps, and memory â€” this will feel familiar.\nğŸ” Deeper understanding: JS is dynamic and event-driven, but under the hood, it\u0026rsquo;s not that different from C/Java â€” it just hides more from you.\nğŸ§  Analogy: Itâ€™s like someone whoâ€™s driven automatic cars learning how a manual transmission works under the hood.\nğŸ”§ \u0026ldquo;It makes heavy references to existing concepts in operating systems and programming languages.\u0026rdquo; âœ… Literal meaning: Terms like stack, heap, queue, thread â€” all come from OS/PL theory.\nğŸ” Deeper understanding: This section connects JS to how all programming languages manage code execution and memory.\nğŸ§  Analogy: Itâ€™s like learning JavaScriptâ€™s \u0026ldquo;internals\u0026rdquo; by understanding its plumbing â€” threads, memory, job queues.\nNext section\u0026hellip;\nğŸ”¥ The engine and the host ğŸ§© \u0026ldquo;JavaScript execution requires the cooperation of two pieces of software: the JavaScript engine and the host environment.\u0026rdquo; âœ… Literal meaning: JS doesnâ€™t run on its own. It needs:\nA JS engine (like V8, SpiderMonkey) A host (like the browser or Node) ğŸ” Deeper understanding: The engine knows how to parse and run JavaScript. The host (browser/Node) knows how to give JS things to do â€” like making network requests or rendering HTML.\nğŸ§  Analogy: The JS engine is the actor. The host is the stage, props, lighting, and audience.\nğŸ§  \u0026ldquo;The JavaScript engine implements the ECMAScript (JavaScript) language, providing the core functionality.\u0026rdquo; âœ… Literal meaning: The engine knows what let, function, Promise, etc., mean. Thatâ€™s ECMAScript.\nğŸ” Deeper understanding: Things like setTimeout or document.querySelector? Those are host-provided, not part of the language spec.\nğŸ§  Analogy: The engine knows English. The host gives it a job â€” like reading a book, or talking to a user.\nğŸŒ \u0026ldquo;In order to interact with the outside world [\u0026hellip;] we need additional environment-specific mechanisms provided by the host environment.\u0026rdquo; âœ… Literal meaning: To talk to files, web APIs, timers, you need help from the host â€” JS alone canâ€™t do it.\nğŸ” Deeper understanding: This is where browsers give us document, and Node gives us fs, etc. Itâ€™s why JS looks different in each environment.\nğŸ§  Analogy: JavaScript is a brilliant chef, but it needs the host to supply groceries, an oven, or even the guests to cook for.\nğŸŒ \u0026ldquo;For example, the HTML DOM is the host environment when JavaScript is executed in a web browser. Node.js is another host environment\u0026hellip;\u0026rdquo; âœ… Literal meaning: DOM and window exist only in the browser. require and process exist only in Node.\nğŸ” Deeper understanding: Same language, different surroundings = different power/tools. JS is host-agnostic; host APIs change.\nğŸ§  Analogy: Same actor, different movie set. A sci-fi set vs. a historical drama set gives the actor different things to interact with.\nAwesome â€” let\u0026rsquo;s dive into a line-by-line, recursive breakdown of the JavaScript Execution Model section. I\u0026rsquo;ll break down each sentence, unpack the underlying concepts, and relate them to real-world analogies and code where helpful.\nğŸ”¹JavaScript execution model This page introduces the basic infrastructure of the JavaScript runtime environment.\nBreakdown: Weâ€™re about to learn how JavaScript runs \u0026ldquo;under the hood.\u0026rdquo; That means looking beyond syntax into how your code gets executed, managed, and scheduled by the JS engine. The model is largely theoretical and abstract, without any platform-specific or implementation-specific details.\nBreakdown: This is not about how Chrome, Node, or Deno implement JavaScript â€” itâ€™s about the ECMAScript specification-level model. Think of this as the universal blueprint all JS engines follow. Modern JavaScript engines heavily optimize the described semantics.\nBreakdown: V8 (Chrome), SpiderMonkey (Firefox), and others add many performance improvements â€” JIT compilation, inlining, hidden classes â€” but they preserve the behavior defined in this theoretical model. ğŸ”¹This page is a reference. It assumes you are already familiar with the execution model of other programming languages, such as C and Java. Breakdown: It expects you know what a call stack, heap, and execution context are from other languages â€” but don\u0026rsquo;t worry, weâ€™ll unpack everything from a JavaScript-first view. ğŸ”¹The engine and the host JavaScript execution requires the cooperation of two pieces of software: the JavaScript engine and the host environment.\nBreakdown: Engine â†’ Understands \u0026amp; runs JS (e.g. V8, SpiderMonkey). Host â†’ Provides APIs outside of JS (e.g., the DOM, setTimeout, fs in Node). ğŸ“Œ Analogy: The engine is the actor, but the host is the stage, props, and audience.\nThe JavaScript engine implements the ECMAScript (JavaScript) language, providing the core functionality. It takes source code, parses it, and executes it.\nBreakdown: Parses â†’ Converts your code into an Abstract Syntax Tree (AST). Executes â†’ Evaluates it via interpreters or compilers. let x = 5; Engine knows how to parse and execute this, but not how to access the DOM. Thatâ€™s the host\u0026rsquo;s job. However, in order to interact with the outside world, such as to produce any meaningful output, to interface with external resources, or to implement security- or performance-related mechanisms, we need additional environment-specific mechanisms provided by the host environment.\nBreakdown: Engine alone canâ€™t do I/O, networking, file access. Host provides: console.log, fetch, setTimeout, document, process.env, etc. For example, the HTML DOM is the host environment when JavaScript is executed in a web browser. Node.js is another host environment that allows JavaScript to be run on the server side.\nBreakdown: Browser = JS engine + DOM + window + events. Node = JS engine + fs, http, Buffer, process, etc. While we focus primarily on the mechanisms defined in ECMAScript in this reference, we will occasionally talk about mechanisms defined in the HTML spec, which is often mimicked by other host environments like Node.js or Deno.\nBreakdown: Core focus = ECMAScript (language spec). But we\u0026rsquo;ll touch on HTML-defined behaviors (like the Event Loop, microtasks) â€” because Node/Deno borrow them too. ğŸ”¹Agent Execution Model In the JavaScript specification, each autonomous executor of JavaScript is called an agent, which maintains its facilities for code execution:\nBreakdown: Think of an agent as an independent \u0026ldquo;runner\u0026rdquo; of JavaScript â€” like a tab, worker, or Node thread. Each agent has its own heap, call stack, and job queue. Now, letâ€™s recursively unpack the three components of an agent:\nğŸ”¸ Heap (of objects) This is just a name to denote a large (mostly unstructured) region of memory. It gets populated as objects get created in the program.\nBreakdown: Heap = where reference types live: objects, arrays, closures, functions. Variables like let obj = {} create entries in the heap. let obj = { name: \u0026#34;you\u0026#34; }; The object lives in the heap; obj points to it.\nNote that in the case of shared memory, each agent has its own heap with its own version of a SharedArrayBuffer object, but the underlying memory represented by the buffer is shared.\nBreakdown: Each worker/tab has its own isolated heap â€” but shared memory (via SharedArrayBuffer) creates cross-agent bridges. Shared memory enables atomic operations between agents. ğŸ“Œ Think: Multiple agents â†’ own memory â†’ but one shared space for coordination.\nğŸ”¸ Queue (of jobs) This is known in HTML (and also commonly) as the event loop which enables asynchronous programming in JavaScript while being single-threaded.\nBreakdown: Queue = Job Queue / Task Queue. Works with the event loop to schedule async tasks (like setTimeout, Promises). It\u0026rsquo;s called a queue because it\u0026rsquo;s generally first-in-first-out: earlier jobs are executed before later ones.\nBreakdown: Classic FIFO structure. Tasks are queued and executed one by one, preserving order. ğŸ”¸ Stack (of execution contexts) This is what\u0026rsquo;s known as a call stack and allows transferring control flow by entering and exiting execution contexts like functions.\nBreakdown: Stack = execution history â€” functions being called and exited. LIFO â€” last-in, first-out. function a() { b(); } function b() { c(); } a(); // a â†’ b â†’ c â†’ return â†’ return â†’ return It\u0026rsquo;s called a stack because it\u0026rsquo;s last-in-first-out. Every job enters by pushing a new frame onto the (empty) stack, and exits by emptying the stack.\nBreakdown: A function call pushes a frame onto the stack. When it returns, the frame is popped off. These are three distinct data structures that keep track of different data.\nHeap â†’ Long-lived objects. Queue â†’ Pending jobs (like fetch().then()). Stack â†’ Current execution chain (call stack). We will introduce the queue and the stack in more detail in the following sections. To read more about how heap memory is allocated and freed, see memory management.\nBreakdown: Stack and queue will be our main focus because they control how code runs. Heap is for storage, not flow. ğŸ§  Up Next: Weâ€™ll dive into the next section â€” realms, agents on the web (workers, windows), and how these fit together using the diagram you shared.\nWant to continue into that next?\nAwesome â€” letâ€™s go line by line, step by step, recursively breaking down every idea here. I\u0026rsquo;ll unpack it intuitively, back it up with examples, and link it to real-world behavior.\nğŸ”¹ Line 1: \u0026ldquo;These are three distinct data structures that keep track of different data.\u0026rdquo;\nğŸ§  Intuition: In the agent model, three â€œbucketsâ€ manage different responsibilities:\nStructure Purpose Example Heap Stores all dynamic data (objects, functions) {name: \u0026quot;John\u0026quot;} or an array [1,2,3] lives here Queue List of \u0026ldquo;jobs\u0026rdquo; waiting to run (asynchronous tasks) setTimeout(() =\u0026gt; {}, 1000) gets added to queue Stack Keeps track of what function is running right now When calling functions, stack tracks \u0026ldquo;who called who\u0026rdquo; ğŸ¯ Real-World Analogy: Heap = Warehouse of data Stack = A to-do list that follows last in, first out â€” newest task gets done first Queue = A waiting room â€” first in, first out â€” oldest task gets picked up first ğŸ”¹ Line 2: \u0026ldquo;We will introduce the queue and the stack in more detail in the following sections.\u0026rdquo;\nğŸ§  Intuition: Theyâ€™re setting you up: heap is mostly a memory detail (not directly manipulated much), but queue and stack are critical to how JavaScript behaves, especially: Why async code works Why console.log runs before a setTimeout Why promises feel synchronous sometimes You\u0026rsquo;ll learn:\nStack: Why recursion fails with â€œmaximum call stack size exceededâ€ Queue: Why this logs in order: console.log(\u0026#34;A\u0026#34;); setTimeout(() =\u0026gt; console.log(\u0026#34;B\u0026#34;)); console.log(\u0026#34;C\u0026#34;); // Output: A C B ğŸ”¹ Line 3: \u0026ldquo;To read more about how heap memory is allocated and freed, see memory management.\u0026rdquo;\nğŸ§  Intuition: The heap is where all your objects live â€” and they stick around as long as something references them.\nlet x = { name: \u0026#34;Alice\u0026#34; }; // stored in the heap x = null; // garbage collected (freed from heap eventually) No manual memory management in JS. The garbage collector watches references.\nğŸ”¹ Line 4: \u0026ldquo;Each agent is analogous to a thread (note that the underlying implementation may or may not be an actual operating system thread).\u0026rdquo;\nğŸ§  Key Concept: Agent â‰ˆ Thread But not exactly.\nJavaScript itself is single-threaded â€” only one agent running main code. But environments (like browsers or Node.js) spawn multiple agents (like Web Workers). ğŸ” Important: Just because JavaScript feels single-threaded doesn\u0026rsquo;t mean there\u0026rsquo;s only one thread underneath.\nExample: If you use a Web Worker, that code runs in its own agent, with its own heap, queue, and stack.\n// main.js const worker = new Worker(\u0026#34;worker.js\u0026#34;); // worker.js onmessage = (e) =\u0026gt; { // This is a separate agent! postMessage(\u0026#34;Got it\u0026#34;); }; ğŸ”¹ Line 5: \u0026ldquo;Each agent can own multiple realms (which 1-to-1 correlate with global objects) that can synchronously access each other, and thus needs to run in a single execution thread.\u0026rdquo;\nğŸ§  Intuition: A realm is like a sandboxed environment: it has its own globalThis, Array, Function, etc. Inside one agent, multiple realms can talk to each other synchronously (because they share the same stack/queue). ğŸ“¦ Real-world example:\nIn a browser, your main page and a same-origin iframe are in the same agent, but different realms. \u0026lt;iframe src=\u0026#34;same-origin.html\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; Inside both:\nconsole.log(window.Array === iframe.contentWindow.Array); // âŒ false Why? Different realms, different versions of built-in objects like Array.\nğŸ”¹ Line 6: \u0026ldquo;An agent also has a single memory model, indicating whether it\u0026rsquo;s little-endian, whether it can be synchronously blocked, whether atomic operations are lock-free, etc.\u0026rdquo;\nğŸ§  What this means: This dives into low-level behavior, useful when youâ€™re dealing with shared memory (e.g., SharedArrayBuffer) and concurrency.\nLittle-endian: Byte ordering in memory (most systems are little-endian). Lock-free atomic operations: Allows agents to coordinate via memory safely. Synchronous blocking: Whether one agent can halt another (usually avoided in JS for responsiveness). ğŸ›  Youâ€™ll care about this if you\u0026rsquo;re:\nUsing Atomics.wait / Atomics.notify Coordinating workers via shared memory Doing real-time or performance-critical code âœ… Summary Table Concept What It Does Practical Example Heap Stores all objects { user: \u0026quot;A\u0026quot; } Stack Tracks function calls foo() calls bar() Queue Holds async jobs setTimeout(), Promise.then() Agent Self-contained executor (heap+stack+queue) Main thread or Worker Realm Global environment inside an agent Main page vs iframe Memory Model Rules for memory access SharedArrayBuffer, Atomics ğŸ”¥ Want to go deeper into one of these now? I can:\nVisualize how a realm compares to an agent Show a step-by-step simulation of the stack and queue Break down how two agents use shared memory safely Let me know your next target â€” Iâ€™m ready to go recursive on it.\nGreat! Let\u0026rsquo;s continue the recursive breakdown from where we left off. We just finished:\n\u0026ldquo;An agent also has a single memory model, indicating whether it\u0026rsquo;s little-endian, whether it can be synchronously blocked, whether atomic operations are lock-free, etc.\u0026rdquo;\nNow, the next part of the MDN doc says:\nğŸ“Œ Next block: â€œAn agent on the web can be one of the following: A Similar-origin window agent, which contains various Window objects which can potentially reach each other, either directly or by using document.domain. If the window is origin-keyed, then only same-origin windows can reach each other. A Dedicated worker agent containing a single DedicatedWorkerGlobalScope. A Shared worker agent containing a single SharedWorkerGlobalScope. A Service worker agent containing a single ServiceWorkerGlobalScope. A Worklet agent containing a single WorkletGlobalScope.â€ âœ… Let\u0026rsquo;s go line-by-line and recursively break this down: ğŸ”¹ Line 1: \u0026ldquo;An agent on the web can be one of the following:\u0026rdquo;\nğŸ§  Big idea: On the web, each type of â€œexecution environmentâ€ (like a browser tab, a worker, etc.) is backed by its own agent â€” meaning it has its own heap, stack, and queue.\nThink of each agent as its own little JS runtime.\nğŸ”¹ Line 2: \u0026ldquo;A Similar-origin window agent, which contains various Window objects which can potentially reach each other, either directly or by using document.domain. If the window is origin-keyed, then only same-origin windows can reach each other.\u0026rdquo;\nğŸ§  What\u0026rsquo;s going on here? A window agent = Your main page + all same-origin iframes you embed in it.\nğŸ”„ Shared Agent Example: \u0026lt;!-- index.html --\u0026gt; \u0026lt;iframe src=\u0026#34;https://yourdomain.com/page.html\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; These two can share memory and synchronously access each other:\n// From parent page console.log(window.frames[0].document.body); ğŸ§ª But if the iframe is cross-origin, access is blocked for security.\nâš ï¸ Security twist: If document.domain is set (deprecated but still used), two subdomains can loosen the restriction a bit.\n// both pages set document.domain = \u0026#34;example.com\u0026#34;; Then they can reach each other, even if one is a.example.com and one is b.example.com.\nğŸ”¹ Line 3: \u0026ldquo;A Dedicated worker agent containing a single DedicatedWorkerGlobalScope.\u0026rdquo;\nğŸ§  What is a Dedicated Worker Agent? When you create a Web Worker in the browser:\nconst worker = new Worker(\u0026#34;worker.js\u0026#34;); That script (worker.js) runs in its own dedicated worker agent â€” with its own heap, queue, and stack â€” completely separate from the main thread.\nğŸ” Communication is done asynchronously via postMessage() â€” like this:\n// main.js worker.postMessage(\u0026#34;hi\u0026#34;); // worker.js onmessage = (e) =\u0026gt; { console.log(\u0026#34;Got:\u0026#34;, e.data); }; âš ï¸ You cannot synchronously access memory between main thread and a dedicated worker (unless using SharedArrayBuffer).\nğŸ”¹ Line 4: \u0026ldquo;A Shared worker agent containing a single SharedWorkerGlobalScope.\u0026rdquo;\nğŸ§  Difference between Shared Worker and Dedicated Worker? Dedicated Worker: Only 1 page can talk to it. Shared Worker: Multiple tabs (from the same origin) can talk to the same worker. // In two tabs of the same site: const sharedWorker = new SharedWorker(\u0026#34;worker.js\u0026#34;); Now both tabs talk to the same long-living agent!\nWhy use this?\nShare data between tabs Maintain a centralized cache Reduce memory usage ğŸ“¦ But again â€” it\u0026rsquo;s a separate agent with its own stack/heap/queue.\nğŸ”¹ Line 5: \u0026ldquo;A Service worker agent containing a single ServiceWorkerGlobalScope.\u0026rdquo;\nğŸ§  Whatâ€™s special about Service Workers? Theyâ€™re background scripts that sit between your site and the network. Intercept requests (fetch), cache stuff, serve offline pages. // Registering a service worker navigator.serviceWorker.register(\u0026#34;sw.js\u0026#34;); ğŸ§  They:\nOutlive pages Donâ€™t have access to DOM Run in their own agent ğŸ’¡ Use case:\nself.addEventListener(\u0026#34;fetch\u0026#34;, (event) =\u0026gt; { event.respondWith(caches.match(event.request)); }); Service workers have a completely isolated memory space and no direct access to the DOM.\nğŸ”¹ Line 6: \u0026ldquo;A Worklet agent containing a single WorkletGlobalScope.\u0026rdquo;\nğŸ§  Whatâ€™s a Worklet? Advanced topic â€” used for things like:\nCSS Paint API Web Audio API (AudioWorklet) Animations ğŸ”Š Example: An AudioWorklet lets you do low-latency audio processing on a separate thread (agent).\n// In main thread audioContext.audioWorklet.addModule(\u0026#34;processor.js\u0026#34;); // processor.js class MyProcessor extends AudioWorkletProcessor { process(inputs, outputs, parameters) { // run audio processing return true; } } registerProcessor(\u0026#34;my-processor\u0026#34;, MyProcessor); These agents are super-lightweight, meant for tiny, focused jobs like drawing or audio frames.\nğŸ§  Summary: Agent Type Runs in Has Own Stack/Heap/Queue? Use Case Similar-origin Window Agent Main page + iframes (same origin) âœ… Yes Regular DOM pages Dedicated Worker Agent Worker created via new Worker() âœ… Yes Offload CPU-intensive tasks Shared Worker Agent Shared among multiple tabs âœ… Yes Tab-to-tab communication Service Worker Agent Background fetch/caching logic âœ… Yes Offline apps, PWA Worklet Agent Lightweight visual/audio tasks âœ… Yes Audio, CSS, animations You want to continue to the next part after this? Itâ€™s:\nâ€œIn other words, each worker creates its own agent, while one or more windows may be within the same agentâ€”usually a main document and its similar-origin iframesâ€¦â€\nJust say the word and weâ€™ll keep recursively breaking it down with visuals and mental models.\nPerfect! Letâ€™s do a recursive breakdown of this next section, line by line, with intuitive mental models, visuals-in-your-head, and real-world JavaScript usage.\nğŸ§  Big Context: You just learned that each agent is like an isolated JavaScript runtime: it has its own heap, call stack, and job queue.\nNow you\u0026rsquo;re learning:\nğŸ” \u0026ldquo;What are the different types of agents on the web?\u0026rdquo;\nLetâ€™s go line by line:\nğŸ”¹ 1. â€œAn agent on the web can be one of the following:â€ âœ… Translation:\nOn the web, there are several \u0026ldquo;execution environments\u0026rdquo; where JavaScript can run.\nEach is backed by a separate agent, i.e., its own isolated execution infrastructure.\nğŸ§© Now we explore each type: ğŸ”¹ 2. â€œA Similar-origin window agent, which contains various Window objects which can potentially reach each other, either directly or by using document.domain. If the window is origin-keyed, then only same-origin windows can reach each other.â€ ğŸ§  What this means: This is your main webpage, plus any iframes inside it that share the same origin (protocol + host + port). These \u0026ldquo;windows\u0026rdquo; share the same agent, and can talk to each other synchronously. ğŸ§ª Real-World Example: \u0026lt;!-- index.html --\u0026gt; \u0026lt;iframe src=\u0026#34;https://yourdomain.com/page.html\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; You can do this from the parent:\nconst iframeDoc = window.frames[0].document; console.log(iframeDoc.title); // works if same origin âš ï¸ If they\u0026rsquo;re cross-origin, that line throws a security error (unless both set document.domain).\nğŸ“Œ What is document.domain? A deprecated way to let subdomains trust each other:\n// a.example.com and b.example.com both set: document.domain = \u0026#34;example.com\u0026#34;; â†’ Now they can talk synchronously.\nğŸ”¹ 3. â€œA Dedicated worker agent containing a single DedicatedWorkerGlobalScope.â€ ğŸ§  What this means: When you use a Web Worker, like this:\nconst worker = new Worker(\u0026#34;worker.js\u0026#34;); Youâ€™re spinning up a new agent behind the scenes.\nThat agent has:\nIts own heap Its own stack Its own event queue It runs worker.js in isolation.\nğŸ’¡ Real-World Use Case: // main.js worker.postMessage({ task: \u0026#34;fibonacci\u0026#34;, n: 40 }); // worker.js onmessage = (e) =\u0026gt; { const result = doHeavyFibonacci(e.data.n); postMessage(result); }; â†’ This keeps your UI thread smooth and responsive while the heavy calculation runs in another agent (aka thread-like sandbox).\nğŸ”¹ 4. â€œA Shared worker agent containing a single SharedWorkerGlobalScope.â€ ğŸ§  Meaning: Unlike a dedicated worker, a SharedWorker is shared across multiple tabs.\nYou create it like:\nconst sharedWorker = new SharedWorker(\u0026#34;worker.js\u0026#34;); This launches an agent that lives beyond a single page, shared between tabs of the same origin.\nğŸ“Œ Use case: You\u0026rsquo;re building a real-time dashboard with multiple tabs.\nYou want all tabs to share a single:\nWebSocket connection Cache State The shared worker agent holds that logic, and all tabs send messages to it.\nğŸ”¹ 5. â€œA Service worker agent containing a single ServiceWorkerGlobalScope.â€ ğŸ§  Meaning: Service workers are special. They\u0026rsquo;re not tied to a tab.\nThey sit in the background and intercept network requests.\nYou register one like:\nnavigator.serviceWorker.register(\u0026#34;/sw.js\u0026#34;); The sw.js file runs in its own agent with:\nNo DOM access Its own global scope (ServiceWorkerGlobalScope) A lifetime independent from your pages ğŸ“Œ Use case: Offline support Background sync Push notifications // sw.js self.addEventListener(\u0026#34;fetch\u0026#34;, (event) =\u0026gt; { event.respondWith(caches.match(event.request)); }); This runs in a background agent even when no tabs are open.\nğŸ”¹ 6. â€œA Worklet agent containing a single WorkletGlobalScope.â€ ğŸ§  What is a Worklet? Worklets are tiny, low-latency JS programs.\nThey\u0026rsquo;re used for audio processing, custom painting, etc.\nThey are isolated agents that are super-performant, meant for frame-by-frame rendering or DSP (digital signal processing).\nğŸ§ª Use Case: // AudioWorklet audioContext.audioWorklet.addModule(\u0026#34;processor.js\u0026#34;); // processor.js registerProcessor(\u0026#34;my-processor\u0026#34;, class extends AudioWorkletProcessor { process(inputs, outputs, params) { // handle audio here return true; } }); Each worklet runs in a micro-agent with hard real-time constraints.\nğŸ”¹ 7. â€œIn other words, each worker creates its own agent, while one or more windows may be within the same agentâ€”usually a main document and its similar-origin iframes.â€ ğŸ” Recap: Workers (dedicated, shared, service, worklet) â†’ always create new agents Windows (tabs, iframes) â†’ may share one agent if they are same origin ğŸ“¦ So:\nIf you new Worker(), you get a new agent. If you create a same-origin iframe, it\u0026rsquo;s part of your agent. If it\u0026rsquo;s a cross-origin iframe, it likely gets its own agent. ğŸ”¹ 8. â€œIn Node.js, a similar concept called worker threads is available.â€ ğŸ§  In Node.js: const { Worker } = require(\u0026#34;worker_threads\u0026#34;); new Worker(\u0026#34;./worker.js\u0026#34;); That is exactly equivalent to a dedicated worker agent on the web.\nIt has its own stack, heap, queue Communicates via postMessage Can use SharedArrayBuffer for shared memory ğŸ”§ This is Nodeâ€™s way of mimicking browser agents in the backend.\nâœ… Summary Mental Model: Imagine each agent as a little isolated mini JavaScript world with:\nğŸ“¦ its own memory (heap) ğŸ§  its own thinking (call stack) ğŸ•“ its own scheduler (job queue) Then:\nnew Worker() â†’ new agent SharedWorker â†’ shared agent across tabs ServiceWorker â†’ background agent Worklet â†’ real-time micro-agent Same-origin iframe â†’ stays in same agent as parent Want to move to the next block (i.e., Realms)?\nIt starts with:\n\u0026ldquo;Each agent owns one or more realms\u0026hellip;\u0026rdquo;\nJust say \u0026ldquo;next\u0026rdquo;, and Iâ€™ll recursively break that one down too.\nPerfect. Letâ€™s do a deep recursive breakdown of this â€œRealmsâ€ sectionâ€”line by line, with intuition, real examples, and mental models.\nğŸ”° Topic: What is a Realm? A Realm is like a self-contained JS universe inside an agent.\nThink of it as a \u0026ldquo;VM inside a thread\u0026rdquo;.\nğŸ”¹ Line 1: \u0026ldquo;Each agent owns one or more realms.\u0026rdquo;\nğŸ§  Intuition:\nWe already learned that an agent is like a JS thread â€” with its own stack, heap, and event queue.\nA realm lives inside an agent.\nSo one agent can have many realms.\nğŸ’¡ Real-world Analogy: Agent = one CPU core running JavaScript Realm = one JavaScript sandbox running a specific program (like a tab or an iframe) ğŸ§ª On the web:\nA main tab is one realm. A same-origin iframe is a different realm. But both can live inside the same agent (thread). ğŸ”¹ Line 2: \u0026ldquo;Each piece of JavaScript code is associated with a realm when it\u0026rsquo;s loaded, which remains the same even when called from another realm.\u0026rdquo;\nğŸ§  What\u0026rsquo;s happening? When a JS file loads in a context (tab, iframe, worker), itâ€™s bound to the realm of that context.\nEven if it\u0026rsquo;s later called from another realm, it still uses the original realm it was loaded in.\nğŸ“¦ Example: \u0026lt;!-- index.html --\u0026gt; \u0026lt;iframe id=\u0026#34;frame\u0026#34; src=\u0026#34;iframe.html\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;script\u0026gt; const fn = window.frames[0].someFunction; fn(); // This still executes in iframe.htmlâ€™s realm! \u0026lt;/script\u0026gt; Even though you called the function from the main page, it still executes with the context of the iframe realm. Why? Because thatâ€™s where it was created.\nğŸ§  Functions are sticky to the realm they were born in.\nğŸ”¹ Line 3â€“5: \u0026ldquo;A realm consists of the following information:\nA list of intrinsic objects like Array, Array.prototype, etc. Globally declared variables, the value of globalThis, and the global object A cache of template literal arrays, because evaluation of the same tagged template literal expression always causes the tag to receive the same array object\u0026rdquo; ğŸ”¸ 1. Intrinsic objects (e.g. Array, Object, Function, etc.) Every realm gets its own versions of core JS constructors:\n// iframe.html Array !== parent.Array; // true Each realm gets its own Array, Object, Function, etc.\nThey might behave the same â€” but they are different objects in memory.\nğŸ”¸ 2. Global variables and globalThis Every realm has its own global scope â€” this includes:\nwindow in main thread self in workers globalThis (unified access) So in two realms:\n// Realm A globalThis === window; // true // Realm B (worker) globalThis === self; // true But:\nrealmA.globalThis !== realmB.globalThis; // true Each has its own isolated namespace.\nğŸ”¸ 3. Template literal cache This is a performance optimization:\nWhen you use tagged template literals, the same template array object is reused:\nfunction tag(strings) { console.log(strings); // same array on repeated calls } tag`Hello ${name}`; tag`Hello ${name}`; This cache is per-realm, not global.\nğŸ”¹ Line 6: \u0026ldquo;On the web, the realm and the global object are 1-to-1 corresponded. The global object is either a Window, a WorkerGlobalScope, or a WorkletGlobalScope.\u0026rdquo;\nğŸ§  Translation:\nEach realm has exactly one global object, and vice versa.\nOn the web:\nRealm Global Object Tab / iframe Window Worker WorkerGlobalScope Worklet WorkletGlobalScope Thatâ€™s why if you get the window in the main page and compare it to an iframeâ€™s, theyâ€™re not equal.\nğŸ”¹ Line 7: \u0026ldquo;So for example, every iframe executes in a different realm, though it may be in the same agent as the parent window.\u0026rdquo;\nâœ… Recap of layers:\niframe.html = different realm index.html = different realm But both can share the same agent (thread), and thus talk synchronously const iframe = window.frames[0]; iframe.document !== document // âœ… different realm typeof iframe.Array === \u0026#34;function\u0026#34; // âœ… iframe has its own Array constructor ğŸ”¹ Line 8: \u0026ldquo;Realms are usually mentioned when talking about the identities of global objects.\u0026rdquo;\nğŸ§  This sets up the next gotcha:\nObjects might \u0026ldquo;look\u0026rdquo; the same (e.g. arrays from two realms) But under the hood, their identity is different ğŸ”¹ Final Line: \u0026ldquo;For example, we need methods such as Array.isArray() or Error.isError(), because an array constructed in another realm will have a different prototype object than the Array.prototype object in the current realm, so instanceof Array will wrongly return false.\u0026rdquo;\nğŸ§ª Mind-blowing Real World Bug: // index.html const arr = window.frames[0].contentWindow.eval(\u0026#34;[]\u0026#34;); console.log(arr instanceof Array); // âŒ false Array.isArray(arr); // âœ… true Why? Because:\ninstanceof uses current realmâ€™s Array.prototype But arr was created in another realm, so it\u0026rsquo;s linked to iframeâ€™s Array.prototype â†’ So theyâ€™re not the same prototype â€” instanceof fails.\nâœ… Array.isArray() uses internal tags and works across realms.\nğŸ”„ Summary (Mental Model) Concept Meaning Realm A self-contained JS \u0026ldquo;universe\u0026rdquo; with its own global scope and built-in objects Agent A thread-like runner that can host one or more realms Function\u0026rsquo;s Realm Determined by where it was created, not called Cross-realm instanceof fails Because prototype objects are realm-specific Global object The realmâ€™s anchor: Window, WorkerGlobalScope, etc. Tag template cache Cached per-realm to avoid array recreation Would you like to move on to the next section:\n\u0026ldquo;Stack and execution contexts\u0026rdquo;\nJust say â€œnextâ€ and Iâ€™ll break that down in the same step-by-step, deeply intuitive style. Absolutely. Letâ€™s run your recursive breakdown prompt on this snippet from the JavaScript execution model.\nğŸ” Break this down recursively, step by step.\nFor each line or idea in the text:\nExplain it in simple words like Iâ€™m 5. Add practical understanding and intuition. Give real-world metaphors or analogies. Show code examples if possible. Call out connections to other concepts (heap, call stack, event loop, etc). If there are any edge cases or gotchas, point them out. ğŸ§  Here\u0026rsquo;s the snippet: Each agent owns one or more realms.\nğŸ§µ TL;DR: An agent (think: thread of JS execution) contains one or more realms, which are like complete JS â€œuniverses.â€\nğŸ‘¶ Like Iâ€™m 5: Imagine a school (agent) with multiple classrooms (realms). Each classroom has its own set of blackboards, students, and books. They donâ€™t share these things directly, even though theyâ€™re all in the same school.\nğŸ’¡ Intuition: A realm is an isolated set of JavaScript built-ins and global variables. Even if two pieces of code are running on the same thread (agent), if they are in different realms, their core object identities are different.\nğŸ§‘â€ğŸ’» Technical Precision: Each realm has its own: Global object (window, self, etc.) Built-in constructors (Object, Array, Map, etc.) Internal references (prototypes, etc.) Each piece of JavaScript code is associated with a realm when it\u0026rsquo;s loaded, which remains the same even when called from another realm.\nğŸ” Key Insight: Once JS code is â€œbornâ€ in a realm, it stays â€œtaggedâ€ with that realm forever. Even if it\u0026rsquo;s called from a different realm, its identity doesn\u0026rsquo;t shift. ğŸ§ª Code Example: // Frame A (iframe1.html) window.foo = []; // Frame B (iframe2.html) console.log(foo instanceof Array); // false foo was created in iframe1\u0026rsquo;s realm. The Array constructor in iframe2 is from a different realm, so the instanceof fails!\nğŸ§  Mental Model: Think of realms like sandboxes. Once a toy (object/function) is built in sandbox A, it keeps using Aâ€™s rules and tools, even if someone in sandbox B tries to use it.\nA realm consists of the following information:\nWe\u0026rsquo;ll now decompose each of these bullet points.\nâœ… A list of intrinsic objects like Array, Array.prototype, etc.\nğŸ¤“ Technical Insight: Intrinsics are ECMAScript-provided, built-in constructors and objects. Every realm has its own fresh copies of these: Object Function Error Array â€¦and their prototypes These are all baked into the realm and created at initialization.\nğŸª¤ Gotcha: Even if two Array constructors look identical (toString()), they are different in identity across realms:\niframe1.Array === iframe2.Array // false âœ… Globally declared variables, the value of globalThis, and the global object\nğŸ§  Translation: globalThis is realm-specific. Each realm has its own: Top-level variables (var x = ...) window or self globalThis ğŸ§ª Real World Example: // iframe.html var foo = 42; console.log(window.foo); // 42 This foo only exists in that iframeâ€™s global object (its realm).\nâœ… A cache of template literal arrays, because evaluation of the same tagged template literal expression always causes the tag to receive the same array object\nğŸ§  Why does this matter? In tagged templates like:\nfunction tag(strings) { console.log(strings); // same array every time } tag`Hello ${user}`; tag`Hello ${user}`; JavaScript ensures that the template string array passed into tag() is cached per realm.\nDifferent realms? Different caches.\nğŸ’¥ Performance: This caching helps speed up repeated template evaluation and ensures referential equality:\ntag`hello` === tag`hello`; // true â€” same object Only within the same realm!\nOn the web, the realm and the global object are 1-to-1 corresponded. The global object is either a Window, a WorkerGlobalScope, or a WorkletGlobalScope.\nğŸ§  Important Connection: This means: Each realm = one global scope = one top-level execution environment\nMain page â†’ Window Web worker â†’ WorkerGlobalScope Audio/paint worklet â†’ WorkletGlobalScope So for example, every iframe executes in a different realm, though it may be in the same agent as the parent window.\nğŸ§ª Key Example: \u0026lt;!-- parent.html --\u0026gt; \u0026lt;iframe src=\u0026#34;child.html\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; Both windows may run in the same thread (same agent), but they have separate realms:\nSeparate window Separate built-ins Separate Array.prototype Realms are usually mentioned when talking about the identities of global objects.\nğŸ§  This is important for comparing object types: instanceof, typeof, and even object shape can mislead across realms. Thatâ€™s why we use Array.isArray() and Object.prototype.toString.call(x) for better checks. For example, we need methods such as Array.isArray() or Error.isError(), because an array constructed in another realm will have a different prototype object than the Array.prototype object in the current realm, so instanceof Array will wrongly return false.\nğŸ’¥ ğŸ”¥ This is the key gotcha: instanceof checks the prototype chain:\nobj instanceof Array; // internally: obj.[[Prototype]] === Array.prototype If obj came from another realm, its [[Prototype]] points to that realmâ€™s Array.prototype.\nSo your current realm\u0026rsquo;s Array.prototype !== obj.[[Prototype]].\nâœ… Fix: Use Array.isArray(obj) â€” it works across realms.\nğŸ”„ Summary: Realm Mental Model Thing Scoped to Realm? Notes globalThis âœ… Yes Same as window in browsers Array, Error, Map âœ… Yes Intrinsics are realm-bound Template literals cache âœ… Yes Same tag + literal = same object only within realm instanceof âŒ Unsafe across realms Use .isArray() instead ğŸ§  You now understand realms:\nWhat they contain (globals, intrinsics, caches) How they interact (or donâ€™t) Why cross-realm identity breaks matter Let me know when you\u0026rsquo;re ready for the next snippet ğŸ”¥\nAbsolutely â€” let\u0026rsquo;s break this down recursively and deeply, exactly as you instructed.\nWe\u0026rsquo;ll go concept by concept, technically and intuitively, and build up mental models for each.\nğŸ” Breakdown: Stack and Execution Contexts ğŸ“Œ â€œWe first consider synchronous code execution.â€ ğŸ§  Simple: Let\u0026rsquo;s start by looking at normal code that runs step-by-step (not async like setTimeout or fetch).\nğŸ§¬ Intuition: Imagine reading a recipe. You follow instructions one by one: get pan, heat it, crack eggs. Thatâ€™s synchronous â€” no skipping, no pausing.\nğŸ’¡ Connection: This section is setting the stage for how JS handles function calls in a single thread.\nğŸ“Œ â€œEach job enters by calling its associated callback.â€ ğŸ§  Simple: A \u0026ldquo;job\u0026rdquo; is a unit of work. That work begins by running a function (called a callback).\nğŸ§¬ Metaphor: Think of a â€œjobâ€ as a task on your to-do list. You canâ€™t start the job until you â€œopen the taskâ€ â€” i.e., call the function.\nğŸ’» Example:\nsetTimeout(() =\u0026gt; console.log(\u0026#34;Hi\u0026#34;), 0); // The callback here is () =\u0026gt; console.log(\u0026#34;Hi\u0026#34;) // This becomes a \u0026#39;job\u0026#39; when placed into the job queue ğŸ”— Links: Ties into the Job Queue / Event Loop model. This is the beginning of â€œrun-to-completion.â€\nğŸ“Œ â€œCode inside this callback may create variables, call functions, or exit.â€ ğŸ§  Simple: Once the function starts running, it can do things â€” define variables, call other functions, or finish and return.\nğŸ” Recursive: Calling another function pushes a new execution context (stack frame) on the stack.\nğŸ“Œ â€œEach function needs to keep track of its own variable environments and where to return to.â€ ğŸ§  Simple: Every function has its own scope â€” a separate box for its variables â€” and knows where to go back when it finishes.\nğŸ§¬ Analogy: Like Russian dolls. Open one, go into the next. But you have to close the inner ones before returning to outer.\nğŸ’» Code:\nfunction greet() { const name = \u0026#34;Alice\u0026#34;; return `Hi ${name}`; } JS must remember: name = \u0026quot;Alice\u0026quot; Where to go after greet() is done. ğŸ“Œ â€œTo handle this, the agent needs a stack to keep track of the execution contexts.â€ ğŸ§  Simple: JavaScript uses a stack to remember what function itâ€™s currently in â€” and where to return.\nğŸ§© Engine Insight: This is the call stack â€” last-in, first-out (LIFO).\nğŸ”— Related:\nStack Overflow = when too many nested calls fill up memory. Execution Context = everything needed to run a chunk of code. ğŸ“Œ â€œAn execution context, also known generally as a stack frame, is the smallest unit of execution.â€ ğŸ§  Simple: Each stack frame = one function\u0026rsquo;s â€œsandbox.â€ JS creates one per function call.\nğŸ’» Contains:\nThe function arguments and variables. The value of this. Which realm weâ€™re in. Internal stuff like await, yield, return address. ğŸ“Œ â€œIt tracks the following informationâ€¦â€ ğŸ”¹ Code evaluation state ğŸ§  What line are we on? Are we paused (e.g., generator)? Are we done?\nğŸ”¹ The module or script, the function (if applicable), and the currently executing generator ğŸ§  JS knows: Are we inside a module or a classic script?\nWhich function is running. Are we inside a paused generator? ğŸ”¹ The current realm ğŸ§  Which global environment are we in? (e.g., iframe vs parent)\nğŸ”— Ties into realms. Important for prototype identity (instanceof, etc.)\nğŸ”¹ Bindings ğŸ§  All the stuff declared inside the function:\nlet, const, var function foo() {} class A {} #privateField this ğŸ’» These are stored in a Lexical Environment.\nğŸ§  Trace: The Example function foo(b) { const a = 10; return a + b + 11; } function bar(x) { const y = 3; return foo(x * y); } const baz = bar(7); // assigns 42 to baz ğŸ“ Step-by-step Stack Trace:\nbar(7) is called Stack: [global, bar] x = 7, y = 3 foo(21) is called inside bar Stack: [global, bar, foo] b = 21, a = 10 foo returns 42, stack pops back to bar bar returns 42, stack pops back to global baz = 42 ğŸ§¬ Intuition: JS stacks frames like Jenga blocks. When one returns, it pops off and reveals the one underneath.\nğŸ” Generators and Reentry ğŸ“Œ â€œWhen a frame is popped, itâ€™s not necessarily gone forever\u0026hellip;â€ ğŸ§  Generators let you pause function execution in the middle, and resume later.\nğŸ’» Code:\nfunction* gen() { console.log(1); yield; console.log(2); } ğŸ“ gen() creates a paused execution context. ğŸ“ g.next() resumes it. ğŸ“ yield suspends it again â€” it lives!\nğŸ§¬ Metaphor: Like pausing a game and saving your state. You can resume from where you left.\nğŸ§¬ Tail Calls ğŸ“Œ â€œIf a function call is in tail positionâ€¦â€ ğŸ§  When a function ends with return anotherFunction(), you donâ€™t need a new frame â€” just reuse the current one.\nğŸ’» Example:\nfunction f() { return g(); // Tail call! } ğŸ”¥ PTC (Proper Tail Call) optimization:\nDonâ€™t grow the stack. Especially useful in tail-recursive functions. ğŸ§© âš ï¸ Only Safari (JavaScriptCore) supports it. Most engines do not implement this due to debugging stack traces.\nğŸ” Closures ğŸ“Œ â€œWhenever a function is created, it also memorizesâ€¦â€ ğŸ§  A closure is a function bundled with the variables from the scope in which it was created.\nğŸ’»\nfunction outer() { let x = 10; return () =\u0026gt; x; // \u0026lt;- closure } const f = outer(); console.log(f()); // 10 ğŸ§¬ Mental model: Think of the returned function as carrying a backpack filled with variables it saw when it was created.\nğŸ”— Related:\nLexical Environment var, let, const scoping Let me know when you\u0026rsquo;re ready for the next section â€” or if you\u0026rsquo;d like me to turn this into an Anki-style Q\u0026amp;A deck for reinforcement. Absolutely â€” letâ€™s do a line-by-line recursive breakdown of this Job Queue and Event Loop section with full senior-engineer depth, intuition, code traces, runtime metaphors, and links to memory model concepts.\nğŸ” Section: Job Queue and Event Loop ğŸ“Œ â€œAn agent is a thread, which means the interpreter can only process one statement at a time.â€ ğŸ§  Simple: JavaScript is single-threaded â€” only one thing runs at a time per agent.\nğŸ§© Engine Insight:\nIn the browser, an agent could be your main window (the tab), or a worker. Think of the JS engine as a tiny CPU that processes one instruction at a time â€” no matter how many cores your real CPU has. ğŸ§¬ Analogy: Like a chef who can only cook one dish at a time. Others must wait their turn.\nğŸ“Œ â€œWhen the code is all synchronous, this is fine because we can always make progress.â€ ğŸ§  This means: As long as the code doesn\u0026rsquo;t pause for anything (like network or timers), it just runs straight to the end.\nğŸ”— Related: Synchronous code uses the call stack, not the job queue.\nğŸ’»\nfunction add(a, b) { return a + b; } add(2, 3); // runs synchronously ğŸ“Œ â€œBut if the code needs to perform asynchronous action, then we cannot progress unless that action is completed.â€ ğŸ§  Async actions (e.g. fetch, setTimeout) pause until external conditions are ready (data returned, timer elapsed).\nâš ï¸ If JS waited synchronously for async things â†’ the browser would freeze.\nğŸ“Œ â€œHowever, it would be detrimental to user experience if that halts the whole program\u0026hellip;â€ ğŸ§¬ Metaphor: Imagine a barista who freezes every time a customer orders a coffee â€” until it\u0026rsquo;s brewed. The line would stall.\nğŸ”¥ Why JS must be async: It\u0026rsquo;s embedded in browsers. You must be able to scroll, type, click even if some JS is waiting.\nğŸ“Œ â€œTherefore, the code that handles the completion of that asynchronous action is defined as a callback.â€ ğŸ§  The logic to run after a wait is defined ahead of time as a callback function.\nğŸ’»\nsetTimeout(() =\u0026gt; { console.log(\u0026#39;Done waiting!\u0026#39;); }, 1000); () =\u0026gt; console.log(...) is the callback It is queued, not run immediately. ğŸ“Œ â€œThis callback defines a job, which gets placed into a job queueâ€”or, in HTML terminology, an event loopâ€”once the action is completed.â€ ğŸ§© The callback becomes a job â†’ a mini \u0026ldquo;task\u0026rdquo; to execute later.\nğŸ§  The event loop is the orchestrator: it picks the next job from the queue when the call stack is empty.\nğŸ”„ Summary Mental Model So Far: [ Main Thread ] --\u0026gt; Executes sync code until stack is empty | When async completes: [ Event Loop ] ---+\u0026gt; Pulls next job from Job Queue [ Job Queue ] ----\u0026gt; Contains callbacks from timers, promises, events ğŸ“Œ â€œEvery time, the agent pulls a job from the queue and executes it.â€ ğŸ§  The engine continuously pulls and runs jobs in a loop (hence: â€œevent loopâ€).\nğŸ” The cycle:\nJob queue: filled by browser or platform APIs Event loop: pulls job â†’ creates execution context â†’ pushes on stack â†’ runs â†’ pops ğŸ“Œ â€œWhen the job is executed, it may create more jobsâ€¦â€ ğŸ§  Example: You can queue new async work from inside another job.\nğŸ’»\nsetTimeout(() =\u0026gt; { console.log(\u0026#34;first\u0026#34;); setTimeout(() =\u0026gt; console.log(\u0026#34;second\u0026#34;), 0); }, 0); ğŸ“Œ â€œJobs might not be pulled with uniform priority\u0026hellip;â€ ğŸ§  Some jobs are more urgent than others!\nğŸ”— Microtasks vs Tasks\nMicrotasks: promise callbacks, queueMicrotask Tasks: setTimeout, setInterval, UI events ğŸ§© Microtasks are always drained first, after each job.\nğŸ’»\nPromise.resolve().then(() =\u0026gt; console.log(\u0026#34;microtask\u0026#34;)); setTimeout(() =\u0026gt; console.log(\u0026#34;task\u0026#34;), 0); // Output: microtask, then task ğŸ“Œ â€œIf the job queue is empty, the agent waits for more jobs to be added.â€ ğŸ§  Idle state. The event loop sleeps until the browser or platform API triggers new work.\nğŸ§¬ Like a delivery robot that naps until someone rings the bell.\nâš¡ \u0026ldquo;Run-to-completion\u0026rdquo; ğŸ“Œ â€œEach job is processed completely before any other job is processed.â€ ğŸ§  JS never interrupts mid-function.\nğŸ§¬ Analogy: Once a doctor starts surgery, no one can stop them to ask a question â€” they must finish.\nğŸ”— Contrast: In C/Java, threads can preempt each other. In JS, once a job starts, it owns the CPU until it finishes.\nğŸ“Œ â€œwhenever a function runs, it cannot be preemptedâ€¦â€ ğŸ§  This is why JS avoids race conditions inside jobs.\nğŸ’» Code:\nlet i = 0; Promise.resolve().then(() =\u0026gt; { i++; console.log(i); }); Promise.resolve().then(() =\u0026gt; { i++; console.log(i); }); ğŸ§¬ Each .then() is a microtask â†’ runs separately â†’ but not simultaneously\nğŸ“¤ Output: 1 then 2 â€” always predictable.\nğŸš¨ Downside: Long jobs freeze the app ğŸ“Œ â€œif a job takes too long to complete, the web application is unable to process user interactions\u0026hellip;â€ ğŸ§  While a job is running, the browser canâ€™t repaint, handle scroll, or click events.\nğŸ§© This is why infinite loops freeze tabs.\nğŸ”¥ Modern browsers will warn: â€œScript is taking too longâ€\nâœ… Best Practice:\nBreak up big tasks using setTimeout or requestIdleCallback ğŸ’» Example:\nfunction heavyWork() { for (let i = 0; i \u0026lt; 1e9; i++) { /*...*/ } } // bad â€“ blocks UI âœ… Never Blocking ğŸ“Œ â€œHandling I/O is typically performed via events and callbacksâ€¦â€ ğŸ§  This is the heart of JS\u0026rsquo;s async model. It uses non-blocking I/O.\nğŸ’» When you call fetch(), JS:\nStarts network request in background Finishes current script Runs your callback when data is ready ğŸ“Œ â€œ\u0026hellip;which defines a job to be added to the job queue once the action completes.â€ ğŸ” Consistent pattern:\nYou give JS a function â†’ it adds it as a job when the async work completes ğŸ’»\nfetch(url).then(data =\u0026gt; { // this is a job }); ğŸ“Œ â€œSome legacy exceptions exist like alert() or synchronous XHR.â€ ğŸ§  These are blocking APIs â€” they freeze the event loop.\nğŸš« Avoid:\nalert() confirm() synchronous XMLHttpRequest They break the \u0026ldquo;never blocking\u0026rdquo; contract.\nâœ… Final Takeaway Mental Model [ Call Stack ] | runs sync code | while stack is empty, pull jobs... [ Event Loop ] â†³ prioritizes Microtask Queue (Promises) â†³ then Task Queue (Timers, Events) [ Microtask Queue ] â†³ .then(), catch(), queueMicrotask() [ Task Queue ] â†³ setTimeout, DOM events, fetch completion Let me know when you\u0026rsquo;re ready for the next section, or if you want a code visualization to simulate this step-by-step.\nAwesome â€” you\u0026rsquo;re diving into the deepest part of the JavaScript execution model: ğŸ§  agent clusters, memory sharing, and concurrency guarantees.\nLetâ€™s now break it down recursively, step-by-step with:\nğŸ§  ELI5 (but senior engineer depth) ğŸ§¬ Metaphors + system-level mental models ğŸ’» Code examples ğŸ” Runtime traces if needed âš ï¸ Gotchas + edge cases ğŸ”— Connections to internals (e.g., call stack, Web Workers, SharedArrayBuffer, Atomics) ğŸ“¦ [SECTION 1] â€” Agent clusters and memory sharing ğŸ”¹ \u0026ldquo;Multiple agents can communicate via memory sharing, forming an agent cluster.\u0026rdquo; ğŸ§  What\u0026rsquo;s an agent?\nThink of an agent as an independent JavaScript execution thread.\nOn the web, this includes Window, Dedicated Worker, Shared Worker, Service Worker, Worklet, etc. ğŸ§¬ Metaphor: Each agent is a chef in their own kitchen. Normally, they can\u0026rsquo;t see or touch each otherâ€™s tools or food, but if we allow shared ingredients (memory), they become part of the same restaurant (agent cluster).\nğŸ’¡ Agent cluster = a group of agents that can share memory, especially SharedArrayBuffer.\nğŸ”¹ \u0026ldquo;Agents are within the same cluster if and only if they can share memory.\u0026rdquo; ğŸ”’ Memory sharing is the defining rule for clustering.\nNo memory sharing = not in the same cluster.\nğŸ§  Think: A dedicated worker created by a window can share memory with it â€” they live in the same memory \u0026ldquo;neighborhood.\u0026rdquo;\nğŸ”¹ \u0026ldquo;There is no built-in mechanism for two agent clusters to exchange any information\u0026hellip; regarded as completely isolated execution models.\u0026rdquo; âš ï¸ Once memory isn\u0026rsquo;t shared, you\u0026rsquo;re in a different universe.\nğŸ’¬ Agents in different clusters canâ€™t see or affect each other. No messaging, no memory sync.\nThis protects data integrity, prevents deadlocks, and improves security/sandboxing.\nğŸ§± [SECTION 2] â€” When are agents in the same cluster? Letâ€™s go line-by-line on the examples.\nâœ… CAN share memory (same agent cluster) A Window and a DedicatedWorker it created\nâ†’ This is the classic case:\nconst worker = new Worker(\u0026#34;worker.js\u0026#34;); Theyâ€™re â€œparent-childâ€ and can share SharedArrayBuffer.\nAny worker and a dedicated worker it created\nâ†’ Nested workers:\n// In worker A const nested = new Worker(\u0026#34;nested.js\u0026#34;); A Window and a same-origin iframe it created\nâ†’ Same-origin iframe = same memory model.\nA Window and a same-origin window that opened it\nâ†’ If window.open() is used and both have same origin â†’ shared memory is possible.\nA Window and a worklet it created\nâ†’ Worklets (e.g., AudioWorklet) run in a specialized context, but under the hood they\u0026rsquo;re still in the cluster.\nâŒ CANNOT share memory (different agent clusters) A Window and a shared worker it created\nShared workers have global scope across tabs â€” memory isolation enforced. Any worker and a shared worker it created\nAgain: shared workers are multi-tenant â†’ no memory sharing. A Window and a service worker it created\nService workers are meant to be persistent proxies â€” not memory-bound to their creators. Window and an iframe with a different origin\nSame document origin = OK. Otherwise â†’ cross-origin sandboxing. Two unrelated Window objects (even if same-origin!)\nIf thereâ€™s no opener/ancestor relationship â†’ isolation. ğŸ“¤ [SECTION 3] â€” Cross-agent communication and memory model ğŸ”¹ \u0026ldquo;Agents communicate via memory sharing\u0026rdquo; ğŸ’¡ On the web, you can use:\npostMessage() â†’ sends data by copying (structured clone). SharedArrayBuffer â†’ sends a reference to the same memory. ğŸ”¹ \u0026ldquo;Typically, data is passed by value only (via structured cloning)\u0026rdquo; ğŸ§  This means that postMessage() copies the data:\nworker.postMessage({ name: \u0026#34;foo\u0026#34; }); // copied, not shared ğŸ’¡ No concurrency issues â€” each agent has its own version.\nğŸ”¹ \u0026ldquo;To share memory, one must post a SharedArrayBuffer\u0026hellip;\u0026rdquo; ğŸ’» Example:\nconst shared = new SharedArrayBuffer(1024); worker.postMessage(shared); // shared, not cloned ğŸ§  Now both sides have shared view of the same memory. Enter: âš ï¸ concurrency risk.\nğŸ”¹ \u0026ldquo;Once agents share memory\u0026hellip; they can synchronize via Atomics\u0026rdquo; ğŸ’¡ Atomics = low-level tools like locks or barriers:\nconst arr = new Int32Array(sharedBuffer); Atomics.store(arr, 0, 123); Atomics.notify(arr, 0, 1); Atomics.wait, notify, add, compareExchange â€” ensure safe coordination. ğŸ”¹ \u0026ldquo;Normal memory access is not atomic\u0026rdquo; âš ï¸ You risk data races without Atomics. For example:\narr[0] = arr[0] + 1; // NOT safe in concurrent context ğŸ”¹ \u0026ldquo;Atomic access is sequentially consistent\u0026rdquo; ğŸ§  Means all agents see memory changes in the same order.\nğŸ§¬ Metaphor: Everyone reads from the same official whiteboard, in strict timestamp order.\nğŸ”¹ \u0026ldquo;Non-atomic access is unordered\u0026rdquo; ğŸ’£ You canâ€™t assume what value an agent will see. Could read half-updated memory!\nğŸ”’ [SECTION 4] â€” Guidelines for shared memory programs ğŸ§  Rule #1: Make it data-race free That means:\nâœ… Only one agent accesses a memory location at a time\nâœ… If concurrent access happens, must use Atomics\nğŸ’¡ If race-free, you donâ€™t need to memorize weird memory model details.\nğŸ§  Rule #2: Use strongly typed memory access â†’ Donâ€™t mix atomic and non-atomic access on same cell\nâ†’ Donâ€™t access memory with different sizes (e.g., Int8 and Int32) at once\nâš ï¸ Otherwise: value tearing = corrupted memory values\nğŸš§ [SECTION 5] â€” Concurrency and forward progress ğŸ”¹ \u0026ldquo;An agent can become blocked\u0026hellip; waiting on another agent\u0026rdquo; ğŸ’¡ Unlike promises (which yield control back), Atomics.wait() can halt the whole thread:\nAtomics.wait(sharedArray, 0, 0); // blocking call ğŸ§  This blocks until someone else wakes it up with Atomics.notify.\nğŸ”¹ Forward progress guarantees: These prevent deadlocks:\nâœ… If agent has its own thread â†’ it will eventually run âœ… If many agents share a thread â†’ one will eventually run âœ… Agents only block each other via explicit APIs (Atomics.wait, sync XHR, etc.) ğŸ”¹ Only certain agents can be blocked ğŸ“Œ On web:\nâœ… Dedicated workers and shared workers â†’ can block âŒ Service workers, same-origin windows â†’ cannot block (must stay responsive) ğŸ”¹ Agent clusters cannot be partially deactivated ğŸ’¡ Ensures one agent doesnâ€™t starve others:\nE.g., if a window goes inactive, it canâ€™t suspend its worker if that worker is holding a lock needed by others.\nğŸ’¥ [SECTION 6] â€” Cluster termination ğŸ”¹ \u0026ldquo;An agent may be paused/resumed/terminated without its knowledge\u0026rdquo; ğŸ§¬ Real-world analogy: The OS may freeze your app if tab is in the background.\nğŸ”¹ \u0026ldquo;If one agent in a cluster is terminated, all are terminated\u0026rdquo; ğŸ“Œ To avoid weird bugs:\nPrevent lock holder (e.g. a dedicated worker) from holding up others Clean, deterministic teardown ğŸ§  Summary Concept What it means Agent A JS execution context (Window, Worker) Agent cluster A group of agents that can share memory Shared memory Via SharedArrayBuffer Synchronization Via Atomics Race-free design Avoids memory corruption Blocked agent Can halt progress if not designed carefully Cluster termination Whole cluster dies if one dies Want to go deeper into:\nCode examples using SharedArrayBuffer and Atomics? Agent cluster detection or visualization? Simulation of race conditions? Letâ€™s pick a direction! ğŸ”¥ Awesome catch â€” letâ€™s audit what I missed from your full MDN snippet breakdown.\nHereâ€™s a delta analysis: what was not fully covered or only partially explored in my previous reply.\nğŸ” MISSED / INCOMPLETE EXPLANATIONS: 1. âœ… Agent Cluster Creation Criteria (subtle details) \u0026ldquo;When creating an agent (such as by spawning a worker), there are some criteria for whether it\u0026rsquo;s in the same cluster\u0026hellip;\u0026rdquo;\nğŸ”¸ Missed:\nI didnâ€™t explain how the browser decides whether a new agent goes into the same cluster or a new one.\nğŸ”¬ Shouldâ€™ve emphasized:\nCluster assignment depends on: Type of worker (DedicatedWorker vs SharedWorker) Origin relationship (same-origin, cross-origin) Opener/ancestor hierarchy Not just â€œwho created whomâ€, but also execution context and memory isolation policy. 2. ğŸ“Œ \u0026ldquo;For the exact algorithm, check the HTML spec.\u0026rdquo; ğŸ§  This implies: thereâ€™s a deterministic cluster decision algorithm in the HTML spec.\nI missed mentioning this exists and is centralized in the spec.\nCouldâ€™ve briefly summarized:\nğŸ§© The cluster assignment is based on origin, opener/ancestor relationship, and agent type â€” enforced by the HTML spec for predictable memory boundaries.\n3. âš ï¸ Structured cloning vs postMessage vs SharedArrayBuffer \u0026ldquo;On the web, memory is shared via the postMessage() method.\u0026rdquo;\nğŸ”¸ What I missed:\nThe line implies postMessage is the only mechanism, but thatâ€™s nuanced.\npostMessage() doesn\u0026rsquo;t actually share memory unless you pass SharedArrayBuffer explicitly. Structured cloning = copy, not share. Missed calling out: postMessage() can include a SharedArrayBuffer in the transfer list for memory sharing. ğŸ’¡ Shouldâ€™ve said:\npostMessage() is a channel, but shared memory only happens if you explicitly transfer SharedArrayBuffer.\n4. ğŸ§ª Interleaving Semantics for Data Race-Free Programs \u0026ldquo;Data race free programs have interleaving semantics\u0026hellip;\u0026rdquo;\nğŸ” Missed explaining:\nWhat â€œinterleaving semanticsâ€ actually means. Why race-free means you can reason as if each agentâ€™s steps are executed in some sequential order (like cooperative multitasking). ğŸ§¬ Could\u0026rsquo;ve added metaphor:\nImagine each agent takes a turn writing on a shared whiteboard one step at a time. If they follow the rules (Atomics or no overlap), the whiteboard always makes sense.\n5. âš ï¸ Non-Atomic Races: Predictability \u0026amp; Access Size \u0026ldquo;\u0026hellip;so long as atomic operations are not involved in any data races and the operations that race all have the same access size.\u0026rdquo;\nğŸ” I skipped this precision:\nAccess size matters for predictability Mixing 1-byte (Int8) and 4-byte (Int32) on the same address can cause value tearing ğŸ’¡ Strongly-typed memory = each memory cell should only be accessed by one \u0026ldquo;type\u0026rdquo; and access size consistently.\n6. â— Memory tearing explanation was too brief \u0026ldquo;\u0026hellip;racing accesses will not \u0026rsquo;tear\u0026rsquo; (bits of their values will not be mixed).\u0026rdquo;\nğŸ”¬ Couldâ€™ve added:\nTearing = e.g., reading a 32-bit value but only getting half updated bytes (2 from old write, 2 from new write) Only happens in non-atomic interleaved updates on the same address with no guarantees 7. âŒ Distinction between Promise Blocking and Agent Blocking \u0026ldquo;This is different from waiting on a promise\u0026hellip; it halts the entire agent\u0026hellip;\u0026rdquo;\nğŸ’¡ I mentioned it, but not clearly enough.\nShouldâ€™ve deeply emphasized:\nawait on a Promise = non-blocking â†’ event loop keeps spinning Atomics.wait() = fully blocking â†’ freezes the agentâ€™s thread until notified 8. â›” Agent Cluster Termination Strategy #2 \u0026ldquo;The spec also allows a second strategy\u0026hellip; identify the termination and the agent that was terminated\u0026hellip;\u0026rdquo;\nğŸ” Totally skipped this:\nThereâ€™s a planned spec strategy for â€œpartial cluster fault-toleranceâ€ (like crash recovery) âš ï¸ But not implemented in browsers yet ğŸ’¡ Couldâ€™ve mentioned:\nFuture APIs might let one agent detect anotherâ€™s termination and respond â€” but no browser supports it yet.\nâœ… Recap: What I Need to Add or Expand Missed Point Fix Needed Agent cluster assignment logic Clarify when/why new clusters are created Reference to HTML spec algo Add that thereâ€™s a central algorithm Clarify postMessage vs shared memory Add nuance on postMessage + SAB Interleaving semantics Visual metaphor + intuition Access size constraints in races Mention alignment, strongly typed memory Memory tearing Add byte-level example Blocking: Promise vs Atomics Emphasize non-blocking vs blocking Spec\u0026rsquo;s unimplemented recovery API Mention future fault-tolerant designs Want me to patch in these improvements into the previous breakdown? I can thread them seamlessly or highlight them in a new focused section.\n","permalink":"https://archit15singh.github.io/posts/2022-07-29-js-execution-model-in-depth/","summary":"\u003ch1 id=\"js-execution-model\"\u003eJS execution model\u003c/h1\u003e\n\u003cp\u003eAlright, letâ€™s break this down recursively and deeply, line by line, starting with the \u003cstrong\u003eJavaScript execution model\u003c/strong\u003e intro and progressing through the first sections. Iâ€™ll give you:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003eLiteral meaning\u003c/strong\u003e (What it says)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDeeper understanding\u003c/strong\u003e (Why it matters)\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eMental model / real-world analogy\u003c/strong\u003e (To cement intuition)\u003c/li\u003e\n\u003c/ol\u003e\n\u003chr\u003e\n\u003ch3 id=\"-\"\u003eğŸ“˜ \u003cstrong\u003e\u0026ldquo;JavaScript execution model\u0026rdquo;\u003c/strong\u003e\u003c/h3\u003e\n\u003ch4 id=\"-literal-meaning\"\u003eâœ… Literal meaning:\u003c/h4\u003e\n\u003cp\u003eThis document explains how JavaScript runs behind the scenes â€” how it processes code, manages memory, handles functions, etc.\u003c/p\u003e","title":"JS execution model in depth"},{"content":"This is just a test post!\nTesting quotes\nItalics\nBold!\nHeading 1 Heading 2 Heading 3 Heading 4 Heading 5 Heading 6 Bulleted list 1 Bulleted list 2 Bulleterd list 3 Ordered list Ordered list Ordered list ","permalink":"https://archit15singh.github.io/posts/2022-07-29-test-post/","summary":"\u003cp\u003eThis is just a test post!\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eTesting quotes\u003c/p\u003e\u003c/blockquote\u003e\n\u003cp\u003e\u003cem\u003eItalics\u003c/em\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eBold!\u003c/strong\u003e\u003c/p\u003e\n\u003ch1 id=\"heading-1\"\u003e\u003cstrong\u003eHeading 1\u003c/strong\u003e\u003c/h1\u003e\n\u003ch2 id=\"heading-2\"\u003eHeading 2\u003c/h2\u003e\n\u003ch3 id=\"heading-3\"\u003eHeading 3\u003c/h3\u003e\n\u003ch4 id=\"heading-4\"\u003eHeading 4\u003c/h4\u003e\n\u003ch5 id=\"heading-5\"\u003eHeading 5\u003c/h5\u003e\n\u003ch6 id=\"heading-6\"\u003eHeading 6\u003c/h6\u003e\n\u003cul\u003e\n\u003cli\u003eBulleted list 1\u003c/li\u003e\n\u003cli\u003eBulleted list 2\u003c/li\u003e\n\u003cli\u003eBulleterd list 3\u003c/li\u003e\n\u003c/ul\u003e\n\u003col\u003e\n\u003cli\u003eOrdered list\u003c/li\u003e\n\u003cli\u003eOrdered list\u003c/li\u003e\n\u003cli\u003eOrdered list\u003c/li\u003e\n\u003c/ol\u003e","title":"Test Post"},{"content":"Social Icons Name Platform Link 123rf 123rf.com adobestock stock.adobe.com apple music music.apple.com behance behance.net bilibili bilibili.com bitcoin - buymeacoffee buymeacoffee.com codepen codepen.io cryptohack cryptohack.org ctftime ctftime.org cv - deezer deezer.com dev dev.to discogs discogs.com discord discord.com dreamstime dreamstime.com dribbble dribbble.com email - facebook facebook.com flickr flickr.com freepik freepik.com gitea gitea.io github github.com gitlab gitlab.com goodreads goodreads.com googlescholar scholar.google.com guruShots gurushots.com hackerone hackerone.com hackerrank hackerrank.com hackthebox hackthebox.eu instagram instagram.com itchio itch.io kaggle - kakaotalk kakaocorp.com/service/KakaoTalk key - keybase keybase.io kofi ko-fi.com komoot - lastfm last.fm letterboxd - liberapay liberapay.com linkedin linkedin.com mastodon mastodon.social matrix matrix.org medium medium.com monero - mixcloud mixcloud.com nuget nuget.org paypal paypal.com peertube - pgp - phone - ploywork ploywork.com qq qq.com reddit reddit.com researchgate researchgate.net rss - serverfault serverfault.com soundcloud soundcloud.com shutterstock shutterstock.com slack slack.com snapchat snapchat.com/add spotify spotify.com stackoverflow stackoverflow.com steam steampowered.com strava strava.com telegram telegram.org `tiktok tiktok.com twitch twitch.tv twitter twitter.com unsplash unsplash.com xda xda-developers.com xing xing.com ycombinator ycombinator.com youtube youtube.com other - Usage :\nsocialIcons: - name: \u0026#34;kofi\u0026#34; url: \u0026#34;https://kofi.com\u0026#34; - name: \u0026#34;twitter\u0026#34; url: \u0026#34;https://twitter.com\u0026#34; Share Icons No. Platform twitter (also generates hash tags from tags linked with post) linkedin reddit facebook whatsapp telegram Usage:\nparams: ShowShareButtons: true params: ShareButtons: [\u0026#34;linkedin\u0026#34;, \u0026#34;twitter\u0026#34;] # To customize which share buttons to be enabled on page ","permalink":"https://archit15singh.github.io/posts/papermod-icons/","summary":"List of all Icons supported by PaperMod","title":"Icons"},{"content":"Below are variables used with this theme\u0026hellip;\nSite Variables under Params name type example Description env string \u0026lsquo;production\u0026rsquo; To set env to production title string \u0026lsquo;My Blog\u0026rsquo; To set title description string \u0026lsquo;This is a blog of mine\u0026rsquo; To set site description author string |list \u0026lsquo;Me\u0026rsquo; | [\u0026lsquo;Me\u0026rsquo;,\u0026lsquo;You\u0026rsquo;] To show multiple Authors images string \u0026lsquo;myimage.png\u0026rsquo; Link or path of image for opengraph, twitter-cards keywords list [blog, page] Add keywords for Home page DateFormat string \u0026ldquo;January 2, 2006\u0026rdquo; The format of date strings in the website. Details languageAltTitle string \u0026ldquo;English\u0026rdquo; Alternate title in Multilingual Mode ShowReadingTime boolean true | false To show read time in post meta ShowShareButtons boolean true | false To show/hide share buttons under post ShowCodeCopyButtons boolean true | false To show/hide Code Copy button ShowFullTextinRSS boolean true | false To show Content in RSS feed defaultTheme string light | dark | auto To set default theme disableThemeToggle boolean true | false To disable theme toggle icon shown besides label disableSpecial1stPost boolean true | false To disable no-card special appearance of 1st post disableScrollToTop boolean true | false To disable ScrollToTop button disableAnchoredHeadings boolean true | false To disable Anchored Headings hideMeta boolean true | false To Hide meta elements : date, read-time, author and available-translations for page hideSummary boolean true | false To Hide summary being shown in list pages showtoc boolean true | false To show/hide Table of Contents tocopen boolean true | false To keep open ToC by default on page load ShowPostNavLinks boolean true | false Show Previous and Next Posts below a Post ShowBreadCrumbs boolean true | false Show BreadCrumb Navigation above single post/page ShareButtons list [\u0026ldquo;linkedin\u0026rdquo;, \u0026ldquo;twitter\u0026rdquo;] To customize which share buttons to be enabled on page ShowWordCount boolean true | false To word count to metadata ShowRssButtonInSectionTermList boolean true | false To show RSS icon in Section, Term and List pages UseHugoToc boolean true | false To use Hugo\u0026rsquo;s default Toc instead of custom comments boolean true | false To show/hide comments hideFooter boolean true | false To Hide Footer Text om the end of page CanonicalLinkText string \u0026lsquo;Originally published at\u0026rsquo; To show text before canonical URL\u0026rsquo;s hostname analytics.google.SiteVerificationTag string \u0026ldquo;XYZabc\u0026rdquo; Site Verification Tag for Google Analytics analytics.bing.SiteVerificationTag string \u0026ldquo;XYZabc\u0026rdquo; Site Verification Tag for Bing analytics.yandex.SiteVerificationTag string \u0026ldquo;XYZabc\u0026rdquo; Site Verification Tag for Yandex schema - - Details fuseOpts - - Details socialIcons - - Details label - - Details assets - - Details cover - - Details profileMode - - Details editPost - - Details Site Variables name type example Description copyright string **[example.site](https://example.site)** This is HUGO\u0026rsquo;s site variable, which can also render markdown content label name type example Description label.text string \u0026lsquo;Home\u0026rsquo; To display different label text other than title label.icon string \u0026lsquo;/apple-touch-icon.png\u0026rsquo; To display a logo image in label label.iconHeight integer 35 To set size of label logo image profileMode name type example Description profileMode.enabled boolean true | false For enabling profileMode, needs to be explicitly set profileMode.title string \u0026ldquo;Title\u0026rdquo; Title profileMode.subtitle string \u0026ldquo;subtitle here\u0026rdquo; Subtitle profileMode.imageUrl string \u0026ldquo;image.png\u0026rdquo; | \u0026ldquo;https://example.com/image.jpg\" Image URL or Link profileMode.imageWidth string \u0026ldquo;150\u0026rdquo; Width of image profileMode.imageHeight string \u0026ldquo;150\u0026rdquo; Height of image profileMode.imageTitle string \u0026ldquo;This image is a picture of ..\u0026rdquo; Title of image profileMode.buttons - - Details profileMode.buttons profileMode: buttons: - name: Archive url: \u0026#34;/archive\u0026#34; - name: Github url: \u0026#34;https://github.com/\u0026#34; assets name type example Description assets.favicon string \u0026lsquo;icon.ico\u0026rsquo; To set favicon, can be path or external link assets.disableHLJS boolean true | false To disable Highlight.js loading assets.disableFingerprinting boolean true | false To disable Sub-Resource integrity for assets assets.theme_color string \u0026lsquo;#color\u0026rsquo; To set custom meta theme-color assets.msapplication_TileColor string \u0026lsquo;#color\u0026rsquo; To set custom msapplication_TileColor cover name type example Description cover.linkFullImages boolean true | false To open full size cover images on click on cover cover.responsiveImages boolean true | false To enable/disable generation of responsive cover images cover.hidden boolean true | false To hide everywhere but not in structured data cover.hiddenInList boolean true | false To hide on list pages and home cover.hiddenInSingle boolean true | false To hide on list pages and home schema name type example Description schema.publisherType string \u0026lsquo;Organization\u0026rsquo; https://schema.org/publisher schema.sameAs list [\u0026ldquo;URL1\u0026rdquo;, \u0026ldquo;URL2\u0026rdquo;] Set https://schema.org/sameAs fuseOpts Refer: https://fusejs.io/api/options.html\nfuseOpts: isCaseSensitive: false shouldSort: true location: 0 distance: 1000 threshold: 0.4 minMatchCharLength: 0 keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;content\u0026#34;] ## can be less but not more than shown in list socialIcons socialIcons: - name: \u0026#34;\u0026lt;platform\u0026gt;\u0026#34; url: \u0026#34;\u0026lt;link\u0026gt;\u0026#34; - name: \u0026#34;\u0026lt;platform 2\u0026gt;\u0026#34; url: \u0026#34;\u0026lt;link2\u0026gt;\u0026#34; editPost editPost: URL: \u0026#34;https://github.com/\u0026lt;path_to_repo\u0026gt;/content\u0026#34; Text: \u0026#34;Suggest Changes\u0026#34; # edit text appendFilePath: true # to append file path to Edit link Note: Same format is being used by Page Variables\nPage Variables Name Type Example Description showtoc boolean true | false To show/hide Table of Contents tocopen boolean true | false To keep open ToC by default on page load hidemeta boolean true | false To Hide meta elements : date, read-time, author and available-translations for page comments boolean true | false To show/hide comments description string \u0026lsquo;description text\u0026rsquo; Show Post Description under Title canonicalURL string \u0026ldquo;https://canonical.url/to/page\" To add canonical URL to posts ShowCanonicalLink boolean true | false To show canonical URL\u0026rsquo;s hostname CanonicalLinkText string \u0026lsquo;Originally published at\u0026rsquo; To show text before canonical URL\u0026rsquo;s hostname disableShare boolean true | false To hide/show share icons under a page disableHLJS boolean true | false To disable Highlight.js loading disableAnchoredHeadings boolean true | false To disable Anchored Headings searchHidden boolean true | false Hide page from search hideSummary boolean true | false To Hide summary being shown in list pages hideFooter boolean true | false To Hide Footer Text om the end of page ShowReadingTime boolean true | false To show read time in post meta ShowBreadCrumbs boolean true | false Show BreadCrumb Navigation above single post/page ShowPostNavLinks boolean true | false Show Previous and Next Posts below a Post ShowCodeCopyButtons boolean true | false To show/hide Code Copy button author string |list \u0026lsquo;Me\u0026rsquo; | [\u0026lsquo;Me\u0026rsquo;,\u0026lsquo;You\u0026rsquo;] To show multiple Authors cover.image string \u0026lsquo;featured.jpg\u0026rsquo; To add a cover image cover.caption string \u0026lsquo;caption for image\u0026rsquo; To add caption to cover image cover.alt string \u0026rsquo;this is cover image\u0026rsquo; Alternate text to show if image doesn\u0026rsquo;t load/show up cover.relative boolean true | false To use relative path for cover image, used in hugo Page-bundles cover.responsiveImages boolean true | false To enable/disable generation of responsive cover images cover.hidden boolean true | false To hide on current single page weight integer 5 To set page order or to pin a post to Top of list ShareButtons list [\u0026ldquo;linkedin\u0026rdquo;, \u0026ldquo;twitter\u0026rdquo;] To customize which share buttons to be enabled on page ShowWordCount boolean true | false To word count to metadata ShowRssButtonInSectionTermList boolean true | false To show RSS icon in Section, Term and List pages UseHugoToc boolean true | false To use Hugo\u0026rsquo;s default Toc instead of custom robotsNoIndex boolean true | false To hide a particular page from indexing by search engines ","permalink":"https://archit15singh.github.io/posts/papermod-variables/","summary":"List of Front Matter variables used by PaperMod","title":"Variables | Front Matter"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;â€”\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\nâ€” Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code Code Blocks Inline Code This is Inline Code\nOnly pre This is pre text Code block with backticks \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with backticks and language specified 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;meta name=\u0026#34;description\u0026#34; content=\u0026#34;Sample article showcasing basic Markdown syntax and formatting for HTML elements.\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Gist List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements â€” abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://archit15singh.github.io/posts/markdown-syntax/","summary":"\u003cp\u003eThis article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\u003c/p\u003e","title":"Markdown Syntax Guide"},{"content":"Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\nYouTube Privacy Enhanced Shortcode Twitter Simple Shortcode â€œIn addition to being more logical, asymmetry has the advantage that its complete appearance is far more optically effective than symmetry.â€\nâ€” Jan Tschichold pic.twitter.com/gcv7SrhvJb\n\u0026mdash; Design Reviewed | Graphic Design History (@DesignReviewed) January 17, 2019 Vimeo Simple Shortcode ","permalink":"https://archit15singh.github.io/posts/rich-content/","summary":"\u003cp\u003eHugo ships with several \u003ca href=\"https://gohugo.io/content-management/shortcodes/#use-hugos-built-in-shortcodes\"\u003eBuilt-in Shortcodes\u003c/a\u003e for rich content, along with a \u003ca href=\"https://gohugo.io/about/hugo-and-gdpr/\"\u003ePrivacy Config\u003c/a\u003e and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\u003c/p\u003e","title":"Rich Content"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates (extend_head.html) like so: refer ISSUE #236 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: \\(\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887â€¦\\) Block math:\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","permalink":"https://archit15singh.github.io/posts/math-typesetting/","summary":"\u003cp\u003eMathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\u003c/p\u003e","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\nğŸ™ˆ :see_no_evil: ğŸ™‰ :hear_no_evil: ğŸ™Š :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n.emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","permalink":"https://archit15singh.github.io/posts/emoji-support/","summary":"\u003cp\u003eEmoji can be enabled in a Hugo project in a number of ways.\u003c/p\u003e","title":"Emoji Support"}]