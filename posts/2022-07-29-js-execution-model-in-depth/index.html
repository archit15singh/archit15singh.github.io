<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive) | Archit's Space</title>
<meta name=keywords content="JavaScript,Technical Deep Dive"><meta name=description content="Explore how JavaScript code actually runs: from the engine and host environment to call stacks, queues, realms, agents, and async behavior â€” explained with mental models, real code, and execution traces."><meta name=author content="Archit Singh"><link rel=canonical href=https://archit15singh.github.io/posts/2022-07-29-js-execution-model-in-depth/><link crossorigin=anonymous href=/assets/css/stylesheet.min.1c5241cc5c31e8a1af5a56caa332bfa60cee35277d8fb31c7063ca9ed7258093.css integrity="sha256-HFJBzFwx6KGvWlbKozK/pgzuNSd9j7MccGPKntclgJM=" rel="preload stylesheet" as=style><link rel=icon href=https://archit15singh.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://archit15singh.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://archit15singh.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://archit15singh.github.io/apple-touch-icon.png><link rel=mask-icon href=https://archit15singh.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.145.0"><link rel=alternate hreflang=en href=https://archit15singh.github.io/posts/2022-07-29-js-execution-model-in-depth/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive)"><meta property="og:description" content="Explore how JavaScript code actually runs: from the engine and host environment to call stacks, queues, realms, agents, and async behavior â€” explained with mental models, real code, and execution traces."><meta property="og:type" content="article"><meta property="og:url" content="https://archit15singh.github.io/posts/2022-07-29-js-execution-model-in-depth/"><meta property="og:image" content="https://archit15singh.github.io/images/uploads/cosmic-timetraveler.webp"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-29T12:00:00+00:00"><meta property="article:modified_time" content="2022-07-29T12:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://archit15singh.github.io/images/uploads/cosmic-timetraveler.webp"><meta name=twitter:title content="How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive)"><meta name=twitter:description content="Explore how JavaScript code actually runs: from the engine and host environment to call stacks, queues, realms, agents, and async behavior â€” explained with mental models, real code, and execution traces."><meta name=twitter:site content="@https://twitter.com/archit_singh15"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://archit15singh.github.io/posts/"},{"@type":"ListItem","position":2,"name":"How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive)","item":"https://archit15singh.github.io/posts/2022-07-29-js-execution-model-in-depth/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive)","name":"How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive)","description":"Explore how JavaScript code actually runs: from the engine and host environment to call stacks, queues, realms, agents, and async behavior â€” explained with mental models, real code, and execution traces.","keywords":["JavaScript","Technical Deep Dive"],"articleBody":"How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive) ğŸš€ What This Series Will Teach You This blog post is the first step of a multi-part deep dive into the JS execution model. Youâ€™ll learn:\nHow JavaScript handles synchronous and asynchronous code What the call stack, job queue, microtasks, and event loop really are How realms, agents, and execution contexts work together How engines like V8 optimize while staying spec-compliant Why seemingly simple code can behave unexpectedly â€” and how to reason through it Each section will build your mental model â€” with visuals, real code traces, intuitive metaphors, and runtime behavior breakdowns.\nğŸ“Œ Whether youâ€™re building a single-page app, debugging race conditions, or writing high-performance server-side JS â€” knowing how JS really runs is your ultimate superpower.\n1. ğŸ¯ Introduction: What is the JavaScript Execution Model? JavaScript might look simple â€” you write let x = 10, it runs. You call a function, it executes. But under the hood, a sophisticated system choreographs every line you write. That system is called the JavaScript execution model.\nğŸ§  Soâ€¦ what is it? At its core, the JavaScript execution model defines how JavaScript code runs:\nHow the engine interprets your code How memory is allocated and freed How functions get stacked and unstacked How asynchronous code (like setTimeout or fetch) is managed How multiple â€œthreadsâ€ (agents) interact â€” or donâ€™t Itâ€™s like the operating system of JavaScript â€” the abstract machine that governs how your code behaves, step-by-step.\nğŸ§© Why should developers care? You donâ€™t need to know every VM optimization trick to write JavaScriptâ€¦\nBut if you want to:\nFix timing bugs Master Promises, async/await, and the event loop Avoid race conditions and memory leaks Write responsive apps that never freeze the UI Debug async issues like â€œWhy does this log after that?â€ â€¦then understanding the execution model isnâ€™t optional â€” itâ€™s essential.\nItâ€™s the foundation beneath everything from simple loops to complex front-end architectures to performance-critical backends.\nğŸ†š Spec vs Reality: Goals of the Execution Model The ECMAScript specification (the official language definition) defines the execution model in a platform-neutral, abstract way.\nThis spec outlines the rules all JavaScript engines must follow, regardless of environment:\nBrowsers (Chrome/V8, Firefox/SpiderMonkey, Safari/JavaScriptCore) Servers (Node.js, Deno) Embedded runtimes (e.g. IoT devices) However, real engines are free to optimize â€” just like how chess players can use different tactics, but must follow the same rules.\nFor example:\nV8 (Chrome/Node.js) uses Just-In-Time (JIT) compilation, inline caching, and memory optimizations. But it still follows the logical model the spec describes: same rules, different execution speed. ğŸ’¡ TL;DR: The spec defines what must happen, not how fast or how exactly an engine does it.\nğŸ­ Real-World Metaphor: Actor, Stage, Script Letâ€™s break it down with a metaphor:\nYour code = the script The JavaScript engine = the actor The host environment (browser, Node) = the stage, lighting, props, audience The execution model = the stage manager â€” orchestrating who enters when, what lines are spoken, and how long each actor gets to perform The actor (engine) canâ€™t improvise wildly â€” it must follow the script (your code) â€” but the stage manager decides when scenes start, what props are ready, and how long each act lasts.\nAnd just like in theater: no actor can speak two lines at the same time. JavaScript, too, is single-threaded â€” one line at a time, unless you start spinning off background actors (Web Workers, Service Workers).\nğŸ§© 2. Core Architecture of JavaScript Runtime To understand how JavaScript runs your code, we need to dissect what components make up the JS runtime.\nAt the core, JavaScript doesnâ€™t run in a vacuum â€” it needs an engine to interpret the code, and a host environment to provide real-world capabilities like networking, timers, and file access.\nLetâ€™s peel this layer by layer.\nğŸ”¹ 2.1. The JavaScript Engine âœ… Literal meaning: The engine is the heart of the JavaScript runtime. Itâ€™s the software that understands and executes ECMAScript â€” the official JavaScript language specification.\nğŸ§  What it provides: Parsing: Reads and interprets JS source code (e.g., turns function foo() {} into a syntax tree). Execution: Runs your code step-by-step, managing memory, stack, scopes, etc. Optimization: Applies techniques like JIT (Just-In-Time) compilation, inline caching, dead code elimination for speed. ğŸ›  Examples of engines: V8 (Chrome, Node.js) SpiderMonkey (Firefox) JavaScriptCore (Safari) Chakra (deprecated, formerly in Edge) ğŸ§¬ Mental model: Think of the engine like a brain that knows how to read JavaScript, understand it, and run it â€” but itâ€™s stuck in a box. It canâ€™t talk to the outside world unless someone wires it up.\n// This is purely engine territory: const x = 5 + 3; const doubled = x * 2; No DOM. No timers. No file I/O. Just language-level stuff.\nğŸ”¹ 2.2. The Host Environment âœ… Literal meaning: This is the external system embedding the JS engine.\nIt provides platform-specific APIs and functionalities that the engine alone cannot offer.\nğŸŒ Common host environments: Web browsers: Chrome, Firefox, Safari Node.js: Server-side JS runtime Deno: Secure, modern runtime for JS/TS React Native: JS inside mobile apps Adobe After Effects: JS for scripting animation! ğŸ›  Host-provided APIs: These arenâ€™t part of the JS language â€” theyâ€™re provided by the host:\nAPI / Feature Provided by setTimeout() Browser / Node document.querySelector() Browser fs.readFile() Node.js fetch() Browser / Node (polyfilled) postMessage() Web Worker context navigator.geolocation Browser ğŸ’» Example: console.log(\"Hello\"); // Host provides the 'console' object setTimeout(() =\u003e { alert(\"Hi\"); }, 1000); // 'setTimeout' is NOT part of JS â€” it's host API ğŸ§¬ Real-world analogy: The JS engine is the actor. The host environment is the stage, lighting, props, and audience. The actor can memorize lines (JavaScript), but canâ€™t do anything â€” like turn on a spotlight or play sound â€” unless the stage supports it.\nğŸ”¹ 2.3. Engine vs Host: Division of Concerns âœ… Literal meaning: JavaScript engines and host environments play distinct but collaborative roles.\nConcern Handled by let, const, class, =\u003e JavaScript Engine console.log, setTimeout Host Environment document.getElementById Host (Browser) fs.readFileSync Host (Node.js) ğŸ§  Why this matters: JavaScript isnâ€™t â€œbrowser-onlyâ€ â€” itâ€™s a language, not a platform. This is why you can run JS in: a browser (with DOM), a server (Node.js), an embedded device (e.g. Espruino), or even in a text editor plugin (VS Code extensions). Each context offers different tools â€” but the engine stays the same.\nğŸ§ª Code Comparison: // Runs in browser setTimeout(() =\u003e console.log(\"Hi\"), 1000); document.body.style.background = \"black\"; // Runs in Node setTimeout(() =\u003e console.log(\"Hi\"), 1000); const fs = require(\"fs\"); fs.readFileSync(\"./file.txt\"); Same JS engine (V8), totally different capabilities, because of the host.\nâš ï¸ Gotcha: â€œWhy does JS code fail in Node but not in the browser?â€ // This fails in Node.js: document.getElementById(\"app\"); Because document is a host-provided object, and Node doesnâ€™t include a DOM.\nğŸ’¡ Same JavaScript. Different host. Different powers.\nğŸ”— Related Concept: Polyfills and Environment Detection Because hosts vary:\nWe need feature detection (typeof window, if ('fetch' in globalThis)) We write polyfills (e.g., implement fetch in Node if itâ€™s missing) ğŸ§  TL;DR Mental Model Layer Role JavaScript Engine Understands and executes ECMAScript code Host Environment Provides platform-specific capabilities JS Runtime Combination of engine + host (aka â€œJS in the wildâ€) ğŸ§© Summary Table Concept Engine or Host? Example Promise, Map Engine ECMAScript features setTimeout() Host Timer API (browser/Node) document Host (Browser) Web page interaction fs Host (Node.js) File system access console Host Logging (defined per host) function, =\u003e Engine Language-level syntax 3. ğŸ§  Agent Execution Model â€” The Secret Engine Behind JavaScriptâ€™s Run-Time JavaScript may look like a language, but it runs like a machine. Under the hood, every line of your JavaScript code is managed by a tiny execution engine called an agent.\nLetâ€™s crack open the hood and understand:\nWhat an agent actually is The key data structures that power it The lifecycle that makes async, generators, and tasks tick 3.1 ğŸš€ What is an Agent? In the JavaScript spec, an agent is a self-contained execution environment â€” like a virtual CPU.\nIt has its own memory (heap) Its own call stack Its own event/job queue If youâ€™re running JavaScript in a browser tab, thatâ€™s an agent.\nIf youâ€™re running a Web Worker, thatâ€™s another agent.\nEach agent is isolated from the others (unless explicitly connected via SharedArrayBuffer).\nğŸ§  Think of an agent as: A single thread of execution with all the gears it needs to process JavaScript independently.\nğŸ”¬ Metaphor: If your code is a cooking recipe, an agent is the chef executing it â€” with its own kitchen, ingredients, and clipboard of instructions.\n3.2 âš™ï¸ Agent Data Structures: The Triad Every agent internally runs three major data structures â€” the holy trinity of JS execution:\nğŸ§  1. Heap ğŸ“¦ Where objects and functions live â€” long-term storage.\nEvery time you create an object ({}), array ([]), or function, itâ€™s allocated on the heap. Think of the heap as your warehouse of live objects. const user = { name: \"Ada\" }; // lives in the heap This is unstructured memory â€” managed automatically by the garbage collector.\nğŸ§  2. Call Stack ğŸ§¾ Where functions are executed, tracked, and returned â€” one frame at a time.\nJavaScript uses a stack (LIFO) to manage function calls. Each function call creates an execution context (aka stack frame). When a function finishes, the frame is popped off. function outer() { inner(); } function inner() { console.log(\"Hi\"); } outer(); Stack:\nouter() inner() console.log(...) Return, return, done âœ… ğŸ”¬ Metaphor: Like opening nested boxes. You canâ€™t close box A until youâ€™ve closed box B inside it.\nğŸ§  3. Job/Task Queue ğŸ•“ A FIFO queue of pending asynchronous callbacks to run when the stack is empty.\nUsed by async actions: setTimeout, fetch, Promises Part of the event loop mechanism Each â€œjobâ€ is a callback waiting to be pulled onto the stack console.log(\"A\"); setTimeout(() =\u003e console.log(\"B\")); console.log(\"C\"); Output: A â†’ C â†’ B\nBecause setTimeout schedules B on the task queue, which runs after the current stack empties.\nğŸ”¬ All Together: Structure Type Role Heap Memory Stores all objects, functions Stack LIFO Tracks current function calls Queue FIFO Stores async jobs to run next 3.3 â³ Agent Lifecycle â€” How Code Actually Runs The life of a JavaScript agent is a predictable cycle:\nğŸ”„ Step 1: A Job Begins A new job is pulled from the queue (e.g., a setTimeout callback) A new execution context is pushed onto the stack JS starts running the code in that callback ğŸ“ˆ Step 2: Stack Fills Up The function may call other functions More execution contexts are added The call stack grows ğŸ“‰ Step 3: Stack Empties Each function finishes and returns The stack pops back down to empty Once empty, the agent picks the next job from the queue ğŸ’¤ Step 4: Idle or Re-entry If the queue is empty â†’ agent waits If the code yields (e.g. with a generator or async function), the context is paused It can later be resumed with the same state function* steps() { console.log(\"Start\"); yield; console.log(\"Resumed\"); } const g = steps(); g.next(); // Start g.next(); // Resumed ğŸ§  The function isnâ€™t restarted â€” itâ€™s resumed from where it left off.\nğŸ§  Why It Matters Understanding the agent model gives you deep insight into:\nWhy JS is single-threaded (per agent) Why async functions return promises Why await doesnâ€™t block the thread Why stack overflows happen (Recursion!) ğŸ’¡ Bonus: Multi-Agent Systems You can have multiple agents running concurrently (e.g., Web Workers) Each has its own stack, heap, and queue They can only communicate via: postMessage (copying data) SharedArrayBuffer + Atomics (shared memory) âœ… Recap: Agent Model Mental Picture Part Role Behavior Agent The JS â€œruntime engineâ€ Runs JS code sequentially Heap Stores objects Grows dynamically, managed by GC Stack Manages function calls LIFO â€” grows and shrinks Queue Schedules async jobs FIFO â€” drives the event loop Lifecycle Pull job â†’ execute â†’ finish â†’ repeat Enables async flow âœ¨ Real-World Debugging Tip When your UI freezes or console.log appears out of order â€” youâ€™re seeing the agent lifecycle in action.\nIf you understand how the stack and queue interact, you can predict and control the timing of your code.\n4. ğŸ“¦ Execution Contexts \u0026 Call Stack 4.1. ğŸ§  What is an Execution Context? An execution context (also called a stack frame) is the smallest unit of JS code execution.\nWhenever JavaScript runs any codeâ€”be it global, a function, or an evalâ€”it wraps it in an execution context.\nğŸ” It contains: ğŸ§¾ The currently executing function or script ğŸ“¦ Its Lexical Environment (all its declared variables, parameters, inner functions) ğŸ”— The associated Realm (global scope + intrinsics like Array) ğŸ’¬ Special bindings like this, arguments, and super ğŸ§­ The return address (where to go back once the function completes) ğŸ§¬ Mental Model: Like a stack of sticky notes: each time a function is called, a new note (context) is added. It tracks what to do and where to return. Once done, it peels off.\nğŸ’» Example: function add(a, b) { return a + b; } function compute(x) { const y = 2; return add(x, y); } compute(5); // Execution Contexts created: global -\u003e compute -\u003e add Each function call creates a new context with its own scope, this, and state.\nğŸ§© Lexical Environment Every execution context has a Lexical Environment, which stores:\nLocal variable bindings (let, const, var) Function declarations Inner scopes (closures) Itâ€™s called lexical because itâ€™s determined by where the code is written, not how it is called.\nğŸ” Closures: When a function is defined, it â€œremembersâ€ the Lexical Environment it was created in. This is what powers closures:\nfunction outer() { let count = 0; return function inner() { count++; return count; } } The inner function holds on to the outerâ€™s lexical environment even after outer has returned.\nğŸŒ Realm Association Each execution context is tied to a Realm, which determines:\nThe version of intrinsics like Array, Function, etc. The globalThis value Identity rules (e.g., x instanceof Array fails across realms) âš ï¸ Gotcha: // If `arr` is created in iframe arr instanceof Array; // âŒ false (different realm's Array) Array.isArray(arr); // âœ… works (uses internal tag) âš™ï¸ this, arguments, and Bindings Each context stores runtime-bound values:\nthis â€” depends on how the function is called (object method, arrow, etc.) arguments â€” array-like object for parameters (non-arrow functions) super â€” relevant in class methods New private class fields/methods also bind per context 4.2. ğŸ” Function Invocation \u0026 Stack Frames When a function is invoked:\nJS creates a new execution context (stack frame) Pushes it onto the call stack Begins executing it ğŸ“¤ When the function finishes: It returns a value or throws an error Its frame is popped off the stack Execution continues where it left off ğŸ’» Code Trace: function foo() { const x = 10; return bar(x); } function bar(n) { return n + 5; } foo(); ğŸ§± Stack trace:\n[global] â†’ foo() â† pushed â†’ bar(10) â† pushed â† return 15 â† bar popped â† return 15 â† foo popped ğŸ¯ Key behaviors: Return unwinds one frame Throw can unwind multiple frames up the stack (via try/catch or crash) Recursion builds up frames until base case or overflow âš¡ 4.3. Tail Call Optimization (TCO) Tail Call = when a function returns the result of calling another function directly\n(i.e., no more work left to do after the call).\nfunction a() { return b(); // â† tail position } If supported, JS engines can reuse the current stack frame rather than creating a new one.\nğŸ¯ Benefits: Prevents stack overflow in tail-recursive functions Improves memory efficiency for deeply nested calls ğŸ”¥ Example (ideal for TCO): function factorial(n, acc = 1) { if (n \u003c= 1) return acc; return factorial(n - 1, acc * n); // tail call } ğŸ” Without TCO â†’ Stack grows with n\nâœ… With TCO â†’ Constant memory usage\nâš ï¸ Engine Support Caveats: ECMAScript 2015 specifies proper TCO. Only Safari implements it (as of now). V8, SpiderMonkey, Chakra do not support it due to debugging \u0026 stack trace concerns. ğŸ§  Summary Table Concept Meaning \u0026 Purpose Execution Context Metadata + bindings for running code Stack Frame Unit of execution pushed onto the call stack Lexical Environment Local scope: variables, closures, declarations Realm JS â€œuniverseâ€ for built-ins, globalThis, etc. Call Stack LIFO structure tracking nested calls Return / Throw Unwinds stack frames (1 or more) Tail Call Optimization Reuses stack frame for tail calls (not widely supported) 5. ğŸŒ€ Understanding Realms: The Hidden Worlds of JavaScript Execution When we talk about JavaScript execution, we often focus on the call stack, the event loop, or async jobs. But thereâ€™s a deeper architectural layer that rarely gets discussedâ€”Realms.\nThink of realms as self-contained universes within a single JavaScript agent. If youâ€™re debugging why instanceof mysteriously returns false, or why your iframeâ€™s Array behaves strangely, youâ€™re bumping up against realmsâ€”without even knowing it.\nLetâ€™s unpack this critical concept with surgical depth and practical clarity.\nğŸ“¦ What Is a Realm? A realm is a sandboxed execution environment in JavaScript.\nEach realm has its own global object and its own copies of built-in constructors like Object, Array, Function, and so on.\nIn simpler terms:\nA realm is a complete JS worldâ€”with its own set of laws (built-ins), and its own sky (global object). It exists within an agent (a JS thread), and multiple realms can coexist inside a single agent. ğŸ§  Mental Model: ğŸ§µ Agent = one JS thread\nğŸŒ Realm = one JS environment (one globalThis)\nğŸ’¡ Real-World Examples: Your main browser tab â†’ 1 realm. A same-origin â†’ another realm (but in the same agent). A Web Worker â†’ a separate agent with its own realm. ğŸ”¬ Realm Internals Letâ€™s zoom into what makes up a realm:\n1. ğŸ§¬ Intrinsic Objects Each realm creates fresh copies of all intrinsic JS constructors and prototypes:\nArray !== iframe.contentWindow.Array; // âœ… true Object !== iframe.contentWindow.Object; // âœ… true These arenâ€™t just shallow copies â€” theyâ€™re entirely different objects in memory. This is what leads to one of the most notorious bugs in cross-realm JSâ€¦\nâš ï¸ Gotcha: instanceof fails across realms const iframeArray = iframe.contentWindow.eval(\"[]\"); iframeArray instanceof Array; // âŒ false Array.isArray(iframeArray); // âœ… true Why? Because iframeArrayâ€™s prototype chain points to iframeâ€™s Array.prototype, not yours.\nThis is why you should always use:\nArray.isArray(obj) Object.prototype.toString.call(obj) â€¦and never rely on instanceof when realms might be involved.\n2. ğŸª Global Object and globalThis Each realm gets its own global object, which defines the top-level scope.\nDepending on the context, this global object could be:\nA Window (in a tab or iframe) A WorkerGlobalScope (in a worker) A WorkletGlobalScope (in an audio or paint worklet) window.globalThis === window; // âœ… in a tab self.globalThis === self; // âœ… in a worker Each realm has a unique globalThis â€” they donâ€™t bleed into each other.\n3. ğŸ§  Template Literal Cache Tagged template literals reuse the same array object on repeated calls within the same realm:\nfunction tag(strings) { console.log(strings); // same object each time } tag`hello`; // strings === [\"hello\"] tag`hello`; // strings is the same object But that cache is per-realm. Use a different realm (like an iframe), and youâ€™ll get a different array object, even with the same template.\nğŸ§© Realms vs Agents Letâ€™s clarify the distinction:\nConcept Realm Agent What it is A JS environment with its own global scope \u0026 built-ins A JS thread (executor of code) Count Multiple per agent One per thread Global object Unique per realm (window, self, etc.) Not shared across agents Memory Shared heap (within same agent) Isolated between agents unless using SharedArrayBuffer ğŸ” Realms Can Talk (if in same agent) If you have:\n\u003ciframe src=\"same-origin.html\"\u003e\u003c/iframe\u003e You can synchronously access the iframeâ€™s realm:\niframe.contentWindow.document.title; // âœ… works But remember: itâ€™s a different realm. So be cautious with identity checks.\nğŸ” Why Realms Matter in the Real World 1. Security and Isolation Realms provide containment: Each realm is sandboxed with its own set of built-ins and globals. Cross-origin iframes get different agents and different realms, enforcing strict separation. 2. Framework \u0026 Testing Tooling Tools like Jest, JSDOM, or sandboxed evaluators often run code in isolated realms to prevent global pollution. 3. Micro-frontend Architecture In advanced front-end architectures, teams load independent apps in iframes or ShadowRealms to prevent conflicts. 4. Cross-Realm Bugs If youâ€™re building libraries, especially polyfills or type-checking utils, you must account for realm differences. // Anti-pattern value instanceof Object; // âŒ not safe across realms // Safe alternative Object.prototype.toString.call(value) === \"[object Object]\"; // âœ… ğŸ§  Takeaways A realm is a self-contained JS universe â€” with its own global scope and its own versions of built-in types. Realms can coexist inside a single agent, but their built-ins and identity checks do not overlap. Always prefer realm-safe methods (Array.isArray, Object.prototype.toString.call) over instanceof. Understand realms if youâ€™re working with: iframes workers multi-app frontends testing sandboxes serialization/deserialization across origins ğŸ“Œ Bonus: ShadowRealm (TC39 Stage 3) A new JS feature, ShadowRealm, allows you to create a new realm programmatically without using iframes:\nconst realm = new ShadowRealm(); const result = realm.evaluate(`1 + 1`); // 2 This is realm-level isolation, but still within the same agent. Great for security, testing, or plugin systems.\nâœï¸ Final Word JavaScript realms are like alternate realities â€” isolated yet interconnected in subtle ways. They influence how your objects behave, how identity is checked, and how memory is managed.\nUnderstanding realms is a superpower â€” especially if youâ€™re debugging strange prototype issues or building frameworks and platforms. Master this layer, and youâ€™re one step closer to mastering the entire JavaScript execution model.\n6. ğŸŒ Agent Types in the Web Platform 6.1. Main Window Agent 6.2. Dedicated Worker Agent 6.3. Shared Worker Agent 6.4. Service Worker Agent 6.5. Worklet Agent Each has its own heap, stack, queue Communication model (postMessage, SharedArrayBuffer) 6. ğŸŒ Agent Types in the Web Platform The web isnâ€™t just one giant thread where all JavaScript code runs together. Instead, itâ€™s composed of multiple agents â€” isolated, independent runtimes that can each execute JS code with their own heap, call stack, and event loop. Understanding these agent types is crucial for mastering concurrency, memory isolation, and performance design patterns in modern web development.\nLetâ€™s break down the main types of agents and why they matter:\n6.1 ğŸªŸ Main Window Agent This is the agent you interact with most â€” the tab in your browser running HTML, CSS, and JavaScript. It includes:\nThe global window object Access to the DOM Full access to browser APIs (e.g., document, alert, fetch) Multiple same-origin iframes can share the same agent, meaning they share the call stack and can synchronously call each otherâ€™s functions and access each otherâ€™s memory (within security limits).\nğŸ“Œ Key traits:\nHas direct DOM access Can synchronously communicate with same-origin iframes Cannot be blocked via Atomics.wait() ğŸ§  Mental model: A control room managing user interaction, UI rendering, and input events â€” all on one thread.\n6.2 ğŸ‘· Dedicated Worker Agent Created via new Worker(), a Dedicated Worker runs JS in a completely separate agent â€” its own isolated thread. It doesnâ€™t have access to the DOM, but can perform heavy computations without blocking the main thread.\nğŸ“¦ Separate agent = separate memory:\nOwn heap Own call stack Own event loop ğŸ§  Think of it like spawning a specialized assistant: you give it instructions via postMessage(), and it replies asynchronously.\nâœ… Can use SharedArrayBuffer for shared memory (with proper CORS and COOP/COEP headers)\nğŸ’»\nconst worker = new Worker(\"worker.js\"); worker.postMessage({ task: \"compute\" }); 6.3 ğŸ¤ Shared Worker Agent Shared Workers are like Dedicated Workers, but shared across multiple same-origin contexts â€” tabs, iframes, or windows. They persist beyond a single page and can maintain shared state (like a single WebSocket connection).\nğŸ“Œ Key distinction: They do not share memory with their clients. All communication is through postMessage() using structured cloning.\nğŸ§  Metaphor: A shared database or message bus multiple clients talk to, but no one can directly poke into its memory.\n6.4 ğŸ›° Service Worker Agent A Service Worker is a proxy-like agent that sits between your web app and the network. It doesnâ€™t have a UI and cannot touch the DOM, but it can:\nIntercept network requests Serve cached assets Enable offline experiences Run even when the page is closed ğŸ“¦ It has its own agent â€” its own heap, stack, and event queue â€” and doesnâ€™t share memory with any window.\nğŸ§  Think of it as a background daemon that acts as a programmable router.\nğŸ’¡ Bonus: Service workers are essential for building Progressive Web Apps (PWAs).\n6.5 ğŸ¨ Worklet Agent Worklets are ultra-lightweight, low-latency agents used for frame-by-frame operations in:\nAudioWorklet (real-time DSP) PaintWorklet (CSS custom painting) LayoutWorklet (custom layout logic) These agents are stripped down for speed â€” no DOM, no network access, but real-time-safe execution.\nğŸ§  Imagine a tiny artist or sound engineer working just fast enough to keep up with your browserâ€™s 60FPS heartbeat.\nğŸ“Œ They run inside their own agent and can be memory-shared with their creators using SharedArrayBuffer.\nğŸ§¬ All Agent Types Have: âœ… Their own execution context:\nHeap: where objects live Call stack: for function execution Job queue: for async callbacks (event loop) âœ… Communication model:\nğŸ” postMessage() for asynchronous messaging (structured cloning) ğŸ”— SharedArrayBuffer + Atomics for shared memory and synchronization (if in the same agent cluster) ğŸ§  Summary Table Agent Type DOM Access Memory Sharing Shared Across Tabs? Use Case Main Window Agent âœ… Yes âœ… with same-origin iframes âŒ UI logic, DOM interaction Dedicated Worker âŒ No âœ… via SharedArrayBuffer âŒ Heavy computation, parallel tasks Shared Worker âŒ No âŒ âœ… Cross-tab state sync, WebSocket hub Service Worker âŒ No âŒ âœ… Offline support, request caching Worklet âŒ No âœ… (when configured) âŒ Real-time audio/visual processing ğŸ”— Related Concepts: Agent Cluster: A group of agents that can share memory (SharedArrayBuffer) and synchronize with Atomics. Structured Cloning: Default communication method â€” objects are copied, not shared. Heap / Stack / Queue: Every agent gets their own â€” enabling safe, parallel, isolated execution. ğŸ“£ Takeaway:\nModern JavaScript isnâ€™t single-threaded anymore â€” itâ€™s multi-agent.\nYou, as a developer, control which type of agent runs your code â€” and how they communicate. Choose wisely based on memory safety, responsiveness, and your appâ€™s architecture.\n7. ğŸ” Job Queue \u0026 Event Loop Modern JavaScript feels synchronous â€” but behaves asynchronously. That paradox is powered by one of the most elegant constructs in programming: the event loop.\nLetâ€™s dive deep into how JavaScript keeps your code non-blocking, predictable, and responsive â€” using jobs, queues, and a beautiful bit of choreography called the run-to-completion model.\n7.1 ğŸ”§ What is a Job? Callback + Execution Context = Job\nEvery time your code hands off a function to be called later â€” say, via setTimeout, a Promise, or a DOM event â€” youâ€™re scheduling a job. Think of it as a tiny program JS will run once itâ€™s done with the current one.\nThese jobs are stored in queues and executed one at a time, with guaranteed order and isolation.\nğŸ§  Mental Model:\nEach job is like a fully wrapped meal order â€” a recipe (callback) bundled with ingredients (execution context). JS cooks them one-by-one, never two at once.\n7.2 ğŸ”„ Event Loop: The Scheduler-in-Chief At the heart of this system is the event loop, the mechanism that:\nWaits for the stack to be empty Pulls the next job from the queue Executes it entirely before moving on This is the run-to-completion guarantee.\nğŸ’¡ Why it matters:\nNo two callbacks ever run at the same time Shared variables are safe during a job Your program stays predictable and easy to reason about console.log(\"A\"); setTimeout(() =\u003e console.log(\"B\"), 0); console.log(\"C\"); // Output: // A // C // B ğŸ” Even though the timer is 0ms, it gets queued as a job and only runs after current code finishes.\n7.3 âš–ï¸ Microtasks vs Macrotasks Not all jobs are equal. The queue is actually two queues:\nType Examples Priority Microtasks Promise.then, queueMicrotask() ğŸ”¥ High (drained first) Macrotasks setTimeout, setInterval, DOM events â³ Lower After every job (macro or otherwise), the event loop drains all microtasks before running the next macro task.\nconsole.log(\"Start\"); setTimeout(() =\u003e console.log(\"Timeout\"), 0); Promise.resolve().then(() =\u003e console.log(\"Promise\")); console.log(\"End\"); // Output: // Start // End // Promise // Timeout ğŸ“Œ Microtasks are prioritized â€” even over timers.\nğŸ§  Metaphor:\nMicrotasks are sticky notes on your desk. Macrotasks are meetings. After finishing a job (macro), JS clears all sticky notes (micro) before going to the next meeting.\n7.4 ğŸ§µ Blocking vs Non-Blocking JSâ€™s single-threaded nature means blocking is dangerous â€” if your code stalls, your UI freezes, your app becomes unresponsive.\nâœ… Async I/O â€” like fetch, setTimeout, readFile â€” is non-blocking by design.\nğŸš« But legacy APIs can block the agent entirely:\nAPI Behavior alert() Blocks entire tab confirm() Blocking XMLHttpRequest (sync) Blocking ğŸ’¡ Even while(true){} loops will freeze your app.\nğŸ” Modern JavaScript avoids blocking at all costs by using:\nThe event loop The job queue And a non-blocking I/O model ğŸ’¡ Final Mental Model Visualize JavaScript as a factory:\nğŸ—ï¸ Call Stack: The active workstation (only one at a time) ğŸ“¬ Job Queue: A mailbox full of tasks to run ğŸ” Event Loop: A robot that: Waits for the workstation to be free Picks the next job from the mailbox Ensures no job starts until the last one finishes And among the jobs:\nğŸ“ Microtasks are urgent memos â€” always read before any new mail. â° Macrotasks are full packages â€” scheduled deliveries that wait their turn. This model gives JS its magic mix of simplicity + power:\nSingle-threaded but never frozen (if you follow the rules) Predictable execution with async capabilities Safe by default, powerful when needed Next time you wonder why Promises beat timers, or why your UI freezes, or why console.log shows up before your setTimeout, remember:\nYouâ€™re not just writing code â€” youâ€™re orchestrating a symphony of jobs in a beautifully synchronized single-threaded engine.\n8. ğŸ§  Concurrency \u0026 Memory Sharing In the world of JavaScript, we often talk about single-threaded execution, the event loop, and asynchronous callbacks. But what happens when multiple threadsâ€”agents, in ECMAScript speakâ€”need to share memory and coordinate? Thatâ€™s where agent clusters, shared memory, and atomic operations come in.\nThis section dives into JavaScriptâ€™s low-level concurrency primitives, showing how modern engines manage parallelism safely using shared memory, and how developers can reason about memory consistency, data races, and synchronization.\n8.1 âš¡ Agent Clusters: Who Can Share Memory with Whom? In JavaScript, every independent execution contextâ€”like a tab, worker, or iframeâ€”is called an agent. But not all agents are created equal. Only some can share memory.\nAgents that can share memory form whatâ€™s called an agent cluster.\nğŸ§  Core Rule: If two agents can share a SharedArrayBuffer, they belong to the same cluster. If not, they are completely isolated.\nâœ… In the Same Cluster (can share memory): A Window and the Dedicated Worker it creates A Worker and the Dedicated Worker it spawns A Window and a same-origin iframe A Window and a same-origin opener window A Window and its Worklet âŒ Different Clusters (canâ€™t share memory): A Window and a SharedWorker A Window and a ServiceWorker A Worker and a SharedWorker Two unrelated same-origin Window objects A Window and a cross-origin iframe Think of agent clusters like secure bubbles. If two agents are in the same bubble, they can point to the same memory. If not, even passing a reference is forbidden.\n8.2 ğŸ§  Shared Memory with SharedArrayBuffer JavaScript is traditionally copy-by-value when agents communicate. Thatâ€™s how postMessage() works: it sends a structured clone of the data.\nBut thereâ€™s one exception: SharedArrayBuffer.\nğŸ§¬ Metaphor: Normally, youâ€™re emailing someone a photocopy of your notebook. With SharedArrayBuffer, youâ€™re giving them the same notebook, and now you both can write in itâ€”simultaneously.\nğŸ”— How It Works: const sab = new SharedArrayBuffer(1024); // shared memory const view = new Int32Array(sab); // typed view worker.postMessage(sab); // no clone â€” both now point to the same memory Now both the main thread and the worker share that memory. But shared access means concurrent access, and that leads us toâ€¦\n8.3 ğŸ”’ Synchronizing with Atomics Just because memory is shared doesnâ€™t mean itâ€™s safe.\nğŸ§  Regular JS assignments like arr[0] = arr[0] + 1 are not atomic and can be torn apart when run from two agents at once.\nThatâ€™s why ECMAScript gives us Atomics: a namespace of operations that guarantee safe, lock-free memory coordination.\nğŸ›  Tools in the Atomics toolbox: Atomics.load(view, index) â€” safely read Atomics.store(view, index, value) â€” safely write Atomics.add, sub, and, or, xor, etc. â€” read-modify-write Atomics.wait(view, index, value) â€” block until value changes Atomics.notify(view, index, count) â€” wake up blocked agents // Thread 1 while (Atomics.load(view, 0) !== 1) { Atomics.wait(view, 0, 0); // wait until someone sets it to 1 } // Thread 2 Atomics.store(view, 0, 1); Atomics.notify(view, 0); This pattern enables thread-style coordination between agents â€” like building your own semaphores or locks.\nâš ï¸ Only dedicated or shared workers can be blocked using Atomics.wait(). Windows and service workers are never allowed to block.\n8.4 ğŸ“ Memory Consistency and Data Races JavaScriptâ€™s memory model ensures predictable behavior only if you follow certain rules.\nâœ… Data raceâ€“free = safe, consistent, sequential semantics\nâŒ Data races = torn values, weird bugs, and undefined behavior\nâš ï¸ Whatâ€™s a Data Race? When two agents access the same memory location at the same time, and at least one of them writes, without proper synchronization.\nğŸ§ª Example of value tearing: // One agent writes a 32-bit int arr[0] = 0x12345678; // Another agent reads only the first 16 bits mid-write Result? You read a garbage value like 0x12340000. Thatâ€™s value tearing.\nğŸ”’ Rule of Thumb: Always access shared memory via Atomics. Use the same access size and typed array across all agents. Avoid mixing atomic and non-atomic operations on the same memory cell. ğŸ§  Why This Matters Shared memory gives us high-performance parallelism in JavaScript â€” without blocking the main thread.\nBut it comes with the responsibility of:\nDefining clear communication patterns Designing for race-freedom Understanding that postMessage() â‰  shared memory unless you use SharedArrayBuffer Avoiding subtle bugs from cross-agent memory inconsistencies ğŸ“¦ In Summary Concept Description Agent Cluster Group of JS agents that can share memory SharedArrayBuffer Enables memory sharing between agents Atomics Enables safe, lock-free communication on shared memory Data Race When agents read/write same memory without sync Sequential Consistency All agents see memory changes in the same order if no races ğŸ’­ Final Thought The introduction of shared memory and Atomics fundamentally changes what JavaScript is capable of â€” enabling parallel algorithms, real-time audio processing, and high-throughput computation. But it also demands a new level of rigor. Just as Promise taught us to think about time, SharedArrayBuffer and Atomics teach us to think about space â€” and how multiple minds can share the same thoughts without stepping on each otherâ€™s toes.\nWelcome to the world of concurrent JavaScript â€” where your variables can now live in more than one mind at once.\n9. ğŸš§ Cluster Lifecycle \u0026 Blocking Modern JavaScript engines have evolved into distributed runtimes. And yet, most developers still think in terms of â€œsingle-threaded async codeâ€. But under the hood, agents, clusters, and shared memory enable fine-grained concurrency.\nThis section explores what really happens when JS environments start talking â€” and blocking â€” across boundaries.\n9.1. ğŸ§± Blocking APIs (Atomics.wait) ğŸ§  What does â€œblockingâ€ actually mean in JavaScript? Weâ€™re used to await yielding control â€” letting the event loop breathe. But Atomics.wait()? Thatâ€™s a different beast.\nAtomics.wait(int32Array, 0, 0); // ğŸ’¥ BLOCKS the agent This is not like Promises. It completely freezes the thread.\nâœ… Promise = async yield Returns control to the event loop Lets other jobs run while waiting âŒ Atomics.wait = sync block Halts everything in that agent (no event loop progress) Nothing else in that thread runs until another agent calls Atomics.notify ğŸ§¬ Mental Model:\nA waiter (Promise) steps aside while the kitchen runs. A locked door (Atomics.wait) freezes the kitchen until someone unlocks it.\n9.2. ğŸ›¡ Forward Progress Guarantees Concurrency is dangerous â€” race conditions, deadlocks, and starvation are real risks.\nThatâ€™s why ECMAScript enforces forward progress guarantees, even in multi-agent systems.\nIf multiple agents share the same thread, the runtime must ensure no agent starves forever.\nğŸ’¡ Fairness by design: The engine cannot ignore one agent just because another is busy. Even if two agents are blocking each other via Atomics, the spec mandates that some agent makes progress. ğŸ“¦ Why this matters: Imagine two workers sharing memory. If worker A holds a lock and gets suspended forever, and worker B is waiting to acquire it â€” youâ€™ve just created a distributed deadlock.\nThe JavaScript memory model prevents that scenario by ensuring all agents in a cluster eventually get time to run.\nğŸ§  Intuition: Even in tight concurrency loops, JavaScript wonâ€™t let one agent monopolize the thread indefinitely.\n9.3. ğŸ’¥ Agent Termination: The Cluster Is a Single Failure Domain Terminate one agent in a cluster, and you kill them all.\nThis is one of the lesser-known â€” but crucial â€” constraints of agent clusters.\nâœ… If agents share memory, theyâ€™re in the same cluster. ğŸ”¥ If one crashes, they all go down. Why?\nBecause allowing a shared-memory cluster to continue operating with a missing participant would:\nRisk memory corruption Break lock semantics Violate deterministic state models ğŸ§¬ System-level analogy: Imagine a nuclear power grid with interdependent control units. If one node goes offline during a write, the entire system must halt to avoid undefined behavior.\nğŸ§ª What about fault-tolerance? Interestingly, the ECMAScript spec mentions a second strategy: detect a terminated agent and let others recover.\nBut:\nğŸ”’ Itâ€™s not implemented in any browser ğŸ›  Still a theoretical model â€” not production-grade yet âš ï¸ Takeaways for System Builders If youâ€™re using SharedArrayBuffer, Atomics, or any worker model with shared memory:\nâœ… Understand agent clusters: memory sharing defines membership ğŸ§  Donâ€™t rely on postMessage for real concurrency â€” use SAB + Atomics intentionally ğŸ›‘ Avoid assuming you can recover from crashes inside a cluster â€” you canâ€™t (yet) ğŸ§µ Be aware of blocking: Promises = cooperative, Atomics = hard locks ğŸ“Œ Final Thought:\nShared memory brings power â€” and responsibility. Youâ€™re no longer in JavaScriptâ€™s comfy async sandbox. Youâ€™re in systems-land now â€” where deadlocks, race conditions, and cluster-wide failure are real threats.\nUse the power. Know the cost.\nğŸ”— 10. Putting It All Together ğŸ¯ Why this section matters: Everything weâ€™ve explored â€” stacks, heaps, queues, jobs, realms, agents, workers, shared memory â€” now comes together into a unified execution trace. This is where theory meets runtime. This is where your intuition levels up.\n10.1 âš™ï¸ Full Execution Trace Letâ€™s simulate a complete run of a JavaScript program involving:\nğŸ§  Synchronous execution (stack) â° setTimeout (macro-task queue) ğŸ’¬ Promise (microtask queue) ğŸ” Nested function calls ğŸ”„ Event loop orchestration ğŸ’» Code Example: console.log(\"Start\"); setTimeout(() =\u003e { console.log(\"Timeout 1\"); }, 0); Promise.resolve().then(() =\u003e { console.log(\"Promise 1\"); }); console.log(\"End\"); ğŸ” Execution Timeline Step Stack Microtask Queue Task Queue Output 1 global() 2 log(â€œStartâ€) Start 3 setTimeout(â€¦) [Timeout callback] 4 Promise.then(â€¦) [Promise callback] [Timeout callback] 5 log(â€œEndâ€) [Promise callback] [Timeout callback] End 6 Execute microtask [] [Timeout callback] Promise 1 7 Execute macro task [] [] Timeout 1 ğŸ§  Metaphor: Call stack is your desk â€” only one function open at a time. Microtasks are sticky notes stuck to the monitor â€” you handle them after the current task, but before picking a new one from the task queue. Macro-tasks (setTimeout) are tasks waiting in your inbox â€” they only get attention after all microtasks are done. ğŸ”— Connections Stack: Tracks what code is currently running. Heap: Stores Promise, callback functions. Job Queue: Schedules promise callbacks (microtasks). Task Queue: Schedules setTimeout, events (macro-tasks). Event Loop: Pulls from microtask â†’ then macro â†’ repeat. ğŸ§¬ Subtle Gotchas Promise.then always runs before setTimeout, even if setTimeout has 0ms delay. This is because microtask queue is prioritized over macro-task queue. 10.2 ğŸ§  Mental Models \u0026 Visuals ğŸ“Š Timeline Diagram Time â†’ | Stack: log(\"Start\") â†’ log(\"End\") â†’ [Empty] | Microtask: â†’ Promise.then() â†’ [Empty] | Task: setTimeout() â†’ â†’ setTimeout() Output: Start End Promise 1 Timeout 1 ğŸ§© Stackâ€“Heapâ€“Queue Visualization â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ Call Stack â”‚ â† Runs synchronous code (one frame at a time) â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ Global Execution â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ Heap â”‚ â† Stores objects, closures, promises â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ Promise, callbacksâ€¦ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ Microtask Q â”‚ â† Promise callbacks (then, catch) â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ () =\u003e console.logâ€¦ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ Task Queue â”‚ â† Timers, UI events â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ setTimeout cbâ€¦ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ ğŸ§­ Cross-Realm \u0026 Agent Flowchart [ Window (Agent A) ] â”‚ â”œâ”€ setTimeout() â†’ Task Queue â”œâ”€ Promise.then() â†’ Microtask Queue â”œâ”€ Web Worker (Agent B) â”‚ â”œâ”€ Own Heap â”‚ â”œâ”€ Own Stack â”‚ â””â”€ Communicates via postMessage or SharedArrayBuffer â”‚ â””â”€ iframe (Realm B, same agent) â”œâ”€ Own GlobalThis â””â”€ Shared Stack/Queue (if same-origin) ğŸ¯ Interview Insight If you truly understand this unified flow, you can:\nPredict async code output reliably. Avoid callback hell and race conditions. Understand Node.js concurrency patterns. Handle shared memory in web workers safely. âœ… Final Thought JavaScript isnâ€™t just â€œsingle-threaded.â€\nItâ€™s a coordinated choreography of:\nAgents (runners) Realms (universes) Heaps (long-term memory) Stacks (call trace) Queues (scheduling) Event loop (the director) Master this mental model, and youâ€™re not just writing JS â€” youâ€™re orchestrating time.\n","wordCount":"6914","inLanguage":"en","image":"https://archit15singh.github.io/images/uploads/cosmic-timetraveler.webp","datePublished":"2022-07-29T12:00:00Z","dateModified":"2022-07-29T12:00:00Z","author":{"@type":"Person","name":"Archit Singh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://archit15singh.github.io/posts/2022-07-29-js-execution-model-in-depth/"},"publisher":{"@type":"Organization","name":"Archit's Space","logo":{"@type":"ImageObject","url":"https://archit15singh.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://archit15singh.github.io/ accesskey=h title="Archit's Space (Alt + H)">Archit's Space</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://archit15singh.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://archit15singh.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://archit15singh.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://archit15singh.github.io/>Home</a>&nbsp;Â»&nbsp;<a href=https://archit15singh.github.io/posts/>Posts</a></div><h1 class=post-title>How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive)</h1><div class=post-description>Explore how JavaScript code actually runs: from the engine and host environment to call stacks, queues, realms, agents, and async behavior â€” explained with mental models, real code, and execution traces.</div><div class=post-meta><span title="2022-07-29 12:00:00 +0000 UTC">July 29, 2022</span>&nbsp;Â·&nbsp;33 min</div></header><figure class=entry-cover><img loading=lazy src=https://archit15singh.github.io/images/uploads/cosmic-timetraveler.webp alt="JS deep dive"><p>JS deep dive</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#how-javascript-really-runs-from-engines-to-event-loop-execution-model-deep-dive aria-label="How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive)">How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive)</a><ul><li><a href=#-what-this-series-will-teach-you aria-label="ğŸš€ What This Series Will Teach You">ğŸš€ What This Series Will Teach You</a></li><li><a href=#1--introduction-what-is-the-javascript-execution-model aria-label="1. ğŸ¯ Introduction: What is the JavaScript Execution Model?">1. ğŸ¯ Introduction: What is the JavaScript Execution Model?</a><ul><li><a href=#-so-what-is-it aria-label="ğŸ§  Soâ€¦ what is it?">ğŸ§  Soâ€¦ what <em>is</em> it?</a></li></ul></li><li><a href=#-why-should-developers-care aria-label="ğŸ§© Why should developers care?">ğŸ§© Why should developers care?</a></li><li><a href=#-spec-vs-reality-goals-of-the-execution-model aria-label="ğŸ†š Spec vs Reality: Goals of the Execution Model">ğŸ†š Spec vs Reality: Goals of the Execution Model</a></li><li><a href=#-real-world-metaphor-actor-stage-script aria-label="ğŸ­ Real-World Metaphor: Actor, Stage, Script">ğŸ­ Real-World Metaphor: Actor, Stage, Script</a></li><li><a href=#-2-core-architecture-of-javascript-runtime aria-label="ğŸ§© 2. Core Architecture of JavaScript Runtime">ğŸ§© 2. <strong>Core Architecture of JavaScript Runtime</strong></a><ul><li><a href=#-21-the-javascript-engine aria-label="ğŸ”¹ 2.1. The JavaScript Engine">ğŸ”¹ 2.1. <strong>The JavaScript Engine</strong></a><ul><li><a href=#-literal-meaning aria-label="âœ… Literal meaning:">âœ… Literal meaning:</a></li><li><a href=#-what-it-provides aria-label="ğŸ§  What it provides:">ğŸ§  What it provides:</a></li><li><a href=#-examples-of-engines aria-label="ğŸ›  Examples of engines:">ğŸ›  Examples of engines:</a></li><li><a href=#-mental-model aria-label="ğŸ§¬ Mental model:">ğŸ§¬ Mental model:</a></li></ul></li><li><a href=#-22-the-host-environment aria-label="ğŸ”¹ 2.2. The Host Environment">ğŸ”¹ 2.2. <strong>The Host Environment</strong></a><ul><li><a href=#-literal-meaning-1 aria-label="âœ… Literal meaning:">âœ… Literal meaning:</a></li><li><a href=#-common-host-environments aria-label="ğŸŒ Common host environments:">ğŸŒ Common host environments:</a></li><li><a href=#-host-provided-apis aria-label="ğŸ›  Host-provided APIs:">ğŸ›  Host-provided APIs:</a></li><li><a href=#-example aria-label="ğŸ’» Example:">ğŸ’» Example:</a></li><li><a href=#-real-world-analogy aria-label="ğŸ§¬ Real-world analogy:">ğŸ§¬ Real-world analogy:</a></li></ul></li><li><a href=#-23-engine-vs-host-division-of-concerns aria-label="ğŸ”¹ 2.3. Engine vs Host: Division of Concerns">ğŸ”¹ 2.3. <strong>Engine vs Host: Division of Concerns</strong></a><ul><li><a href=#-literal-meaning-2 aria-label="âœ… Literal meaning:">âœ… Literal meaning:</a></li><li><a href=#-why-this-matters aria-label="ğŸ§  Why this matters:">ğŸ§  Why this matters:</a></li><li><a href=#-code-comparison aria-label="ğŸ§ª Code Comparison:">ğŸ§ª Code Comparison:</a></li><li><a href=#-gotcha-why-does-js-code-fail-in-node-but-not-in-the-browser aria-label="âš ï¸ Gotcha: â€œWhy does JS code fail in Node but not in the browser?â€">âš ï¸ Gotcha: â€œWhy does JS code fail in Node but not in the browser?â€</a></li><li><a href=#-related-concept-polyfills-and-environment-detection aria-label="ğŸ”— Related Concept: Polyfills and Environment Detection">ğŸ”— Related Concept: <strong>Polyfills and Environment Detection</strong></a></li></ul></li><li><a href=#-tldr-mental-model aria-label="ğŸ§  TL;DR Mental Model">ğŸ§  TL;DR Mental Model</a></li><li><a href=#-summary-table aria-label="ğŸ§© Summary Table">ğŸ§© Summary Table</a></li></ul></li><li><a href=#3--agent-execution-model--the-secret-engine-behind-javascripts-run-time aria-label="3. ğŸ§  Agent Execution Model â€” The Secret Engine Behind JavaScriptâ€™s Run-Time">3. ğŸ§  Agent Execution Model â€” The Secret Engine Behind JavaScriptâ€™s Run-Time</a></li><li><a href=#31--what-is-an-agent aria-label="3.1 ğŸš€ What is an Agent?">3.1 ğŸš€ What is an Agent?</a><ul><li><a href=#-think-of-an-agent-as aria-label="ğŸ§  Think of an agent as:">ğŸ§  Think of an agent as:</a></li><li><a href=#-metaphor aria-label="ğŸ”¬ Metaphor:">ğŸ”¬ Metaphor:</a></li></ul></li><li><a href=#32--agent-data-structures-the-triad aria-label="3.2 âš™ï¸ Agent Data Structures: The Triad">3.2 âš™ï¸ Agent Data Structures: The Triad</a><ul><li><a href=#-1-heap aria-label="ğŸ§  1. Heap">ğŸ§  1. <strong>Heap</strong></a></li><li><a href=#-2-call-stack aria-label="ğŸ§  2. Call Stack">ğŸ§  2. <strong>Call Stack</strong></a></li><li><a href=#-3-jobtask-queue aria-label="ğŸ§  3. Job/Task Queue">ğŸ§  3. <strong>Job/Task Queue</strong></a></li><li><a href=#-all-together aria-label="ğŸ”¬ All Together:">ğŸ”¬ All Together:</a></li></ul></li><li><a href=#33--agent-lifecycle--how-code-actually-runs aria-label="3.3 â³ Agent Lifecycle â€” How Code Actually Runs">3.3 â³ Agent Lifecycle â€” How Code <em>Actually</em> Runs</a><ul><li><a href=#-step-1-a-job-begins aria-label="ğŸ”„ Step 1: A Job Begins">ğŸ”„ Step 1: A Job Begins</a></li><li><a href=#-step-2-stack-fills-up aria-label="ğŸ“ˆ Step 2: Stack Fills Up">ğŸ“ˆ Step 2: Stack Fills Up</a></li><li><a href=#-step-3-stack-empties aria-label="ğŸ“‰ Step 3: Stack Empties">ğŸ“‰ Step 3: Stack Empties</a></li><li><a href=#-step-4-idle-or-re-entry aria-label="ğŸ’¤ Step 4: Idle or Re-entry">ğŸ’¤ Step 4: Idle or Re-entry</a></li><li><a href=#-why-it-matters aria-label="ğŸ§  Why It Matters">ğŸ§  Why It Matters</a></li></ul></li><li><a href=#-bonus-multi-agent-systems aria-label="ğŸ’¡ Bonus: Multi-Agent Systems">ğŸ’¡ Bonus: Multi-Agent Systems</a></li><li><a href=#-recap-agent-model-mental-picture aria-label="âœ… Recap: Agent Model Mental Picture">âœ… Recap: Agent Model Mental Picture</a></li><li><a href=#-real-world-debugging-tip aria-label="âœ¨ Real-World Debugging Tip">âœ¨ Real-World Debugging Tip</a></li><li><a href=#4--execution-contexts--call-stack aria-label="4. ğŸ“¦ Execution Contexts & Call Stack">4. ğŸ“¦ <strong>Execution Contexts & Call Stack</strong></a><ul><li><a href=#41--what-is-an-execution-context aria-label="4.1. ğŸ§  What is an Execution Context?">4.1. ğŸ§  <strong>What is an Execution Context?</strong></a><ul><li><a href=#-it-contains aria-label="ğŸ” It contains:">ğŸ” It contains:</a></li><li><a href=#-mental-model-1 aria-label="ğŸ§¬ Mental Model:">ğŸ§¬ Mental Model:</a></li><li><a href=#-example-1 aria-label="ğŸ’» Example:">ğŸ’» Example:</a></li></ul></li><li><a href=#-lexical-environment aria-label="ğŸ§© Lexical Environment">ğŸ§© Lexical Environment</a><ul><li><a href=#-closures aria-label="ğŸ” Closures:">ğŸ” Closures:</a></li></ul></li><li><a href=#-realm-association aria-label="ğŸŒ Realm Association">ğŸŒ Realm Association</a><ul><li><a href=#-gotcha aria-label="âš ï¸ Gotcha:">âš ï¸ Gotcha:</a></li></ul></li><li><a href=#-this-arguments-and-bindings aria-label="âš™ï¸ this, arguments, and Bindings">âš™ï¸ <code>this</code>, <code>arguments</code>, and Bindings</a></li><li><a href=#42--function-invocation--stack-frames aria-label="4.2. ğŸ” Function Invocation & Stack Frames">4.2. ğŸ” <strong>Function Invocation & Stack Frames</strong></a><ul><li><a href=#-when-the-function-finishes aria-label="ğŸ“¤ When the function finishes:">ğŸ“¤ When the function finishes:</a></li><li><a href=#-code-trace aria-label="ğŸ’» Code Trace:">ğŸ’» Code Trace:</a></li><li><a href=#-key-behaviors aria-label="ğŸ¯ Key behaviors:">ğŸ¯ Key behaviors:</a></li></ul></li><li><a href=#-43-tail-call-optimization-tco aria-label="âš¡ 4.3. Tail Call Optimization (TCO)">âš¡ 4.3. <strong>Tail Call Optimization (TCO)</strong></a><ul><li><a href=#-benefits aria-label="ğŸ¯ Benefits:">ğŸ¯ Benefits:</a></li><li><a href=#-example-ideal-for-tco aria-label="ğŸ”¥ Example (ideal for TCO):">ğŸ”¥ Example (ideal for TCO):</a></li><li><a href=#-engine-support-caveats aria-label="âš ï¸ Engine Support Caveats:">âš ï¸ Engine Support Caveats:</a></li></ul></li><li><a href=#-summary-table-1 aria-label="ğŸ§  Summary Table">ğŸ§  Summary Table</a></li></ul></li><li><a href=#5--understanding-realms-the-hidden-worlds-of-javascript-execution aria-label="5. ğŸŒ€ Understanding Realms: The Hidden Worlds of JavaScript Execution">5. ğŸŒ€ Understanding Realms: The Hidden Worlds of JavaScript Execution</a></li><li><a href=#-what-is-a-realm aria-label="ğŸ“¦ What Is a Realm?">ğŸ“¦ What Is a Realm?</a><ul><li><a href=#-mental-model-2 aria-label="ğŸ§  Mental Model:">ğŸ§  Mental Model:</a></li><li><a href=#-real-world-examples aria-label="ğŸ’¡ Real-World Examples:">ğŸ’¡ Real-World Examples:</a></li></ul></li><li><a href=#-realm-internals aria-label="ğŸ”¬ Realm Internals">ğŸ”¬ Realm Internals</a><ul><li><a href=#1--intrinsic-objects aria-label="1. ğŸ§¬ Intrinsic Objects">1. ğŸ§¬ Intrinsic Objects</a></li><li><a href=#-gotcha-instanceof-fails-across-realms aria-label="âš ï¸ Gotcha: instanceof fails across realms">âš ï¸ Gotcha: <code>instanceof</code> fails across realms</a></li><li><a href=#2--global-object-and-globalthis aria-label="2. ğŸª Global Object and globalThis">2. ğŸª Global Object and <code>globalThis</code></a></li><li><a href=#3--template-literal-cache aria-label="3. ğŸ§  Template Literal Cache">3. ğŸ§  Template Literal Cache</a></li></ul></li><li><a href=#-realms-vs-agents aria-label="ğŸ§© Realms vs Agents">ğŸ§© Realms vs Agents</a><ul><li><a href=#-realms-can-talk-if-in-same-agent aria-label="ğŸ” Realms Can Talk (if in same agent)">ğŸ” Realms Can Talk (if in same agent)</a></li></ul></li><li><a href=#-why-realms-matter-in-the-real-world aria-label="ğŸ” Why Realms Matter in the Real World">ğŸ” Why Realms Matter in the Real World</a><ul><li><a href=#1-security-and-isolation aria-label="1. Security and Isolation">1. <strong>Security and Isolation</strong></a></li><li><a href=#2-framework--testing-tooling aria-label="2. Framework & Testing Tooling">2. <strong>Framework & Testing Tooling</strong></a></li><li><a href=#3-micro-frontend-architecture aria-label="3. Micro-frontend Architecture">3. <strong>Micro-frontend Architecture</strong></a></li><li><a href=#4-cross-realm-bugs aria-label="4. Cross-Realm Bugs">4. <strong>Cross-Realm Bugs</strong></a></li></ul></li><li><a href=#-takeaways aria-label="ğŸ§  Takeaways">ğŸ§  Takeaways</a></li><li><a href=#-bonus-shadowrealm-tc39-stage-3 aria-label="ğŸ“Œ Bonus: ShadowRealm (TC39 Stage 3)">ğŸ“Œ Bonus: ShadowRealm (TC39 Stage 3)</a></li><li><a href=#-final-word aria-label="âœï¸ Final Word">âœï¸ Final Word</a></li><li><a href=#6--agent-types-in-the-web-platform aria-label="6. ğŸŒ Agent Types in the Web Platform">6. ğŸŒ <strong>Agent Types in the Web Platform</strong></a><ul><li><a href=#61-main-window-agent aria-label="6.1. Main Window Agent">6.1. Main Window Agent</a></li><li><a href=#62-dedicated-worker-agent aria-label="6.2. Dedicated Worker Agent">6.2. Dedicated Worker Agent</a></li><li><a href=#63-shared-worker-agent aria-label="6.3. Shared Worker Agent">6.3. Shared Worker Agent</a></li><li><a href=#64-service-worker-agent aria-label="6.4. Service Worker Agent">6.4. Service Worker Agent</a></li><li><a href=#65-worklet-agent aria-label="6.5. Worklet Agent">6.5. Worklet Agent</a></li></ul></li><li><a href=#6--agent-types-in-the-web-platform-1 aria-label="6. ğŸŒ Agent Types in the Web Platform">6. ğŸŒ <strong>Agent Types in the Web Platform</strong></a><ul><li><a href=#61--main-window-agent aria-label="6.1 ğŸªŸ Main Window Agent">6.1 ğŸªŸ <strong>Main Window Agent</strong></a></li><li><a href=#62--dedicated-worker-agent aria-label="6.2 ğŸ‘· Dedicated Worker Agent">6.2 ğŸ‘· <strong>Dedicated Worker Agent</strong></a></li><li><a href=#63--shared-worker-agent aria-label="6.3 ğŸ¤ Shared Worker Agent">6.3 ğŸ¤ <strong>Shared Worker Agent</strong></a></li><li><a href=#64--service-worker-agent aria-label="6.4 ğŸ›° Service Worker Agent">6.4 ğŸ›° <strong>Service Worker Agent</strong></a></li><li><a href=#65--worklet-agent aria-label="6.5 ğŸ¨ Worklet Agent">6.5 ğŸ¨ <strong>Worklet Agent</strong></a></li><li><a href=#-all-agent-types-have aria-label="ğŸ§¬ All Agent Types Have:">ğŸ§¬ All Agent Types Have:</a></li><li><a href=#-summary-table-2 aria-label="ğŸ§  Summary Table">ğŸ§  Summary Table</a></li><li><a href=#-related-concepts aria-label="ğŸ”— Related Concepts:">ğŸ”— Related Concepts:</a></li></ul></li><li><a href=#7--job-queue--event-loop aria-label="7. ğŸ” Job Queue & Event Loop">7. ğŸ” <strong>Job Queue & Event Loop</strong></a><ul><li><a href=#71--what-is-a-job aria-label="7.1 ğŸ”§ What is a Job?">7.1 ğŸ”§ What is a Job?</a></li><li><a href=#72--event-loop-the-scheduler-in-chief aria-label="7.2 ğŸ”„ Event Loop: The Scheduler-in-Chief">7.2 ğŸ”„ Event Loop: The Scheduler-in-Chief</a></li><li><a href=#73--microtasks-vs-macrotasks aria-label="7.3 âš–ï¸ Microtasks vs Macrotasks">7.3 âš–ï¸ Microtasks vs Macrotasks</a></li><li><a href=#74--blocking-vs-non-blocking aria-label="7.4 ğŸ§µ Blocking vs Non-Blocking">7.4 ğŸ§µ Blocking vs Non-Blocking</a></li><li><a href=#-final-mental-model aria-label="ğŸ’¡ Final Mental Model">ğŸ’¡ Final Mental Model</a></li></ul></li><li><a href=#8--concurrency--memory-sharing aria-label="8. ğŸ§  Concurrency & Memory Sharing">8. ğŸ§  <strong>Concurrency & Memory Sharing</strong></a><ul><li><a href=#81--agent-clusters-who-can-share-memory-with-whom aria-label="8.1 âš¡ Agent Clusters: Who Can Share Memory with Whom?">8.1 âš¡ <strong>Agent Clusters: Who Can Share Memory with Whom?</strong></a><ul><li><a href=#-in-the-same-cluster-can-share-memory aria-label="âœ… In the Same Cluster (can share memory):">âœ… In the Same Cluster (can share memory):</a></li><li><a href=#-different-clusters-cant-share-memory aria-label="âŒ Different Clusters (canâ€™t share memory):">âŒ Different Clusters (canâ€™t share memory):</a></li></ul></li><li><a href=#82--shared-memory-with-sharedarraybuffer aria-label="8.2 ğŸ§  Shared Memory with SharedArrayBuffer">8.2 ğŸ§  <strong>Shared Memory with SharedArrayBuffer</strong></a><ul><li><a href=#-how-it-works aria-label="ğŸ”— How It Works:">ğŸ”— How It Works:</a></li></ul></li><li><a href=#83--synchronizing-with-atomics aria-label="8.3 ğŸ”’ Synchronizing with Atomics">8.3 ğŸ”’ <strong>Synchronizing with Atomics</strong></a><ul><li><a href=#-tools-in-the-atomics-toolbox aria-label="ğŸ›  Tools in the Atomics toolbox:">ğŸ›  Tools in the <code>Atomics</code> toolbox:</a></li></ul></li><li><a href=#84--memory-consistency-and-data-races aria-label="8.4 ğŸ“ Memory Consistency and Data Races">8.4 ğŸ“ <strong>Memory Consistency and Data Races</strong></a><ul><li><a href=#-whats-a-data-race aria-label="âš ï¸ Whatâ€™s a Data Race?">âš ï¸ Whatâ€™s a Data Race?</a></li><li><a href=#-example-of-value-tearing aria-label="ğŸ§ª Example of value tearing:">ğŸ§ª Example of value tearing:</a></li><li><a href=#-rule-of-thumb aria-label="ğŸ”’ Rule of Thumb:">ğŸ”’ Rule of Thumb:</a></li></ul></li><li><a href=#-why-this-matters-1 aria-label="ğŸ§  Why This Matters">ğŸ§  Why This Matters</a></li><li><a href=#-in-summary aria-label="ğŸ“¦ In Summary">ğŸ“¦ In Summary</a></li><li><a href=#-final-thought aria-label="ğŸ’­ Final Thought">ğŸ’­ Final Thought</a></li></ul></li><li><a href=#9--cluster-lifecycle--blocking aria-label="9. ğŸš§ Cluster Lifecycle & Blocking">9. ğŸš§ Cluster Lifecycle & Blocking</a><ul><li><a href=#91--blocking-apis-atomicswait aria-label="9.1. ğŸ§± Blocking APIs (Atomics.wait)">9.1. ğŸ§± Blocking APIs (<code>Atomics.wait</code>)</a><ul><li><a href=#-what-does-blocking-actually-mean-in-javascript aria-label="ğŸ§  What does &ldquo;blocking&rdquo; actually mean in JavaScript?">ğŸ§  What does &ldquo;blocking&rdquo; <em>actually</em> mean in JavaScript?</a></li><li><a href=#-promise--async-yield aria-label="âœ… Promise = async yield">âœ… Promise = async yield</a></li><li><a href=#-atomicswait--sync-block aria-label="âŒ Atomics.wait = sync block">âŒ Atomics.wait = sync block</a></li></ul></li><li><a href=#92--forward-progress-guarantees aria-label="9.2. ğŸ›¡ Forward Progress Guarantees">9.2. ğŸ›¡ Forward Progress Guarantees</a><ul><li><a href=#-fairness-by-design aria-label="ğŸ’¡ Fairness by design:">ğŸ’¡ Fairness by design:</a></li><li><a href=#-why-this-matters-2 aria-label="ğŸ“¦ Why this matters:">ğŸ“¦ Why this matters:</a></li></ul></li><li><a href=#93--agent-termination-the-cluster-is-a-single-failure-domain aria-label="9.3. ğŸ’¥ Agent Termination: The Cluster Is a Single Failure Domain">9.3. ğŸ’¥ Agent Termination: The Cluster Is a Single Failure Domain</a><ul><li><a href=#-if-agents-share-memory-theyre-in-the-same-cluster aria-label="âœ… If agents share memory, theyâ€™re in the same cluster.">âœ… If agents share memory, theyâ€™re in the same cluster.</a></li><li><a href=#-if-one-crashes-they-all-go-down aria-label="ğŸ”¥ If one crashes, they all go down.">ğŸ”¥ If one crashes, they <em>all</em> go down.</a></li><li><a href=#-what-about-fault-tolerance aria-label="ğŸ§ª What about fault-tolerance?">ğŸ§ª What about fault-tolerance?</a></li></ul></li></ul></li><li><a href=#-takeaways-for-system-builders aria-label="âš ï¸ Takeaways for System Builders">âš ï¸ Takeaways for System Builders</a></li><li><a href=#-10-putting-it-all-together aria-label="ğŸ”— 10. Putting It All Together">ğŸ”— 10. <strong>Putting It All Together</strong></a><ul><li><a href=#-why-this-section-matters aria-label="ğŸ¯ Why this section matters:">ğŸ¯ Why this section matters:</a></li><li><a href=#101--full-execution-trace aria-label="10.1 âš™ï¸ Full Execution Trace">10.1 âš™ï¸ <strong>Full Execution Trace</strong></a><ul><li><a href=#-code-example aria-label="ğŸ’» Code Example:">ğŸ’» Code Example:</a></li></ul></li><li><a href=#-execution-timeline aria-label="ğŸ” Execution Timeline">ğŸ” Execution Timeline</a></li><li><a href=#-metaphor-1 aria-label="ğŸ§  Metaphor:">ğŸ§  Metaphor:</a></li><li><a href=#-connections aria-label="ğŸ”— Connections">ğŸ”— Connections</a></li><li><a href=#-subtle-gotchas aria-label="ğŸ§¬ Subtle Gotchas">ğŸ§¬ Subtle Gotchas</a></li><li><a href=#102--mental-models--visuals aria-label="10.2 ğŸ§  Mental Models & Visuals">10.2 ğŸ§  <strong>Mental Models & Visuals</strong></a></li><li><a href=#-timeline-diagram aria-label="ğŸ“Š Timeline Diagram">ğŸ“Š Timeline Diagram</a></li><li><a href=#-stackheapqueue-visualization aria-label="ğŸ§© Stackâ€“Heapâ€“Queue Visualization">ğŸ§© Stackâ€“Heapâ€“Queue Visualization</a></li><li><a href=#-cross-realm--agent-flowchart aria-label="ğŸ§­ Cross-Realm & Agent Flowchart">ğŸ§­ Cross-Realm & Agent Flowchart</a></li><li><a href=#-interview-insight aria-label="ğŸ¯ Interview Insight">ğŸ¯ Interview Insight</a></li></ul></li><li><a href=#-final-thought-1 aria-label="âœ… Final Thought">âœ… Final Thought</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=how-javascript-really-runs-from-engines-to-event-loop-execution-model-deep-dive>How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive)<a hidden class=anchor aria-hidden=true href=#how-javascript-really-runs-from-engines-to-event-loop-execution-model-deep-dive>#</a></h1><hr><h2 id=-what-this-series-will-teach-you>ğŸš€ What This Series Will Teach You<a hidden class=anchor aria-hidden=true href=#-what-this-series-will-teach-you>#</a></h2><p>This blog post is the first step of a <strong>multi-part deep dive</strong> into the JS execution model. Youâ€™ll learn:</p><ul><li>How JavaScript handles synchronous and asynchronous code</li><li>What the call stack, job queue, microtasks, and event loop really are</li><li>How realms, agents, and execution contexts work together</li><li>How engines like V8 optimize while staying spec-compliant</li><li>Why seemingly simple code can behave unexpectedly â€” and how to reason through it</li></ul><p>Each section will build your mental model â€” with visuals, real code traces, intuitive metaphors, and runtime behavior breakdowns.</p><blockquote><p>ğŸ“Œ Whether you&rsquo;re building a single-page app, debugging race conditions, or writing high-performance server-side JS â€” knowing <em>how JS really runs</em> is your ultimate superpower.</p></blockquote><hr><h2 id=1--introduction-what-is-the-javascript-execution-model>1. ğŸ¯ Introduction: What is the JavaScript Execution Model?<a hidden class=anchor aria-hidden=true href=#1--introduction-what-is-the-javascript-execution-model>#</a></h2><p>JavaScript might <em>look</em> simple â€” you write <code>let x = 10</code>, it runs. You call a function, it executes. But under the hood, a sophisticated system choreographs every line you write. That system is called the <strong>JavaScript execution model</strong>.</p><h3 id=-so-what-is-it>ğŸ§  Soâ€¦ what <em>is</em> it?<a hidden class=anchor aria-hidden=true href=#-so-what-is-it>#</a></h3><p>At its core, the JavaScript execution model defines <strong>how JavaScript code runs</strong>:</p><ul><li>How the engine interprets your code</li><li>How memory is allocated and freed</li><li>How functions get stacked and unstacked</li><li>How asynchronous code (like <code>setTimeout</code> or <code>fetch</code>) is managed</li><li>How multiple â€œthreadsâ€ (agents) interact â€” or donâ€™t</li></ul><p>Itâ€™s like the <strong>operating system of JavaScript</strong> â€” the abstract machine that governs how your code behaves, step-by-step.</p><hr><h2 id=-why-should-developers-care>ğŸ§© Why should developers care?<a hidden class=anchor aria-hidden=true href=#-why-should-developers-care>#</a></h2><p>You donâ€™t need to know every VM optimization trick to write JavaScriptâ€¦<br>But if you want to:</p><ul><li><strong>Fix timing bugs</strong></li><li><strong>Master Promises, async/await, and the event loop</strong></li><li><strong>Avoid race conditions and memory leaks</strong></li><li><strong>Write responsive apps that never freeze the UI</strong></li><li><strong>Debug async issues like â€œWhy does this log after that?â€</strong></li></ul><p>&mldr;then understanding the execution model isn&rsquo;t optional â€” itâ€™s essential.</p><p>Itâ€™s the foundation beneath everything from simple loops to complex front-end architectures to performance-critical backends.</p><hr><h2 id=-spec-vs-reality-goals-of-the-execution-model>ğŸ†š Spec vs Reality: Goals of the Execution Model<a hidden class=anchor aria-hidden=true href=#-spec-vs-reality-goals-of-the-execution-model>#</a></h2><p>The <strong>ECMAScript specification</strong> (the official language definition) defines the execution model in a <strong>platform-neutral</strong>, abstract way.</p><p>This spec outlines the <strong>rules all JavaScript engines must follow</strong>, regardless of environment:</p><ul><li>Browsers (Chrome/V8, Firefox/SpiderMonkey, Safari/JavaScriptCore)</li><li>Servers (Node.js, Deno)</li><li>Embedded runtimes (e.g. IoT devices)</li></ul><p>However, <strong>real engines are free to optimize</strong> â€” just like how chess players can use different tactics, but must follow the same rules.</p><p>For example:</p><ul><li>V8 (Chrome/Node.js) uses Just-In-Time (JIT) compilation, inline caching, and memory optimizations.</li><li>But it still follows the logical model the spec describes: same rules, different execution speed.</li></ul><blockquote><p>ğŸ’¡ <strong>TL;DR</strong>: The spec defines <em>what must happen</em>, not <em>how fast</em> or <em>how exactly</em> an engine does it.</p></blockquote><hr><h2 id=-real-world-metaphor-actor-stage-script>ğŸ­ Real-World Metaphor: Actor, Stage, Script<a hidden class=anchor aria-hidden=true href=#-real-world-metaphor-actor-stage-script>#</a></h2><p>Letâ€™s break it down with a metaphor:</p><ul><li><strong>Your code</strong> = the <em>script</em></li><li><strong>The JavaScript engine</strong> = the <em>actor</em></li><li><strong>The host environment (browser, Node)</strong> = the <em>stage, lighting, props, audience</em></li><li><strong>The execution model</strong> = the <em>stage manager</em> â€” orchestrating who enters when, what lines are spoken, and how long each actor gets to perform</li></ul><p>The actor (engine) canâ€™t improvise wildly â€” it must follow the script (your code) â€” but the stage manager decides when scenes start, what props are ready, and how long each act lasts.</p><p>And just like in theater: no actor can speak two lines at the same time. JavaScript, too, is single-threaded â€” one line at a time, unless you start spinning off background actors (Web Workers, Service Workers).</p><hr><h2 id=-2-core-architecture-of-javascript-runtime>ğŸ§© 2. <strong>Core Architecture of JavaScript Runtime</strong><a hidden class=anchor aria-hidden=true href=#-2-core-architecture-of-javascript-runtime>#</a></h2><p>To understand <em>how</em> JavaScript runs your code, we need to dissect <strong>what components make up the JS runtime</strong>.<br>At the core, JavaScript doesn&rsquo;t run in a vacuum â€” it needs an <strong>engine</strong> to interpret the code, and a <strong>host environment</strong> to provide real-world capabilities like networking, timers, and file access.</p><p>Letâ€™s peel this layer by layer.</p><hr><h3 id=-21-the-javascript-engine>ğŸ”¹ 2.1. <strong>The JavaScript Engine</strong><a hidden class=anchor aria-hidden=true href=#-21-the-javascript-engine>#</a></h3><h4 id=-literal-meaning>âœ… Literal meaning:<a hidden class=anchor aria-hidden=true href=#-literal-meaning>#</a></h4><p>The <strong>engine</strong> is the heart of the JavaScript runtime. It&rsquo;s the software that understands and executes ECMAScript â€” the official JavaScript language specification.</p><h4 id=-what-it-provides>ğŸ§  What it provides:<a hidden class=anchor aria-hidden=true href=#-what-it-provides>#</a></h4><ul><li><strong>Parsing</strong>: Reads and interprets JS source code (e.g., turns <code>function foo() {}</code> into a syntax tree).</li><li><strong>Execution</strong>: Runs your code step-by-step, managing memory, stack, scopes, etc.</li><li><strong>Optimization</strong>: Applies techniques like JIT (Just-In-Time) compilation, inline caching, dead code elimination for speed.</li></ul><h4 id=-examples-of-engines>ğŸ›  Examples of engines:<a hidden class=anchor aria-hidden=true href=#-examples-of-engines>#</a></h4><ul><li><strong>V8</strong> (Chrome, Node.js)</li><li><strong>SpiderMonkey</strong> (Firefox)</li><li><strong>JavaScriptCore</strong> (Safari)</li><li><strong>Chakra</strong> (deprecated, formerly in Edge)</li></ul><h4 id=-mental-model>ğŸ§¬ Mental model:<a hidden class=anchor aria-hidden=true href=#-mental-model>#</a></h4><p>Think of the engine like a <strong>brain</strong> that knows how to read JavaScript, understand it, and run it â€” but itâ€™s stuck in a box. It can&rsquo;t talk to the outside world unless someone wires it up.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// This is purely engine territory:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>x</span> <span class=o>=</span> <span class=mi>5</span> <span class=o>+</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>doubled</span> <span class=o>=</span> <span class=nx>x</span> <span class=o>*</span> <span class=mi>2</span><span class=p>;</span>
</span></span></code></pre></div><p>No DOM. No timers. No file I/O. Just language-level stuff.</p><hr><h3 id=-22-the-host-environment>ğŸ”¹ 2.2. <strong>The Host Environment</strong><a hidden class=anchor aria-hidden=true href=#-22-the-host-environment>#</a></h3><h4 id=-literal-meaning-1>âœ… Literal meaning:<a hidden class=anchor aria-hidden=true href=#-literal-meaning-1>#</a></h4><p>This is the <strong>external system</strong> embedding the JS engine.<br>It provides <strong>platform-specific APIs</strong> and functionalities that the engine alone cannot offer.</p><h4 id=-common-host-environments>ğŸŒ Common host environments:<a hidden class=anchor aria-hidden=true href=#-common-host-environments>#</a></h4><ul><li><strong>Web browsers</strong>: Chrome, Firefox, Safari</li><li><strong>Node.js</strong>: Server-side JS runtime</li><li><strong>Deno</strong>: Secure, modern runtime for JS/TS</li><li><strong>React Native</strong>: JS inside mobile apps</li><li><strong>Adobe After Effects</strong>: JS for scripting animation!</li></ul><h4 id=-host-provided-apis>ğŸ›  Host-provided APIs:<a hidden class=anchor aria-hidden=true href=#-host-provided-apis>#</a></h4><p>These arenâ€™t part of the JS language â€” theyâ€™re provided by the host:</p><table><thead><tr><th>API / Feature</th><th>Provided by</th></tr></thead><tbody><tr><td><code>setTimeout()</code></td><td>Browser / Node</td></tr><tr><td><code>document.querySelector()</code></td><td>Browser</td></tr><tr><td><code>fs.readFile()</code></td><td>Node.js</td></tr><tr><td><code>fetch()</code></td><td>Browser / Node (polyfilled)</td></tr><tr><td><code>postMessage()</code></td><td>Web Worker context</td></tr><tr><td><code>navigator.geolocation</code></td><td>Browser</td></tr></tbody></table><h4 id=-example>ğŸ’» Example:<a hidden class=anchor aria-hidden=true href=#-example>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Hello&#34;</span><span class=p>);</span> <span class=c1>// Host provides the &#39;console&#39; object
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>alert</span><span class=p>(</span><span class=s2>&#34;Hi&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>},</span> <span class=mi>1000</span><span class=p>);</span> <span class=c1>// &#39;setTimeout&#39; is NOT part of JS â€” it&#39;s host API
</span></span></span></code></pre></div><h4 id=-real-world-analogy>ğŸ§¬ Real-world analogy:<a hidden class=anchor aria-hidden=true href=#-real-world-analogy>#</a></h4><ul><li>The <strong>JS engine</strong> is the <strong>actor</strong>.</li><li>The <strong>host environment</strong> is the <strong>stage</strong>, <strong>lighting</strong>, <strong>props</strong>, and <strong>audience</strong>.</li></ul><p>The actor can memorize lines (JavaScript), but can&rsquo;t <strong>do</strong> anything â€” like turn on a spotlight or play sound â€” unless the stage supports it.</p><hr><h3 id=-23-engine-vs-host-division-of-concerns>ğŸ”¹ 2.3. <strong>Engine vs Host: Division of Concerns</strong><a hidden class=anchor aria-hidden=true href=#-23-engine-vs-host-division-of-concerns>#</a></h3><h4 id=-literal-meaning-2>âœ… Literal meaning:<a hidden class=anchor aria-hidden=true href=#-literal-meaning-2>#</a></h4><p>JavaScript engines and host environments play <strong>distinct but collaborative roles</strong>.</p><table><thead><tr><th>Concern</th><th>Handled by</th></tr></thead><tbody><tr><td><code>let</code>, <code>const</code>, <code>class</code>, <code>=></code></td><td>JavaScript Engine</td></tr><tr><td><code>console.log</code>, <code>setTimeout</code></td><td>Host Environment</td></tr><tr><td><code>document.getElementById</code></td><td>Host (Browser)</td></tr><tr><td><code>fs.readFileSync</code></td><td>Host (Node.js)</td></tr></tbody></table><h4 id=-why-this-matters>ğŸ§  Why this matters:<a hidden class=anchor aria-hidden=true href=#-why-this-matters>#</a></h4><ul><li>JavaScript <strong>isnâ€™t â€œbrowser-onlyâ€</strong> â€” itâ€™s a language, not a platform.</li><li>This is why you can run JS in:<ul><li>a browser (with DOM),</li><li>a server (Node.js),</li><li>an embedded device (e.g. Espruino),</li><li>or even in a text editor plugin (VS Code extensions).</li></ul></li></ul><p>Each context offers <strong>different tools</strong> â€” but the <strong>engine stays the same</strong>.</p><hr><h4 id=-code-comparison>ğŸ§ª Code Comparison:<a hidden class=anchor aria-hidden=true href=#-code-comparison>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// Runs in browser
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Hi&#34;</span><span class=p>),</span> <span class=mi>1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nb>document</span><span class=p>.</span><span class=nx>body</span><span class=p>.</span><span class=nx>style</span><span class=p>.</span><span class=nx>background</span> <span class=o>=</span> <span class=s2>&#34;black&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Runs in Node
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Hi&#34;</span><span class=p>),</span> <span class=mi>1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>fs</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s2>&#34;fs&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>fs</span><span class=p>.</span><span class=nx>readFileSync</span><span class=p>(</span><span class=s2>&#34;./file.txt&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>Same JS engine (V8), totally different <strong>capabilities</strong>, because of the host.</p><hr><h4 id=-gotcha-why-does-js-code-fail-in-node-but-not-in-the-browser>âš ï¸ Gotcha: â€œWhy does JS code fail in Node but not in the browser?â€<a hidden class=anchor aria-hidden=true href=#-gotcha-why-does-js-code-fail-in-node-but-not-in-the-browser>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// This fails in Node.js:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>document</span><span class=p>.</span><span class=nx>getElementById</span><span class=p>(</span><span class=s2>&#34;app&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>Because <code>document</code> is a <strong>host-provided object</strong>, and Node doesnâ€™t include a DOM.</p><blockquote><p>ğŸ’¡ Same JavaScript. Different host. Different powers.</p></blockquote><hr><h4 id=-related-concept-polyfills-and-environment-detection>ğŸ”— Related Concept: <strong>Polyfills and Environment Detection</strong><a hidden class=anchor aria-hidden=true href=#-related-concept-polyfills-and-environment-detection>#</a></h4><p>Because hosts vary:</p><ul><li>We need <strong>feature detection</strong> (<code>typeof window</code>, <code>if ('fetch' in globalThis)</code>)</li><li>We write <strong>polyfills</strong> (e.g., implement <code>fetch</code> in Node if itâ€™s missing)</li></ul><hr><h3 id=-tldr-mental-model>ğŸ§  TL;DR Mental Model<a hidden class=anchor aria-hidden=true href=#-tldr-mental-model>#</a></h3><table><thead><tr><th>Layer</th><th>Role</th></tr></thead><tbody><tr><td>JavaScript Engine</td><td>Understands and executes ECMAScript code</td></tr><tr><td>Host Environment</td><td>Provides platform-specific capabilities</td></tr><tr><td>JS Runtime</td><td>Combination of engine + host (aka â€œJS in the wildâ€)</td></tr></tbody></table><hr><h3 id=-summary-table>ğŸ§© Summary Table<a hidden class=anchor aria-hidden=true href=#-summary-table>#</a></h3><table><thead><tr><th>Concept</th><th>Engine or Host?</th><th>Example</th></tr></thead><tbody><tr><td><code>Promise</code>, <code>Map</code></td><td>Engine</td><td>ECMAScript features</td></tr><tr><td><code>setTimeout()</code></td><td>Host</td><td>Timer API (browser/Node)</td></tr><tr><td><code>document</code></td><td>Host (Browser)</td><td>Web page interaction</td></tr><tr><td><code>fs</code></td><td>Host (Node.js)</td><td>File system access</td></tr><tr><td><code>console</code></td><td>Host</td><td>Logging (defined per host)</td></tr><tr><td><code>function</code>, <code>=></code></td><td>Engine</td><td>Language-level syntax</td></tr></tbody></table><hr><h2 id=3--agent-execution-model--the-secret-engine-behind-javascripts-run-time>3. ğŸ§  Agent Execution Model â€” The Secret Engine Behind JavaScriptâ€™s Run-Time<a hidden class=anchor aria-hidden=true href=#3--agent-execution-model--the-secret-engine-behind-javascripts-run-time>#</a></h2><p>JavaScript may <em>look</em> like a language, but it <strong>runs</strong> like a machine. Under the hood, every line of your JavaScript code is managed by a tiny execution engine called an <strong>agent</strong>.</p><p>Letâ€™s crack open the hood and understand:</p><ul><li>What an <strong>agent</strong> actually is</li><li>The key <strong>data structures</strong> that power it</li><li>The <strong>lifecycle</strong> that makes async, generators, and tasks tick</li></ul><hr><h2 id=31--what-is-an-agent>3.1 ğŸš€ What is an Agent?<a hidden class=anchor aria-hidden=true href=#31--what-is-an-agent>#</a></h2><p>In the JavaScript spec, an <strong>agent</strong> is a self-contained execution environment â€” like a virtual CPU.</p><ul><li>It has its <strong>own memory (heap)</strong></li><li>Its own <strong>call stack</strong></li><li>Its own <strong>event/job queue</strong></li></ul><p>If you&rsquo;re running JavaScript in a browser tab, that&rsquo;s an agent.<br>If you&rsquo;re running a Web Worker, thatâ€™s <strong>another agent</strong>.<br>Each agent is <strong>isolated</strong> from the others (unless explicitly connected via <code>SharedArrayBuffer</code>).</p><h3 id=-think-of-an-agent-as>ğŸ§  Think of an agent as:<a hidden class=anchor aria-hidden=true href=#-think-of-an-agent-as>#</a></h3><blockquote><p>A single <strong>thread of execution</strong> with all the gears it needs to process JavaScript independently.</p></blockquote><h3 id=-metaphor>ğŸ”¬ Metaphor:<a hidden class=anchor aria-hidden=true href=#-metaphor>#</a></h3><p>If your code is a cooking recipe, an <strong>agent</strong> is the chef executing it â€” with its own kitchen, ingredients, and clipboard of instructions.</p><hr><h2 id=32--agent-data-structures-the-triad>3.2 âš™ï¸ Agent Data Structures: The Triad<a hidden class=anchor aria-hidden=true href=#32--agent-data-structures-the-triad>#</a></h2><p>Every agent internally runs three major data structures â€” the holy trinity of JS execution:</p><h3 id=-1-heap>ğŸ§  1. <strong>Heap</strong><a hidden class=anchor aria-hidden=true href=#-1-heap>#</a></h3><blockquote><p>ğŸ“¦ Where objects and functions live â€” long-term storage.</p></blockquote><ul><li>Every time you create an object (<code>{}</code>), array (<code>[]</code>), or function, itâ€™s allocated on the <strong>heap</strong>.</li><li>Think of the heap as your <strong>warehouse of live objects</strong>.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>user</span> <span class=o>=</span> <span class=p>{</span> <span class=nx>name</span><span class=o>:</span> <span class=s2>&#34;Ada&#34;</span> <span class=p>};</span> <span class=c1>// lives in the heap
</span></span></span></code></pre></div><p>This is <strong>unstructured memory</strong> â€” managed automatically by the garbage collector.</p><hr><h3 id=-2-call-stack>ğŸ§  2. <strong>Call Stack</strong><a hidden class=anchor aria-hidden=true href=#-2-call-stack>#</a></h3><blockquote><p>ğŸ§¾ Where functions are executed, tracked, and returned â€” one frame at a time.</p></blockquote><ul><li>JavaScript uses a <strong>stack</strong> (LIFO) to manage <strong>function calls</strong>.</li><li>Each function call creates an <strong>execution context</strong> (aka stack frame).</li><li>When a function finishes, the frame is <strong>popped off</strong>.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>outer</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>inner</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>inner</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Hi&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>outer</span><span class=p>();</span>
</span></span></code></pre></div><p><strong>Stack:</strong></p><ol><li><code>outer()</code></li><li><code>inner()</code></li><li><code>console.log(...)</code></li><li>Return, return, done âœ…</li></ol><p>ğŸ”¬ Metaphor: Like opening nested boxes. You canâ€™t close box A until youâ€™ve closed box B inside it.</p><hr><h3 id=-3-jobtask-queue>ğŸ§  3. <strong>Job/Task Queue</strong><a hidden class=anchor aria-hidden=true href=#-3-jobtask-queue>#</a></h3><blockquote><p>ğŸ•“ A FIFO queue of pending <strong>asynchronous callbacks</strong> to run when the stack is empty.</p></blockquote><ul><li>Used by async actions: <code>setTimeout</code>, <code>fetch</code>, Promises</li><li>Part of the <strong>event loop</strong> mechanism</li><li>Each â€œjobâ€ is a callback waiting to be pulled onto the stack</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;A&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;B&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;C&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p><strong>Output:</strong> A â†’ C â†’ B<br>Because <code>setTimeout</code> schedules <code>B</code> on the <strong>task queue</strong>, which runs after the current stack empties.</p><hr><h3 id=-all-together>ğŸ”¬ All Together:<a hidden class=anchor aria-hidden=true href=#-all-together>#</a></h3><table><thead><tr><th>Structure</th><th>Type</th><th>Role</th></tr></thead><tbody><tr><td><strong>Heap</strong></td><td>Memory</td><td>Stores all objects, functions</td></tr><tr><td><strong>Stack</strong></td><td>LIFO</td><td>Tracks current function calls</td></tr><tr><td><strong>Queue</strong></td><td>FIFO</td><td>Stores async jobs to run next</td></tr></tbody></table><hr><h2 id=33--agent-lifecycle--how-code-actually-runs>3.3 â³ Agent Lifecycle â€” How Code <em>Actually</em> Runs<a hidden class=anchor aria-hidden=true href=#33--agent-lifecycle--how-code-actually-runs>#</a></h2><p>The life of a JavaScript agent is a predictable cycle:</p><hr><h3 id=-step-1-a-job-begins>ğŸ”„ Step 1: A Job Begins<a hidden class=anchor aria-hidden=true href=#-step-1-a-job-begins>#</a></h3><ul><li>A new <strong>job</strong> is pulled from the <strong>queue</strong> (e.g., a <code>setTimeout</code> callback)</li><li>A <strong>new execution context</strong> is pushed onto the <strong>stack</strong></li><li>JS starts running the code in that callback</li></ul><hr><h3 id=-step-2-stack-fills-up>ğŸ“ˆ Step 2: Stack Fills Up<a hidden class=anchor aria-hidden=true href=#-step-2-stack-fills-up>#</a></h3><ul><li>The function may call other functions</li><li>More execution contexts are added</li><li>The <strong>call stack grows</strong></li></ul><hr><h3 id=-step-3-stack-empties>ğŸ“‰ Step 3: Stack Empties<a hidden class=anchor aria-hidden=true href=#-step-3-stack-empties>#</a></h3><ul><li>Each function finishes and returns</li><li>The stack <strong>pops</strong> back down to empty</li><li>Once empty, the agent picks the <strong>next job</strong> from the queue</li></ul><hr><h3 id=-step-4-idle-or-re-entry>ğŸ’¤ Step 4: Idle or Re-entry<a hidden class=anchor aria-hidden=true href=#-step-4-idle-or-re-entry>#</a></h3><ul><li>If the queue is empty â†’ agent waits</li><li>If the code <strong>yields</strong> (e.g. with a generator or async function), the context is <strong>paused</strong></li><li>It can later be <strong>resumed</strong> with the same state</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span><span class=o>*</span> <span class=nx>steps</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Start&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>yield</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Resumed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>g</span> <span class=o>=</span> <span class=nx>steps</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>g</span><span class=p>.</span><span class=nx>next</span><span class=p>();</span> <span class=c1>// Start
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>g</span><span class=p>.</span><span class=nx>next</span><span class=p>();</span> <span class=c1>// Resumed
</span></span></span></code></pre></div><p>ğŸ§  The function isnâ€™t restarted â€” itâ€™s <em>resumed from where it left off</em>.</p><hr><h3 id=-why-it-matters>ğŸ§  Why It Matters<a hidden class=anchor aria-hidden=true href=#-why-it-matters>#</a></h3><p>Understanding the <strong>agent model</strong> gives you deep insight into:</p><ul><li>Why JS is single-threaded (per agent)</li><li>Why async functions return promises</li><li>Why <code>await</code> doesn&rsquo;t block the thread</li><li>Why stack overflows happen (<code>Recursion</code>!)</li></ul><hr><h2 id=-bonus-multi-agent-systems>ğŸ’¡ Bonus: Multi-Agent Systems<a hidden class=anchor aria-hidden=true href=#-bonus-multi-agent-systems>#</a></h2><ul><li>You can have <strong>multiple agents</strong> running concurrently (e.g., Web Workers)</li><li>Each has <strong>its own stack, heap, and queue</strong></li><li>They can only communicate via:<ul><li><code>postMessage</code> (copying data)</li><li><code>SharedArrayBuffer + Atomics</code> (shared memory)</li></ul></li></ul><hr><h2 id=-recap-agent-model-mental-picture>âœ… Recap: Agent Model Mental Picture<a hidden class=anchor aria-hidden=true href=#-recap-agent-model-mental-picture>#</a></h2><table><thead><tr><th>Part</th><th>Role</th><th>Behavior</th></tr></thead><tbody><tr><td><strong>Agent</strong></td><td>The JS â€œruntime engineâ€</td><td>Runs JS code sequentially</td></tr><tr><td><strong>Heap</strong></td><td>Stores objects</td><td>Grows dynamically, managed by GC</td></tr><tr><td><strong>Stack</strong></td><td>Manages function calls</td><td>LIFO â€” grows and shrinks</td></tr><tr><td><strong>Queue</strong></td><td>Schedules async jobs</td><td>FIFO â€” drives the event loop</td></tr><tr><td><strong>Lifecycle</strong></td><td>Pull job â†’ execute â†’ finish â†’ repeat</td><td>Enables async flow</td></tr></tbody></table><hr><h2 id=-real-world-debugging-tip>âœ¨ Real-World Debugging Tip<a hidden class=anchor aria-hidden=true href=#-real-world-debugging-tip>#</a></h2><p>When your UI freezes or <code>console.log</code> appears out of order â€” youâ€™re seeing the <strong>agent lifecycle in action</strong>.<br>If you understand how the stack and queue interact, you can <strong>predict and control</strong> the timing of your code.</p><hr><h2 id=4--execution-contexts--call-stack>4. ğŸ“¦ <strong>Execution Contexts & Call Stack</strong><a hidden class=anchor aria-hidden=true href=#4--execution-contexts--call-stack>#</a></h2><hr><h3 id=41--what-is-an-execution-context>4.1. ğŸ§  <strong>What is an Execution Context?</strong><a hidden class=anchor aria-hidden=true href=#41--what-is-an-execution-context>#</a></h3><p>An <strong>execution context</strong> (also called a <em>stack frame</em>) is the smallest unit of JS code execution.<br>Whenever JavaScript runs any codeâ€”be it global, a function, or an evalâ€”it wraps it in an execution context.</p><h4 id=-it-contains>ğŸ” It contains:<a hidden class=anchor aria-hidden=true href=#-it-contains>#</a></h4><ul><li>ğŸ§¾ The currently executing <strong>function or script</strong></li><li>ğŸ“¦ Its <strong>Lexical Environment</strong> (all its declared variables, parameters, inner functions)</li><li>ğŸ”— The associated <strong>Realm</strong> (global scope + intrinsics like <code>Array</code>)</li><li>ğŸ’¬ Special bindings like <code>this</code>, <code>arguments</code>, and <code>super</code></li><li>ğŸ§­ The <strong>return address</strong> (where to go back once the function completes)</li></ul><h4 id=-mental-model-1>ğŸ§¬ Mental Model:<a hidden class=anchor aria-hidden=true href=#-mental-model-1>#</a></h4><blockquote><p>Like a stack of sticky notes: each time a function is called, a new note (context) is added. It tracks what to do and where to return. Once done, it peels off.</p></blockquote><h4 id=-example-1>ğŸ’» Example:<a hidden class=anchor aria-hidden=true href=#-example-1>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>add</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>compute</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>y</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>add</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>compute</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span> <span class=c1>// Execution Contexts created: global -&gt; compute -&gt; add
</span></span></span></code></pre></div><p>Each function call creates a new context with its own scope, <code>this</code>, and state.</p><hr><h3 id=-lexical-environment>ğŸ§© Lexical Environment<a hidden class=anchor aria-hidden=true href=#-lexical-environment>#</a></h3><p>Every execution context has a <strong>Lexical Environment</strong>, which stores:</p><ul><li>Local variable bindings (<code>let</code>, <code>const</code>, <code>var</code>)</li><li>Function declarations</li><li>Inner scopes (closures)</li></ul><p>It&rsquo;s called <em>lexical</em> because it&rsquo;s determined by <strong>where the code is written</strong>, not how it is called.</p><h4 id=-closures>ğŸ” Closures:<a hidden class=anchor aria-hidden=true href=#-closures>#</a></h4><p>When a function is defined, it &ldquo;remembers&rdquo; the Lexical Environment it was created in. This is what powers closures:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>outer</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nx>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kd>function</span> <span class=nx>inner</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>count</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>count</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The <code>inner</code> function holds on to the <code>outer</code>&rsquo;s lexical environment even after <code>outer</code> has returned.</p><hr><h3 id=-realm-association>ğŸŒ Realm Association<a hidden class=anchor aria-hidden=true href=#-realm-association>#</a></h3><p>Each execution context is tied to a <strong>Realm</strong>, which determines:</p><ul><li>The version of intrinsics like <code>Array</code>, <code>Function</code>, etc.</li><li>The <code>globalThis</code> value</li><li>Identity rules (e.g., <code>x instanceof Array</code> fails across realms)</li></ul><h4 id=-gotcha>âš ï¸ Gotcha:<a hidden class=anchor aria-hidden=true href=#-gotcha>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// If `arr` is created in iframe
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>arr</span> <span class=k>instanceof</span> <span class=nb>Array</span><span class=p>;</span> <span class=c1>// âŒ false (different realm&#39;s Array)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>Array</span><span class=p>.</span><span class=nx>isArray</span><span class=p>(</span><span class=nx>arr</span><span class=p>);</span>   <span class=c1>// âœ… works (uses internal tag)
</span></span></span></code></pre></div><hr><h3 id=-this-arguments-and-bindings>âš™ï¸ <code>this</code>, <code>arguments</code>, and Bindings<a hidden class=anchor aria-hidden=true href=#-this-arguments-and-bindings>#</a></h3><p>Each context stores runtime-bound values:</p><ul><li><code>this</code> â€” depends on how the function is called (object method, arrow, etc.)</li><li><code>arguments</code> â€” array-like object for parameters (non-arrow functions)</li><li><code>super</code> â€” relevant in class methods</li><li>New private class fields/methods also bind per context</li></ul><hr><h3 id=42--function-invocation--stack-frames>4.2. ğŸ” <strong>Function Invocation & Stack Frames</strong><a hidden class=anchor aria-hidden=true href=#42--function-invocation--stack-frames>#</a></h3><p>When a function is invoked:</p><ol><li>JS creates a new <strong>execution context</strong> (stack frame)</li><li>Pushes it onto the <strong>call stack</strong></li><li>Begins executing it</li></ol><h4 id=-when-the-function-finishes>ğŸ“¤ When the function finishes:<a hidden class=anchor aria-hidden=true href=#-when-the-function-finishes>#</a></h4><ul><li>It <strong>returns</strong> a value or throws an error</li><li>Its frame is <strong>popped</strong> off the stack</li><li>Execution continues where it left off</li></ul><h4 id=-code-trace>ğŸ’» Code Trace:<a hidden class=anchor aria-hidden=true href=#-code-trace>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>foo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>x</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>bar</span><span class=p>(</span><span class=nx>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>bar</span><span class=p>(</span><span class=nx>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>n</span> <span class=o>+</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>foo</span><span class=p>();</span>
</span></span></code></pre></div><p>ğŸ§± Stack trace:</p><pre tabindex=0><code>[global]
â†’ foo()          â† pushed
â†’ bar(10)        â† pushed
â† return 15      â† bar popped
â† return 15      â† foo popped
</code></pre><h4 id=-key-behaviors>ğŸ¯ Key behaviors:<a hidden class=anchor aria-hidden=true href=#-key-behaviors>#</a></h4><ul><li><strong>Return</strong> unwinds one frame</li><li><strong>Throw</strong> can unwind multiple frames up the stack (via try/catch or crash)</li><li><strong>Recursion</strong> builds up frames until base case or overflow</li></ul><hr><h3 id=-43-tail-call-optimization-tco>âš¡ 4.3. <strong>Tail Call Optimization (TCO)</strong><a hidden class=anchor aria-hidden=true href=#-43-tail-call-optimization-tco>#</a></h3><p><strong>Tail Call</strong> = when a function returns the result of <em>calling another function directly</em><br>(i.e., no more work left to do after the call).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>a</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>b</span><span class=p>();</span> <span class=c1>// â† tail position
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>If supported, JS engines can <strong>reuse the current stack frame</strong> rather than creating a new one.</p><hr><h4 id=-benefits>ğŸ¯ Benefits:<a hidden class=anchor aria-hidden=true href=#-benefits>#</a></h4><ul><li>Prevents stack overflow in <strong>tail-recursive</strong> functions</li><li>Improves memory efficiency for deeply nested calls</li></ul><h4 id=-example-ideal-for-tco>ğŸ”¥ Example (ideal for TCO):<a hidden class=anchor aria-hidden=true href=#-example-ideal-for-tco>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>factorial</span><span class=p>(</span><span class=nx>n</span><span class=p>,</span> <span class=nx>acc</span> <span class=o>=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nx>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>)</span> <span class=k>return</span> <span class=nx>acc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>factorial</span><span class=p>(</span><span class=nx>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=nx>acc</span> <span class=o>*</span> <span class=nx>n</span><span class=p>);</span> <span class=c1>// tail call
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>ğŸ” Without TCO â†’ Stack grows with <code>n</code><br>âœ… With TCO â†’ Constant memory usage</p><hr><h4 id=-engine-support-caveats>âš ï¸ Engine Support Caveats:<a hidden class=anchor aria-hidden=true href=#-engine-support-caveats>#</a></h4><ul><li><strong>ECMAScript 2015</strong> specifies proper TCO.</li><li><strong>Only Safari</strong> implements it (as of now).</li><li><strong>V8, SpiderMonkey, Chakra</strong> do <strong>not</strong> support it due to debugging & stack trace concerns.</li></ul><hr><h3 id=-summary-table-1>ğŸ§  Summary Table<a hidden class=anchor aria-hidden=true href=#-summary-table-1>#</a></h3><table><thead><tr><th>Concept</th><th>Meaning & Purpose</th></tr></thead><tbody><tr><td>Execution Context</td><td>Metadata + bindings for running code</td></tr><tr><td>Stack Frame</td><td>Unit of execution pushed onto the call stack</td></tr><tr><td>Lexical Environment</td><td>Local scope: variables, closures, declarations</td></tr><tr><td>Realm</td><td>JS &ldquo;universe&rdquo; for built-ins, <code>globalThis</code>, etc.</td></tr><tr><td>Call Stack</td><td>LIFO structure tracking nested calls</td></tr><tr><td>Return / Throw</td><td>Unwinds stack frames (1 or more)</td></tr><tr><td>Tail Call Optimization</td><td>Reuses stack frame for tail calls (not widely supported)</td></tr></tbody></table><hr><h2 id=5--understanding-realms-the-hidden-worlds-of-javascript-execution>5. ğŸŒ€ Understanding Realms: The Hidden Worlds of JavaScript Execution<a hidden class=anchor aria-hidden=true href=#5--understanding-realms-the-hidden-worlds-of-javascript-execution>#</a></h2><p>When we talk about JavaScript execution, we often focus on the call stack, the event loop, or async jobs. But thereâ€™s a <strong>deeper architectural layer</strong> that rarely gets discussedâ€”<strong>Realms</strong>.</p><p>Think of realms as <strong>self-contained universes</strong> within a single JavaScript agent. If you&rsquo;re debugging why <code>instanceof</code> mysteriously returns <code>false</code>, or why your iframeâ€™s <code>Array</code> behaves strangely, you&rsquo;re bumping up against <strong>realms</strong>â€”without even knowing it.</p><p>Letâ€™s unpack this critical concept with surgical depth and practical clarity.</p><hr><h2 id=-what-is-a-realm>ğŸ“¦ What Is a Realm?<a hidden class=anchor aria-hidden=true href=#-what-is-a-realm>#</a></h2><blockquote><p>A <strong>realm</strong> is a sandboxed execution environment in JavaScript.<br>Each realm has its <strong>own global object</strong> and <strong>its own copies of built-in constructors</strong> like <code>Object</code>, <code>Array</code>, <code>Function</code>, and so on.</p></blockquote><p>In simpler terms:</p><ul><li>A realm is a <strong>complete JS world</strong>â€”with its own set of laws (built-ins), and its own sky (global object).</li><li>It exists <strong>within an agent</strong> (a JS thread), and multiple realms can coexist inside a single agent.</li></ul><h3 id=-mental-model-2>ğŸ§  Mental Model:<a hidden class=anchor aria-hidden=true href=#-mental-model-2>#</a></h3><blockquote><p>ğŸ§µ <em>Agent</em> = one JS thread<br>ğŸŒ <em>Realm</em> = one JS environment (one <code>globalThis</code>)</p></blockquote><h3 id=-real-world-examples>ğŸ’¡ Real-World Examples:<a hidden class=anchor aria-hidden=true href=#-real-world-examples>#</a></h3><ul><li>Your main browser tab â†’ 1 realm.</li><li>A same-origin <code>&lt;iframe></code> â†’ another realm (but in the same agent).</li><li>A Web Worker â†’ a <strong>separate agent</strong> with its <strong>own realm</strong>.</li></ul><hr><h2 id=-realm-internals>ğŸ”¬ Realm Internals<a hidden class=anchor aria-hidden=true href=#-realm-internals>#</a></h2><p>Letâ€™s zoom into what makes up a realm:</p><h3 id=1--intrinsic-objects>1. ğŸ§¬ Intrinsic Objects<a hidden class=anchor aria-hidden=true href=#1--intrinsic-objects>#</a></h3><p>Each realm creates <strong>fresh copies</strong> of all intrinsic JS constructors and prototypes:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nb>Array</span> <span class=o>!==</span> <span class=nx>iframe</span><span class=p>.</span><span class=nx>contentWindow</span><span class=p>.</span><span class=nb>Array</span><span class=p>;</span> <span class=c1>// âœ… true
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>Object</span> <span class=o>!==</span> <span class=nx>iframe</span><span class=p>.</span><span class=nx>contentWindow</span><span class=p>.</span><span class=nb>Object</span><span class=p>;</span> <span class=c1>// âœ… true
</span></span></span></code></pre></div><p>These aren&rsquo;t just shallow copies â€” theyâ€™re entirely different objects in memory. This is what leads to one of the most notorious bugs in cross-realm JSâ€¦</p><h3 id=-gotcha-instanceof-fails-across-realms>âš ï¸ Gotcha: <code>instanceof</code> fails across realms<a hidden class=anchor aria-hidden=true href=#-gotcha-instanceof-fails-across-realms>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>iframeArray</span> <span class=o>=</span> <span class=nx>iframe</span><span class=p>.</span><span class=nx>contentWindow</span><span class=p>.</span><span class=nb>eval</span><span class=p>(</span><span class=s2>&#34;[]&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>iframeArray</span> <span class=k>instanceof</span> <span class=nb>Array</span><span class=p>;</span> <span class=c1>// âŒ false
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>Array</span><span class=p>.</span><span class=nx>isArray</span><span class=p>(</span><span class=nx>iframeArray</span><span class=p>);</span>   <span class=c1>// âœ… true
</span></span></span></code></pre></div><p><strong>Why?</strong> Because <code>iframeArray</code>&rsquo;s prototype chain points to <strong>iframeâ€™s</strong> <code>Array.prototype</code>, not yours.</p><p>This is why you should <strong>always use</strong>:</p><ul><li><code>Array.isArray(obj)</code></li><li><code>Object.prototype.toString.call(obj)</code></li></ul><p>â€¦and never rely on <code>instanceof</code> when realms might be involved.</p><hr><h3 id=2--global-object-and-globalthis>2. ğŸª Global Object and <code>globalThis</code><a hidden class=anchor aria-hidden=true href=#2--global-object-and-globalthis>#</a></h3><p>Each realm gets its own <strong>global object</strong>, which defines the top-level scope.</p><p>Depending on the context, this global object could be:</p><ul><li>A <code>Window</code> (in a tab or iframe)</li><li>A <code>WorkerGlobalScope</code> (in a worker)</li><li>A <code>WorkletGlobalScope</code> (in an audio or paint worklet)</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nb>window</span><span class=p>.</span><span class=nx>globalThis</span> <span class=o>===</span> <span class=nb>window</span><span class=p>;</span> <span class=c1>// âœ… in a tab
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>self</span><span class=p>.</span><span class=nx>globalThis</span> <span class=o>===</span> <span class=nx>self</span><span class=p>;</span>     <span class=c1>// âœ… in a worker
</span></span></span></code></pre></div><p>Each realm has a unique <code>globalThis</code> â€” they donâ€™t bleed into each other.</p><hr><h3 id=3--template-literal-cache>3. ğŸ§  Template Literal Cache<a hidden class=anchor aria-hidden=true href=#3--template-literal-cache>#</a></h3><p>Tagged template literals reuse the same <strong>array object</strong> on repeated calls <strong>within the same realm</strong>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>tag</span><span class=p>(</span><span class=nx>strings</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>strings</span><span class=p>);</span> <span class=c1>// same object each time
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>tag</span><span class=sb>`hello`</span><span class=p>;</span> <span class=c1>// strings === [&#34;hello&#34;]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>tag</span><span class=sb>`hello`</span><span class=p>;</span> <span class=c1>// strings is the same object
</span></span></span></code></pre></div><p>But that cache is <strong>per-realm</strong>. Use a different realm (like an iframe), and you&rsquo;ll get a different array object, even with the same template.</p><hr><h2 id=-realms-vs-agents>ğŸ§© Realms vs Agents<a hidden class=anchor aria-hidden=true href=#-realms-vs-agents>#</a></h2><p>Letâ€™s clarify the distinction:</p><table><thead><tr><th>Concept</th><th>Realm</th><th>Agent</th></tr></thead><tbody><tr><td>What it is</td><td>A JS environment with its own global scope & built-ins</td><td>A JS <strong>thread</strong> (executor of code)</td></tr><tr><td>Count</td><td>Multiple per agent</td><td>One per thread</td></tr><tr><td>Global object</td><td>Unique per realm (<code>window</code>, <code>self</code>, etc.)</td><td>Not shared across agents</td></tr><tr><td>Memory</td><td>Shared heap (within same agent)</td><td>Isolated between agents unless using SharedArrayBuffer</td></tr></tbody></table><h3 id=-realms-can-talk-if-in-same-agent>ğŸ” Realms Can Talk (if in same agent)<a hidden class=anchor aria-hidden=true href=#-realms-can-talk-if-in-same-agent>#</a></h3><p>If you have:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=o>&lt;</span><span class=nx>iframe</span> <span class=nx>src</span><span class=o>=</span><span class=s2>&#34;same-origin.html&#34;</span><span class=o>&gt;&lt;</span><span class=err>/iframe&gt;</span>
</span></span></code></pre></div><p>You can synchronously access the iframeâ€™s realm:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>iframe</span><span class=p>.</span><span class=nx>contentWindow</span><span class=p>.</span><span class=nb>document</span><span class=p>.</span><span class=nx>title</span><span class=p>;</span> <span class=c1>// âœ… works
</span></span></span></code></pre></div><p>But remember: it&rsquo;s a <strong>different realm</strong>. So be cautious with identity checks.</p><hr><h2 id=-why-realms-matter-in-the-real-world>ğŸ” Why Realms Matter in the Real World<a hidden class=anchor aria-hidden=true href=#-why-realms-matter-in-the-real-world>#</a></h2><h3 id=1-security-and-isolation>1. <strong>Security and Isolation</strong><a hidden class=anchor aria-hidden=true href=#1-security-and-isolation>#</a></h3><ul><li>Realms provide containment: Each realm is sandboxed with its own set of built-ins and globals.</li><li>Cross-origin iframes get different agents <em>and</em> different realms, enforcing strict separation.</li></ul><h3 id=2-framework--testing-tooling>2. <strong>Framework & Testing Tooling</strong><a hidden class=anchor aria-hidden=true href=#2-framework--testing-tooling>#</a></h3><ul><li>Tools like Jest, JSDOM, or sandboxed evaluators often run code in isolated realms to prevent global pollution.</li></ul><h3 id=3-micro-frontend-architecture>3. <strong>Micro-frontend Architecture</strong><a hidden class=anchor aria-hidden=true href=#3-micro-frontend-architecture>#</a></h3><ul><li>In advanced front-end architectures, teams load independent apps in iframes or ShadowRealms to prevent conflicts.</li></ul><h3 id=4-cross-realm-bugs>4. <strong>Cross-Realm Bugs</strong><a hidden class=anchor aria-hidden=true href=#4-cross-realm-bugs>#</a></h3><ul><li>If you&rsquo;re building libraries, especially polyfills or type-checking utils, <strong>you must account for realm differences</strong>.<div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// Anti-pattern
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>value</span> <span class=k>instanceof</span> <span class=nb>Object</span><span class=p>;</span> <span class=c1>// âŒ not safe across realms
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// Safe alternative
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>Object</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>toString</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=nx>value</span><span class=p>)</span> <span class=o>===</span> <span class=s2>&#34;[object Object]&#34;</span><span class=p>;</span> <span class=c1>// âœ…
</span></span></span></code></pre></div></li></ul><hr><h2 id=-takeaways>ğŸ§  Takeaways<a hidden class=anchor aria-hidden=true href=#-takeaways>#</a></h2><ul><li><strong>A realm is a self-contained JS universe</strong> â€” with its own global scope and its own versions of built-in types.</li><li>Realms can coexist inside a single agent, but their built-ins and identity checks <strong>do not overlap</strong>.</li><li>Always prefer <strong>realm-safe methods</strong> (<code>Array.isArray</code>, <code>Object.prototype.toString.call</code>) over <code>instanceof</code>.</li><li>Understand realms if you&rsquo;re working with:<ul><li>iframes</li><li>workers</li><li>multi-app frontends</li><li>testing sandboxes</li><li>serialization/deserialization across origins</li></ul></li></ul><hr><h2 id=-bonus-shadowrealm-tc39-stage-3>ğŸ“Œ Bonus: ShadowRealm (TC39 Stage 3)<a hidden class=anchor aria-hidden=true href=#-bonus-shadowrealm-tc39-stage-3>#</a></h2><p>A new JS feature, <code>ShadowRealm</code>, allows you to <strong>create a new realm programmatically</strong> without using iframes:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>realm</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>ShadowRealm</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>result</span> <span class=o>=</span> <span class=nx>realm</span><span class=p>.</span><span class=nx>evaluate</span><span class=p>(</span><span class=sb>`1 + 1`</span><span class=p>);</span> <span class=c1>// 2
</span></span></span></code></pre></div><p>This is <strong>realm-level isolation</strong>, but <strong>still within the same agent</strong>. Great for security, testing, or plugin systems.</p><hr><h2 id=-final-word>âœï¸ Final Word<a hidden class=anchor aria-hidden=true href=#-final-word>#</a></h2><p>JavaScript realms are like alternate realities â€” isolated yet interconnected in subtle ways. They influence how your objects behave, how identity is checked, and how memory is managed.</p><p>Understanding realms is a <strong>superpower</strong> â€” especially if youâ€™re debugging strange prototype issues or building frameworks and platforms. Master this layer, and youâ€™re one step closer to mastering the entire JavaScript execution model.</p><hr><h2 id=6--agent-types-in-the-web-platform>6. ğŸŒ <strong>Agent Types in the Web Platform</strong><a hidden class=anchor aria-hidden=true href=#6--agent-types-in-the-web-platform>#</a></h2><h3 id=61-main-window-agent>6.1. Main Window Agent<a hidden class=anchor aria-hidden=true href=#61-main-window-agent>#</a></h3><h3 id=62-dedicated-worker-agent>6.2. Dedicated Worker Agent<a hidden class=anchor aria-hidden=true href=#62-dedicated-worker-agent>#</a></h3><h3 id=63-shared-worker-agent>6.3. Shared Worker Agent<a hidden class=anchor aria-hidden=true href=#63-shared-worker-agent>#</a></h3><h3 id=64-service-worker-agent>6.4. Service Worker Agent<a hidden class=anchor aria-hidden=true href=#64-service-worker-agent>#</a></h3><h3 id=65-worklet-agent>6.5. Worklet Agent<a hidden class=anchor aria-hidden=true href=#65-worklet-agent>#</a></h3><ul><li>Each has its own heap, stack, queue</li><li>Communication model (<code>postMessage</code>, SharedArrayBuffer)</li></ul><hr><h2 id=6--agent-types-in-the-web-platform-1>6. ğŸŒ <strong>Agent Types in the Web Platform</strong><a hidden class=anchor aria-hidden=true href=#6--agent-types-in-the-web-platform-1>#</a></h2><p>The web isn&rsquo;t just one giant thread where all JavaScript code runs together. Instead, it&rsquo;s composed of multiple <strong>agents</strong> â€” isolated, independent runtimes that can each execute JS code with their own <strong>heap</strong>, <strong>call stack</strong>, and <strong>event loop</strong>. Understanding these agent types is crucial for mastering concurrency, memory isolation, and performance design patterns in modern web development.</p><p>Letâ€™s break down the main types of agents and why they matter:</p><hr><h3 id=61--main-window-agent>6.1 ğŸªŸ <strong>Main Window Agent</strong><a hidden class=anchor aria-hidden=true href=#61--main-window-agent>#</a></h3><p>This is the agent you interact with most â€” the <strong>tab</strong> in your browser running HTML, CSS, and JavaScript. It includes:</p><ul><li>The global <code>window</code> object</li><li>Access to the DOM</li><li>Full access to browser APIs (e.g., <code>document</code>, <code>alert</code>, <code>fetch</code>)</li></ul><p>Multiple same-origin iframes can <em>share</em> the same agent, meaning they share the <strong>call stack</strong> and can synchronously call each otherâ€™s functions and access each otherâ€™s memory (within security limits).</p><p>ğŸ“Œ <strong>Key traits</strong>:</p><ul><li>Has direct DOM access</li><li>Can synchronously communicate with same-origin iframes</li><li>Cannot be blocked via <code>Atomics.wait()</code></li></ul><p>ğŸ§  <strong>Mental model</strong>: A control room managing user interaction, UI rendering, and input events â€” all on one thread.</p><hr><h3 id=62--dedicated-worker-agent>6.2 ğŸ‘· <strong>Dedicated Worker Agent</strong><a hidden class=anchor aria-hidden=true href=#62--dedicated-worker-agent>#</a></h3><p>Created via <code>new Worker()</code>, a <strong>Dedicated Worker</strong> runs JS in a completely separate agent â€” its own isolated thread. It doesnâ€™t have access to the DOM, but can perform heavy computations without blocking the main thread.</p><p>ğŸ“¦ <strong>Separate agent = separate memory</strong>:</p><ul><li>Own heap</li><li>Own call stack</li><li>Own event loop</li></ul><p>ğŸ§  Think of it like spawning a specialized assistant: you give it instructions via <code>postMessage()</code>, and it replies asynchronously.</p><p>âœ… Can use <code>SharedArrayBuffer</code> for shared memory (with proper CORS and COOP/COEP headers)</p><p>ğŸ’»</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>worker</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Worker</span><span class=p>(</span><span class=s2>&#34;worker.js&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>worker</span><span class=p>.</span><span class=nx>postMessage</span><span class=p>({</span> <span class=nx>task</span><span class=o>:</span> <span class=s2>&#34;compute&#34;</span> <span class=p>});</span>
</span></span></code></pre></div><hr><h3 id=63--shared-worker-agent>6.3 ğŸ¤ <strong>Shared Worker Agent</strong><a hidden class=anchor aria-hidden=true href=#63--shared-worker-agent>#</a></h3><p>Shared Workers are like Dedicated Workers, but <strong>shared across multiple same-origin contexts</strong> â€” tabs, iframes, or windows. They persist beyond a single page and can maintain shared state (like a single WebSocket connection).</p><p>ğŸ“Œ <strong>Key distinction</strong>: They <strong>do not</strong> share memory with their clients. All communication is through <code>postMessage()</code> using <strong>structured cloning</strong>.</p><p>ğŸ§  Metaphor: A shared database or message bus multiple clients talk to, but no one can directly poke into its memory.</p><hr><h3 id=64--service-worker-agent>6.4 ğŸ›° <strong>Service Worker Agent</strong><a hidden class=anchor aria-hidden=true href=#64--service-worker-agent>#</a></h3><p>A <strong>Service Worker</strong> is a proxy-like agent that sits between your web app and the network. It doesnâ€™t have a UI and cannot touch the DOM, but it can:</p><ul><li>Intercept network requests</li><li>Serve cached assets</li><li>Enable offline experiences</li><li>Run even when the page is closed</li></ul><p>ğŸ“¦ It has its own agent â€” its own heap, stack, and event queue â€” and doesnâ€™t share memory with any window.</p><p>ğŸ§  Think of it as a background daemon that acts as a programmable router.</p><p>ğŸ’¡ Bonus: Service workers are essential for building Progressive Web Apps (PWAs).</p><hr><h3 id=65--worklet-agent>6.5 ğŸ¨ <strong>Worklet Agent</strong><a hidden class=anchor aria-hidden=true href=#65--worklet-agent>#</a></h3><p><strong>Worklets</strong> are ultra-lightweight, low-latency agents used for frame-by-frame operations in:</p><ul><li><strong>AudioWorklet</strong> (real-time DSP)</li><li><strong>PaintWorklet</strong> (CSS custom painting)</li><li><strong>LayoutWorklet</strong> (custom layout logic)</li></ul><p>These agents are stripped down for speed â€” no DOM, no network access, but real-time-safe execution.</p><p>ğŸ§  Imagine a tiny artist or sound engineer working just fast enough to keep up with your browserâ€™s 60FPS heartbeat.</p><p>ğŸ“Œ They run inside their own agent and can be memory-shared with their creators using <code>SharedArrayBuffer</code>.</p><hr><h3 id=-all-agent-types-have>ğŸ§¬ All Agent Types Have:<a hidden class=anchor aria-hidden=true href=#-all-agent-types-have>#</a></h3><p>âœ… Their <strong>own execution context</strong>:</p><ul><li><strong>Heap</strong>: where objects live</li><li><strong>Call stack</strong>: for function execution</li><li><strong>Job queue</strong>: for async callbacks (event loop)</li></ul><p>âœ… Communication model:</p><ul><li>ğŸ” <code>postMessage()</code> for asynchronous messaging (structured cloning)</li><li>ğŸ”— <code>SharedArrayBuffer</code> + <code>Atomics</code> for shared memory and synchronization (if in the same agent cluster)</li></ul><hr><h3 id=-summary-table-2>ğŸ§  Summary Table<a hidden class=anchor aria-hidden=true href=#-summary-table-2>#</a></h3><table><thead><tr><th>Agent Type</th><th>DOM Access</th><th>Memory Sharing</th><th>Shared Across Tabs?</th><th>Use Case</th></tr></thead><tbody><tr><td><strong>Main Window Agent</strong></td><td>âœ… Yes</td><td>âœ… with same-origin iframes</td><td>âŒ</td><td>UI logic, DOM interaction</td></tr><tr><td><strong>Dedicated Worker</strong></td><td>âŒ No</td><td>âœ… via <code>SharedArrayBuffer</code></td><td>âŒ</td><td>Heavy computation, parallel tasks</td></tr><tr><td><strong>Shared Worker</strong></td><td>âŒ No</td><td>âŒ</td><td>âœ…</td><td>Cross-tab state sync, WebSocket hub</td></tr><tr><td><strong>Service Worker</strong></td><td>âŒ No</td><td>âŒ</td><td>âœ…</td><td>Offline support, request caching</td></tr><tr><td><strong>Worklet</strong></td><td>âŒ No</td><td>âœ… (when configured)</td><td>âŒ</td><td>Real-time audio/visual processing</td></tr></tbody></table><hr><h3 id=-related-concepts>ğŸ”— Related Concepts:<a hidden class=anchor aria-hidden=true href=#-related-concepts>#</a></h3><ul><li><strong>Agent Cluster</strong>: A group of agents that can share memory (<code>SharedArrayBuffer</code>) and synchronize with <code>Atomics</code>.</li><li><strong>Structured Cloning</strong>: Default communication method â€” objects are <em>copied</em>, not shared.</li><li><strong>Heap / Stack / Queue</strong>: Every agent gets their own â€” enabling safe, parallel, isolated execution.</li></ul><hr><p>ğŸ“£ <strong>Takeaway</strong>:<br>Modern JavaScript isnâ€™t single-threaded anymore â€” <strong>itâ€™s multi-agent</strong>.<br>You, as a developer, control which type of agent runs your code â€” and how they communicate. Choose wisely based on memory safety, responsiveness, and your appâ€™s architecture.</p><hr><h2 id=7--job-queue--event-loop>7. ğŸ” <strong>Job Queue & Event Loop</strong><a hidden class=anchor aria-hidden=true href=#7--job-queue--event-loop>#</a></h2><p>Modern JavaScript feels synchronous â€” but behaves asynchronously. That paradox is powered by one of the most elegant constructs in programming: the <strong>event loop</strong>.</p><p>Letâ€™s dive deep into how JavaScript keeps your code <em>non-blocking</em>, <em>predictable</em>, and <em>responsive</em> â€” using <strong>jobs</strong>, <strong>queues</strong>, and a beautiful bit of choreography called the <strong>run-to-completion model</strong>.</p><hr><h3 id=71--what-is-a-job>7.1 ğŸ”§ What is a Job?<a hidden class=anchor aria-hidden=true href=#71--what-is-a-job>#</a></h3><blockquote><p><strong>Callback + Execution Context = Job</strong></p></blockquote><p>Every time your code hands off a function to be called later â€” say, via <code>setTimeout</code>, a Promise, or a DOM event â€” you&rsquo;re scheduling a <strong>job</strong>. Think of it as a <strong>tiny program</strong> JS will run once itâ€™s done with the current one.</p><p>These jobs are stored in queues and executed one at a time, with guaranteed order and isolation.</p><p>ğŸ§  <strong>Mental Model</strong>:<br>Each job is like a fully wrapped meal order â€” a recipe (<code>callback</code>) bundled with ingredients (<code>execution context</code>). JS cooks them one-by-one, never two at once.</p><hr><h3 id=72--event-loop-the-scheduler-in-chief>7.2 ğŸ”„ Event Loop: The Scheduler-in-Chief<a hidden class=anchor aria-hidden=true href=#72--event-loop-the-scheduler-in-chief>#</a></h3><p>At the heart of this system is the <strong>event loop</strong>, the mechanism that:</p><ol><li><strong>Waits</strong> for the stack to be empty</li><li><strong>Pulls the next job</strong> from the queue</li><li><strong>Executes</strong> it entirely before moving on</li></ol><p>This is the <strong>run-to-completion guarantee</strong>.</p><p>ğŸ’¡ <strong>Why it matters</strong>:</p><ul><li>No two callbacks ever run at the same time</li><li>Shared variables are safe during a job</li><li>Your program stays predictable and easy to reason about</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;A&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;B&#34;</span><span class=p>),</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;C&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Output:
</span></span></span><span class=line><span class=cl><span class=c1>// A
</span></span></span><span class=line><span class=cl><span class=c1>// C
</span></span></span><span class=line><span class=cl><span class=c1>// B
</span></span></span></code></pre></div><p>ğŸ” Even though the timer is 0ms, it gets queued as a <em>job</em> and only runs <em>after</em> current code finishes.</p><hr><h3 id=73--microtasks-vs-macrotasks>7.3 âš–ï¸ Microtasks vs Macrotasks<a hidden class=anchor aria-hidden=true href=#73--microtasks-vs-macrotasks>#</a></h3><p>Not all jobs are equal. The queue is actually two queues:</p><table><thead><tr><th>Type</th><th>Examples</th><th>Priority</th></tr></thead><tbody><tr><td><strong>Microtasks</strong></td><td><code>Promise.then</code>, <code>queueMicrotask()</code></td><td>ğŸ”¥ High (drained first)</td></tr><tr><td><strong>Macrotasks</strong></td><td><code>setTimeout</code>, <code>setInterval</code>, DOM events</td><td>â³ Lower</td></tr></tbody></table><p>After every job (macro or otherwise), the event loop <strong>drains all microtasks</strong> before running the next macro task.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Start&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Timeout&#34;</span><span class=p>),</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nb>Promise</span><span class=p>.</span><span class=nx>resolve</span><span class=p>().</span><span class=nx>then</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Promise&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;End&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Output:
</span></span></span><span class=line><span class=cl><span class=c1>// Start
</span></span></span><span class=line><span class=cl><span class=c1>// End
</span></span></span><span class=line><span class=cl><span class=c1>// Promise
</span></span></span><span class=line><span class=cl><span class=c1>// Timeout
</span></span></span></code></pre></div><p>ğŸ“Œ <strong>Microtasks are prioritized</strong> â€” even over timers.</p><p>ğŸ§  <strong>Metaphor</strong>:<br>Microtasks are sticky notes on your desk. Macrotasks are meetings. After finishing a job (macro), JS clears all sticky notes (micro) before going to the next meeting.</p><hr><h3 id=74--blocking-vs-non-blocking>7.4 ğŸ§µ Blocking vs Non-Blocking<a hidden class=anchor aria-hidden=true href=#74--blocking-vs-non-blocking>#</a></h3><p>JS&rsquo;s single-threaded nature means <strong>blocking is dangerous</strong> â€” if your code stalls, your UI freezes, your app becomes unresponsive.</p><p>âœ… Async I/O â€” like <code>fetch</code>, <code>setTimeout</code>, <code>readFile</code> â€” is non-blocking by design.</p><p>ğŸš« But legacy APIs can <em>block the agent</em> entirely:</p><table><thead><tr><th>API</th><th>Behavior</th></tr></thead><tbody><tr><td><code>alert()</code></td><td>Blocks entire tab</td></tr><tr><td><code>confirm()</code></td><td>Blocking</td></tr><tr><td><code>XMLHttpRequest</code> (sync)</td><td>Blocking</td></tr></tbody></table><p>ğŸ’¡ Even <code>while(true){}</code> loops will freeze your app.</p><p>ğŸ” <strong>Modern JavaScript avoids blocking at all costs</strong> by using:</p><ul><li>The <strong>event loop</strong></li><li>The <strong>job queue</strong></li><li>And a <strong>non-blocking I/O model</strong></li></ul><hr><h3 id=-final-mental-model>ğŸ’¡ Final Mental Model<a hidden class=anchor aria-hidden=true href=#-final-mental-model>#</a></h3><p>Visualize JavaScript as a factory:</p><ul><li>ğŸ—ï¸ <strong>Call Stack</strong>: The active workstation (only one at a time)</li><li>ğŸ“¬ <strong>Job Queue</strong>: A mailbox full of tasks to run</li><li>ğŸ” <strong>Event Loop</strong>: A robot that:<ul><li>Waits for the workstation to be free</li><li>Picks the next job from the mailbox</li><li>Ensures no job starts until the last one finishes</li></ul></li></ul><p>And among the jobs:</p><ul><li>ğŸ“ <strong>Microtasks</strong> are urgent memos â€” always read before any new mail.</li><li>â° <strong>Macrotasks</strong> are full packages â€” scheduled deliveries that wait their turn.</li></ul><p>This model gives JS its magic mix of <strong>simplicity + power</strong>:</p><ul><li>Single-threaded but never frozen (if you follow the rules)</li><li>Predictable execution with async capabilities</li><li>Safe by default, powerful when needed</li></ul><hr><p>Next time you wonder <em>why Promises beat timers</em>, or <em>why your UI freezes</em>, or <em>why <code>console.log</code> shows up before your <code>setTimeout</code></em>, remember:<br>Youâ€™re not just writing code â€” youâ€™re orchestrating a symphony of jobs in a beautifully synchronized single-threaded engine.</p><hr><h2 id=8--concurrency--memory-sharing>8. ğŸ§  <strong>Concurrency & Memory Sharing</strong><a hidden class=anchor aria-hidden=true href=#8--concurrency--memory-sharing>#</a></h2><p>In the world of JavaScript, we often talk about <em>single-threaded execution</em>, the <em>event loop</em>, and <em>asynchronous callbacks</em>. But what happens when multiple threadsâ€”<em>agents</em>, in ECMAScript speakâ€”need to <strong>share memory and coordinate</strong>? Thatâ€™s where <strong>agent clusters</strong>, <strong>shared memory</strong>, and <strong>atomic operations</strong> come in.</p><p>This section dives into JavaScriptâ€™s <em>low-level concurrency primitives</em>, showing how modern engines manage <strong>parallelism</strong> safely using shared memory, and how developers can reason about memory consistency, data races, and synchronization.</p><hr><h3 id=81--agent-clusters-who-can-share-memory-with-whom>8.1 âš¡ <strong>Agent Clusters: Who Can Share Memory with Whom?</strong><a hidden class=anchor aria-hidden=true href=#81--agent-clusters-who-can-share-memory-with-whom>#</a></h3><p>In JavaScript, every independent execution contextâ€”like a tab, worker, or iframeâ€”is called an <strong>agent</strong>. But not all agents are created equal. Only some can <strong>share memory</strong>.</p><p>Agents that can share memory form what&rsquo;s called an <strong>agent cluster</strong>.</p><blockquote><p>ğŸ§  <strong>Core Rule:</strong> If two agents can share a <code>SharedArrayBuffer</code>, they belong to the same cluster. If not, they are <strong>completely isolated</strong>.</p></blockquote><h4 id=-in-the-same-cluster-can-share-memory>âœ… In the Same Cluster (can share memory):<a hidden class=anchor aria-hidden=true href=#-in-the-same-cluster-can-share-memory>#</a></h4><ul><li>A <strong>Window</strong> and the <strong>Dedicated Worker</strong> it creates</li><li>A <strong>Worker</strong> and the <strong>Dedicated Worker</strong> it spawns</li><li>A <strong>Window</strong> and a <strong>same-origin iframe</strong></li><li>A <strong>Window</strong> and a <strong>same-origin opener window</strong></li><li>A <strong>Window</strong> and its <strong>Worklet</strong></li></ul><h4 id=-different-clusters-cant-share-memory>âŒ Different Clusters (canâ€™t share memory):<a hidden class=anchor aria-hidden=true href=#-different-clusters-cant-share-memory>#</a></h4><ul><li>A <strong>Window</strong> and a <strong>SharedWorker</strong></li><li>A <strong>Window</strong> and a <strong>ServiceWorker</strong></li><li>A <strong>Worker</strong> and a <strong>SharedWorker</strong></li><li>Two <strong>unrelated</strong> same-origin <code>Window</code> objects</li><li>A <strong>Window</strong> and a <strong>cross-origin iframe</strong></li></ul><p>Think of <strong>agent clusters</strong> like secure bubbles. If two agents are in the same bubble, they can point to the same memory. If not, even passing a reference is forbidden.</p><hr><h3 id=82--shared-memory-with-sharedarraybuffer>8.2 ğŸ§  <strong>Shared Memory with SharedArrayBuffer</strong><a hidden class=anchor aria-hidden=true href=#82--shared-memory-with-sharedarraybuffer>#</a></h3><p>JavaScript is traditionally <strong>copy-by-value</strong> when agents communicate. Thatâ€™s how <code>postMessage()</code> works: it sends a <strong>structured clone</strong> of the data.</p><p>But thereâ€™s one exception: <strong><code>SharedArrayBuffer</code></strong>.</p><blockquote><p>ğŸ§¬ Metaphor: Normally, you&rsquo;re emailing someone a <em>photocopy</em> of your notebook. With <code>SharedArrayBuffer</code>, you&rsquo;re giving them the <em>same notebook</em>, and now you both can write in itâ€”simultaneously.</p></blockquote><h4 id=-how-it-works>ğŸ”— How It Works:<a hidden class=anchor aria-hidden=true href=#-how-it-works>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>sab</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>SharedArrayBuffer</span><span class=p>(</span><span class=mi>1024</span><span class=p>);</span> <span class=c1>// shared memory
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>view</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Int32Array</span><span class=p>(</span><span class=nx>sab</span><span class=p>);</span>        <span class=c1>// typed view
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>worker</span><span class=p>.</span><span class=nx>postMessage</span><span class=p>(</span><span class=nx>sab</span><span class=p>);</span> <span class=c1>// no clone â€” both now point to the same memory
</span></span></span></code></pre></div><p>Now both the main thread and the worker share that memory. But shared access means <strong>concurrent access</strong>, and that leads us toâ€¦</p><hr><h3 id=83--synchronizing-with-atomics>8.3 ğŸ”’ <strong>Synchronizing with Atomics</strong><a hidden class=anchor aria-hidden=true href=#83--synchronizing-with-atomics>#</a></h3><p>Just because memory is shared doesnâ€™t mean itâ€™s safe.</p><blockquote><p>ğŸ§  Regular JS assignments like <code>arr[0] = arr[0] + 1</code> are <strong>not atomic</strong> and can be torn apart when run from two agents at once.</p></blockquote><p>Thatâ€™s why ECMAScript gives us <strong><code>Atomics</code></strong>: a namespace of operations that <strong>guarantee safe, lock-free memory coordination</strong>.</p><h4 id=-tools-in-the-atomics-toolbox>ğŸ›  Tools in the <code>Atomics</code> toolbox:<a hidden class=anchor aria-hidden=true href=#-tools-in-the-atomics-toolbox>#</a></h4><ul><li><code>Atomics.load(view, index)</code> â€” safely read</li><li><code>Atomics.store(view, index, value)</code> â€” safely write</li><li><code>Atomics.add</code>, <code>sub</code>, <code>and</code>, <code>or</code>, <code>xor</code>, etc. â€” read-modify-write</li><li><code>Atomics.wait(view, index, value)</code> â€” <strong>block</strong> until value changes</li><li><code>Atomics.notify(view, index, count)</code> â€” wake up blocked agents</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// Thread 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>while</span> <span class=p>(</span><span class=nx>Atomics</span><span class=p>.</span><span class=nx>load</span><span class=p>(</span><span class=nx>view</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>!==</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>Atomics</span><span class=p>.</span><span class=nx>wait</span><span class=p>(</span><span class=nx>view</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span> <span class=c1>// wait until someone sets it to 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Thread 2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>Atomics</span><span class=p>.</span><span class=nx>store</span><span class=p>(</span><span class=nx>view</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>Atomics</span><span class=p>.</span><span class=nx>notify</span><span class=p>(</span><span class=nx>view</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span></code></pre></div><p>This pattern enables <strong>thread-style coordination</strong> between agents â€” like building your own semaphores or locks.</p><blockquote><p>âš ï¸ Only <strong>dedicated</strong> or <strong>shared workers</strong> can be blocked using <code>Atomics.wait()</code>. Windows and service workers are never allowed to block.</p></blockquote><hr><h3 id=84--memory-consistency-and-data-races>8.4 ğŸ“ <strong>Memory Consistency and Data Races</strong><a hidden class=anchor aria-hidden=true href=#84--memory-consistency-and-data-races>#</a></h3><p>JavaScriptâ€™s memory model ensures <strong>predictable behavior</strong> only if you follow certain rules.</p><blockquote><p>âœ… <strong>Data raceâ€“free = safe, consistent, sequential semantics</strong><br>âŒ Data races = torn values, weird bugs, and undefined behavior</p></blockquote><h4 id=-whats-a-data-race>âš ï¸ Whatâ€™s a Data Race?<a hidden class=anchor aria-hidden=true href=#-whats-a-data-race>#</a></h4><p>When <strong>two agents</strong> access the <strong>same memory location</strong> at the <strong>same time</strong>, and at least one of them writes, <em>without proper synchronization</em>.</p><h4 id=-example-of-value-tearing>ğŸ§ª Example of value tearing:<a hidden class=anchor aria-hidden=true href=#-example-of-value-tearing>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// One agent writes a 32-bit int
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mh>0x12345678</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Another agent reads only the first 16 bits mid-write
</span></span></span></code></pre></div><p>Result? You read a garbage value like <code>0x12340000</code>. Thatâ€™s <strong>value tearing</strong>.</p><h4 id=-rule-of-thumb>ğŸ”’ Rule of Thumb:<a hidden class=anchor aria-hidden=true href=#-rule-of-thumb>#</a></h4><ul><li>Always access shared memory via <strong><code>Atomics</code></strong>.</li><li>Use the <strong>same access size</strong> and <strong>typed array</strong> across all agents.</li><li>Avoid mixing atomic and non-atomic operations on the same memory cell.</li></ul><hr><h3 id=-why-this-matters-1>ğŸ§  Why This Matters<a hidden class=anchor aria-hidden=true href=#-why-this-matters-1>#</a></h3><p>Shared memory gives us <strong>high-performance parallelism</strong> in JavaScript â€” without blocking the main thread.</p><p>But it comes with the responsibility of:</p><ul><li>Defining clear communication patterns</li><li>Designing for <strong>race-freedom</strong></li><li>Understanding that <code>postMessage()</code> â‰  shared memory unless you use <code>SharedArrayBuffer</code></li><li>Avoiding subtle bugs from <strong>cross-agent memory inconsistencies</strong></li></ul><hr><h3 id=-in-summary>ğŸ“¦ In Summary<a hidden class=anchor aria-hidden=true href=#-in-summary>#</a></h3><table><thead><tr><th>Concept</th><th>Description</th></tr></thead><tbody><tr><td><strong>Agent Cluster</strong></td><td>Group of JS agents that can share memory</td></tr><tr><td><strong>SharedArrayBuffer</strong></td><td>Enables memory sharing between agents</td></tr><tr><td><strong>Atomics</strong></td><td>Enables safe, lock-free communication on shared memory</td></tr><tr><td><strong>Data Race</strong></td><td>When agents read/write same memory without sync</td></tr><tr><td><strong>Sequential Consistency</strong></td><td>All agents see memory changes in the same order if no races</td></tr></tbody></table><hr><h3 id=-final-thought>ğŸ’­ Final Thought<a hidden class=anchor aria-hidden=true href=#-final-thought>#</a></h3><p>The introduction of shared memory and <code>Atomics</code> fundamentally changes what JavaScript is capable of â€” enabling <strong>parallel algorithms</strong>, <strong>real-time audio processing</strong>, and <strong>high-throughput computation</strong>. But it also demands a new level of rigor. Just as <code>Promise</code> taught us to think about <strong>time</strong>, <code>SharedArrayBuffer</code> and <code>Atomics</code> teach us to think about <strong>space</strong> â€” and how multiple minds can share the same thoughts without stepping on each otherâ€™s toes.</p><p>Welcome to the world of <strong>concurrent JavaScript</strong> â€” where your variables can now live in more than one mind at once.</p><hr><h2 id=9--cluster-lifecycle--blocking>9. ğŸš§ Cluster Lifecycle & Blocking<a hidden class=anchor aria-hidden=true href=#9--cluster-lifecycle--blocking>#</a></h2><p>Modern JavaScript engines have evolved into distributed runtimes. And yet, most developers still think in terms of <em>&ldquo;single-threaded async code&rdquo;</em>. But under the hood, <strong>agents</strong>, <strong>clusters</strong>, and <strong>shared memory</strong> enable fine-grained concurrency.</p><p>This section explores what really happens when JS environments start talking â€” and blocking â€” across boundaries.</p><hr><h3 id=91--blocking-apis-atomicswait>9.1. ğŸ§± Blocking APIs (<code>Atomics.wait</code>)<a hidden class=anchor aria-hidden=true href=#91--blocking-apis-atomicswait>#</a></h3><h4 id=-what-does-blocking-actually-mean-in-javascript>ğŸ§  What does &ldquo;blocking&rdquo; <em>actually</em> mean in JavaScript?<a hidden class=anchor aria-hidden=true href=#-what-does-blocking-actually-mean-in-javascript>#</a></h4><p>Weâ€™re used to <code>await</code> yielding control â€” letting the event loop breathe. But <code>Atomics.wait()</code>? Thatâ€™s a different beast.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>Atomics</span><span class=p>.</span><span class=nx>wait</span><span class=p>(</span><span class=nx>int32Array</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span> <span class=c1>// ğŸ’¥ BLOCKS the agent
</span></span></span></code></pre></div><p>This is <strong>not like Promises</strong>. It <strong>completely freezes</strong> the thread.</p><h4 id=-promise--async-yield>âœ… Promise = async yield<a hidden class=anchor aria-hidden=true href=#-promise--async-yield>#</a></h4><ul><li>Returns control to the event loop</li><li>Lets other jobs run while waiting</li></ul><h4 id=-atomicswait--sync-block>âŒ Atomics.wait = sync block<a hidden class=anchor aria-hidden=true href=#-atomicswait--sync-block>#</a></h4><ul><li>Halts everything in that agent (no event loop progress)</li><li>Nothing else in that thread runs until another agent calls <code>Atomics.notify</code></li></ul><p>ğŸ§¬ <strong>Mental Model</strong>:<br>A waiter (Promise) steps aside while the kitchen runs. A locked door (Atomics.wait) freezes the kitchen until someone unlocks it.</p><hr><h3 id=92--forward-progress-guarantees>9.2. ğŸ›¡ Forward Progress Guarantees<a hidden class=anchor aria-hidden=true href=#92--forward-progress-guarantees>#</a></h3><p>Concurrency is dangerous â€” race conditions, deadlocks, and starvation are real risks.</p><p>Thatâ€™s why <strong>ECMAScript enforces forward progress</strong> guarantees, even in multi-agent systems.</p><blockquote><p>If multiple agents share the same thread, the runtime must ensure <strong>no agent starves forever.</strong></p></blockquote><h4 id=-fairness-by-design>ğŸ’¡ Fairness by design:<a hidden class=anchor aria-hidden=true href=#-fairness-by-design>#</a></h4><ul><li>The engine cannot ignore one agent just because another is busy.</li><li>Even if two agents are blocking each other via Atomics, the spec mandates that <em>some</em> agent makes progress.</li></ul><h4 id=-why-this-matters-2>ğŸ“¦ Why this matters:<a hidden class=anchor aria-hidden=true href=#-why-this-matters-2>#</a></h4><p>Imagine two workers sharing memory. If worker A holds a lock and gets suspended forever, and worker B is waiting to acquire it â€” youâ€™ve just created a distributed deadlock.</p><p>The JavaScript memory model <strong>prevents</strong> that scenario by <strong>ensuring all agents in a cluster eventually get time to run</strong>.</p><p>ğŸ§  <strong>Intuition</strong>: Even in tight concurrency loops, JavaScript wonâ€™t let one agent monopolize the thread indefinitely.</p><hr><h3 id=93--agent-termination-the-cluster-is-a-single-failure-domain>9.3. ğŸ’¥ Agent Termination: The Cluster Is a Single Failure Domain<a hidden class=anchor aria-hidden=true href=#93--agent-termination-the-cluster-is-a-single-failure-domain>#</a></h3><blockquote><p>Terminate one agent in a cluster, and you <strong>kill them all</strong>.</p></blockquote><p>This is one of the lesser-known â€” but crucial â€” constraints of <strong>agent clusters</strong>.</p><h4 id=-if-agents-share-memory-theyre-in-the-same-cluster>âœ… If agents share memory, theyâ€™re in the same cluster.<a hidden class=anchor aria-hidden=true href=#-if-agents-share-memory-theyre-in-the-same-cluster>#</a></h4><h4 id=-if-one-crashes-they-all-go-down>ğŸ”¥ If one crashes, they <em>all</em> go down.<a hidden class=anchor aria-hidden=true href=#-if-one-crashes-they-all-go-down>#</a></h4><p>Why?</p><p>Because allowing a shared-memory cluster to continue operating with a missing participant would:</p><ul><li>Risk <strong>memory corruption</strong></li><li>Break <strong>lock semantics</strong></li><li>Violate <strong>deterministic state models</strong></li></ul><p>ğŸ§¬ <strong>System-level analogy</strong>: Imagine a nuclear power grid with interdependent control units. If one node goes offline during a write, the entire system must halt to avoid undefined behavior.</p><h4 id=-what-about-fault-tolerance>ğŸ§ª What about fault-tolerance?<a hidden class=anchor aria-hidden=true href=#-what-about-fault-tolerance>#</a></h4><p>Interestingly, the ECMAScript spec <em>mentions</em> a second strategy: detect a terminated agent and let others recover.</p><p>But:</p><ul><li>ğŸ”’ Itâ€™s <strong>not implemented in any browser</strong></li><li>ğŸ›  Still a theoretical model â€” not production-grade yet</li></ul><hr><h2 id=-takeaways-for-system-builders>âš ï¸ Takeaways for System Builders<a hidden class=anchor aria-hidden=true href=#-takeaways-for-system-builders>#</a></h2><p>If youâ€™re using <code>SharedArrayBuffer</code>, <code>Atomics</code>, or any worker model with shared memory:</p><ul><li>âœ… Understand <strong>agent clusters</strong>: memory sharing defines membership</li><li>ğŸ§  Donâ€™t rely on <code>postMessage</code> for real concurrency â€” use SAB + Atomics intentionally</li><li>ğŸ›‘ Avoid assuming you can recover from crashes inside a cluster â€” you <em>canâ€™t</em> (yet)</li><li>ğŸ§µ Be aware of blocking: Promises = cooperative, Atomics = hard locks</li></ul><hr><p>ğŸ“Œ <strong>Final Thought</strong>:<br>Shared memory brings <strong>power</strong> â€” and <strong>responsibility</strong>. Youâ€™re no longer in JavaScriptâ€™s comfy async sandbox. Youâ€™re in systems-land now â€” where deadlocks, race conditions, and cluster-wide failure are real threats.</p><p>Use the power. Know the cost.</p><hr><h2 id=-10-putting-it-all-together>ğŸ”— 10. <strong>Putting It All Together</strong><a hidden class=anchor aria-hidden=true href=#-10-putting-it-all-together>#</a></h2><hr><h3 id=-why-this-section-matters>ğŸ¯ Why this section matters:<a hidden class=anchor aria-hidden=true href=#-why-this-section-matters>#</a></h3><p>Everything weâ€™ve explored â€” stacks, heaps, queues, jobs, realms, agents, workers, shared memory â€” now comes together into a unified execution trace. This is where theory meets runtime. This is where <em>your intuition levels up</em>.</p><hr><h3 id=101--full-execution-trace>10.1 âš™ï¸ <strong>Full Execution Trace</strong><a hidden class=anchor aria-hidden=true href=#101--full-execution-trace>#</a></h3><p>Letâ€™s simulate a complete run of a JavaScript program involving:</p><ul><li>ğŸ§  <strong>Synchronous execution</strong> (stack)</li><li>â° <strong>setTimeout</strong> (macro-task queue)</li><li>ğŸ’¬ <strong>Promise</strong> (microtask queue)</li><li>ğŸ” <strong>Nested function calls</strong></li><li>ğŸ”„ <strong>Event loop orchestration</strong></li></ul><hr><h4 id=-code-example>ğŸ’» Code Example:<a hidden class=anchor aria-hidden=true href=#-code-example>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Start&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Timeout 1&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>},</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>Promise</span><span class=p>.</span><span class=nx>resolve</span><span class=p>().</span><span class=nx>then</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Promise 1&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;End&#34;</span><span class=p>);</span>
</span></span></code></pre></div><hr><h3 id=-execution-timeline>ğŸ” Execution Timeline<a hidden class=anchor aria-hidden=true href=#-execution-timeline>#</a></h3><table><thead><tr><th>Step</th><th>Stack</th><th>Microtask Queue</th><th>Task Queue</th><th>Output</th></tr></thead><tbody><tr><td>1</td><td><code>global()</code></td><td></td><td></td><td></td></tr><tr><td>2</td><td>log(&ldquo;Start&rdquo;)</td><td></td><td></td><td>Start</td></tr><tr><td>3</td><td>setTimeout(&mldr;)</td><td></td><td>[Timeout callback]</td><td></td></tr><tr><td>4</td><td>Promise.then(&mldr;)</td><td>[Promise callback]</td><td>[Timeout callback]</td><td></td></tr><tr><td>5</td><td>log(&ldquo;End&rdquo;)</td><td>[Promise callback]</td><td>[Timeout callback]</td><td>End</td></tr><tr><td>6</td><td>Execute microtask</td><td>[]</td><td>[Timeout callback]</td><td>Promise 1</td></tr><tr><td>7</td><td>Execute macro task</td><td>[]</td><td>[]</td><td>Timeout 1</td></tr></tbody></table><hr><h3 id=-metaphor-1>ğŸ§  Metaphor:<a hidden class=anchor aria-hidden=true href=#-metaphor-1>#</a></h3><ul><li><strong>Call stack</strong> is your desk â€” only one function open at a time.</li><li><strong>Microtasks</strong> are sticky notes stuck to the monitor â€” you handle them <strong>after the current task</strong>, but <strong>before</strong> picking a new one from the task queue.</li><li><strong>Macro-tasks (setTimeout)</strong> are tasks waiting in your inbox â€” they only get attention <strong>after all microtasks are done</strong>.</li></ul><hr><h3 id=-connections>ğŸ”— Connections<a hidden class=anchor aria-hidden=true href=#-connections>#</a></h3><ul><li><strong>Stack</strong>: Tracks what code is currently running.</li><li><strong>Heap</strong>: Stores <code>Promise</code>, callback functions.</li><li><strong>Job Queue</strong>: Schedules promise callbacks (microtasks).</li><li><strong>Task Queue</strong>: Schedules <code>setTimeout</code>, events (macro-tasks).</li><li><strong>Event Loop</strong>: Pulls from microtask â†’ then macro â†’ repeat.</li></ul><hr><h3 id=-subtle-gotchas>ğŸ§¬ Subtle Gotchas<a hidden class=anchor aria-hidden=true href=#-subtle-gotchas>#</a></h3><ul><li><code>Promise.then</code> always runs <strong>before</strong> <code>setTimeout</code>, even if <code>setTimeout</code> has 0ms delay.</li><li>This is because <strong>microtask queue</strong> is prioritized over <strong>macro-task queue</strong>.</li></ul><hr><h3 id=102--mental-models--visuals>10.2 ğŸ§  <strong>Mental Models & Visuals</strong><a hidden class=anchor aria-hidden=true href=#102--mental-models--visuals>#</a></h3><hr><h3 id=-timeline-diagram>ğŸ“Š Timeline Diagram<a hidden class=anchor aria-hidden=true href=#-timeline-diagram>#</a></h3><pre tabindex=0><code>Time â†’
| Stack: log(&#34;Start&#34;)      â†’ log(&#34;End&#34;)        â†’ [Empty]
| Microtask:               â†’ Promise.then()    â†’ [Empty]
| Task:     setTimeout()   â†’                  â†’ setTimeout()
Output:
Start
End
Promise 1
Timeout 1
</code></pre><hr><h3 id=-stackheapqueue-visualization>ğŸ§© Stackâ€“Heapâ€“Queue Visualization<a hidden class=anchor aria-hidden=true href=#-stackheapqueue-visualization>#</a></h3><pre tabindex=0><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Call Stack      â”‚ â† Runs synchronous code (one frame at a time)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Global Execution   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        Heap          â”‚ â† Stores objects, closures, promises
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Promise, callbacksâ€¦  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     Microtask Q      â”‚ â† Promise callbacks (then, catch)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ () =&gt; console.logâ€¦   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     Task Queue       â”‚ â† Timers, UI events
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ setTimeout cbâ€¦       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre><hr><h3 id=-cross-realm--agent-flowchart>ğŸ§­ Cross-Realm & Agent Flowchart<a hidden class=anchor aria-hidden=true href=#-cross-realm--agent-flowchart>#</a></h3><pre tabindex=0><code>[ Window (Agent A) ]
     â”‚
     â”œâ”€ setTimeout()        â†’ Task Queue
     â”œâ”€ Promise.then()      â†’ Microtask Queue
     â”œâ”€ Web Worker (Agent B)
     â”‚     â”œâ”€ Own Heap
     â”‚     â”œâ”€ Own Stack
     â”‚     â””â”€ Communicates via postMessage or SharedArrayBuffer
     â”‚
     â””â”€ iframe (Realm B, same agent)
           â”œâ”€ Own GlobalThis
           â””â”€ Shared Stack/Queue (if same-origin)
</code></pre><hr><h3 id=-interview-insight>ğŸ¯ Interview Insight<a hidden class=anchor aria-hidden=true href=#-interview-insight>#</a></h3><p>If you truly understand this unified flow, you can:</p><ul><li>Predict async code output reliably.</li><li>Avoid callback hell and race conditions.</li><li>Understand Node.js concurrency patterns.</li><li>Handle shared memory in web workers safely.</li></ul><hr><h2 id=-final-thought-1>âœ… Final Thought<a hidden class=anchor aria-hidden=true href=#-final-thought-1>#</a></h2><p>JavaScript isnâ€™t just â€œsingle-threaded.â€<br>Itâ€™s a <strong>coordinated choreography</strong> of:</p><ul><li>Agents (runners)</li><li>Realms (universes)</li><li>Heaps (long-term memory)</li><li>Stacks (call trace)</li><li>Queues (scheduling)</li><li>Event loop (the director)</li></ul><p>Master this mental model, and you&rsquo;re not just writing JS â€” you&rsquo;re <strong>orchestrating time</strong>.</p><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://archit15singh.github.io/tags/javascript/>JavaScript</a></li><li><a href=https://archit15singh.github.io/tags/technical-deep-dive/>Technical Deep Dive</a></li></ul><nav class=paginav><a class=prev href=https://archit15singh.github.io/posts/minimal-test-post/><span class=title>Â« Prev Page</span><br><span>Minimal Test Post</span>
</a><a class=next href=https://archit15singh.github.io/posts/2022-07-29-test-post/><span class=title>Next Page Â»</span><br><span>Test Post</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive) on twitter" href="https://twitter.com/intent/tweet/?text=How%20JavaScript%20Really%20Runs%3a%20From%20Engines%20to%20Event%20Loop%20%28Execution%20Model%20Deep%20Dive%29&amp;url=https%3a%2f%2farchit15singh.github.io%2fposts%2f2022-07-29-js-execution-model-in-depth%2f&amp;hashtags=JavaScript%2cTechnicalDeepDive"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2farchit15singh.github.io%2fposts%2f2022-07-29-js-execution-model-in-depth%2f&amp;title=How%20JavaScript%20Really%20Runs%3a%20From%20Engines%20to%20Event%20Loop%20%28Execution%20Model%20Deep%20Dive%29&amp;summary=How%20JavaScript%20Really%20Runs%3a%20From%20Engines%20to%20Event%20Loop%20%28Execution%20Model%20Deep%20Dive%29&amp;source=https%3a%2f%2farchit15singh.github.io%2fposts%2f2022-07-29-js-execution-model-in-depth%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive) on reddit" href="https://reddit.com/submit?url=https%3a%2f%2farchit15singh.github.io%2fposts%2f2022-07-29-js-execution-model-in-depth%2f&title=How%20JavaScript%20Really%20Runs%3a%20From%20Engines%20to%20Event%20Loop%20%28Execution%20Model%20Deep%20Dive%29"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive) on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2farchit15singh.github.io%2fposts%2f2022-07-29-js-execution-model-in-depth%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive) on whatsapp" href="https://api.whatsapp.com/send?text=How%20JavaScript%20Really%20Runs%3a%20From%20Engines%20to%20Event%20Loop%20%28Execution%20Model%20Deep%20Dive%29%20-%20https%3a%2f%2farchit15singh.github.io%2fposts%2f2022-07-29-js-execution-model-in-depth%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive) on telegram" href="https://telegram.me/share/url?text=How%20JavaScript%20Really%20Runs%3a%20From%20Engines%20to%20Event%20Loop%20%28Execution%20Model%20Deep%20Dive%29&amp;url=https%3a%2f%2farchit15singh.github.io%2fposts%2f2022-07-29-js-execution-model-in-depth%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><div class=container><div class="content has-text-centered"><p><strong>Archit's Space</strong> - Sharing knowledge one post at a time.<br>Crafted with â¤ï¸ by Archit Singh</a>.<br>Connect with me on
<a href=https://github.com/archit15singh target=_blank>GitHub</a>,
<a href=https://www.linkedin.com/in/archit15singh target=_blank>LinkedIn</a>,
and <a href=https://twitter.com/archit15singh target=_blank>Twitter</a>.</p></div></div></footer><script data-goatcounter=https://architsingh.goatcounter.com/count async src=//gc.zgo.at/count.js></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>