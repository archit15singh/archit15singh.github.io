<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>JS execution model in depth | Archit's Space</title>
<meta name=keywords content="JavaScript,JavaScript Execution Model"><meta name=description content="An in-depth breakdown of the JS execution model"><meta name=author content="Archit Singh"><link rel=canonical href=https://archit15singh.github.io/posts/2022-07-29-js-execution-model-in-depth/><link crossorigin=anonymous href=/assets/css/stylesheet.min.1c5241cc5c31e8a1af5a56caa332bfa60cee35277d8fb31c7063ca9ed7258093.css integrity="sha256-HFJBzFwx6KGvWlbKozK/pgzuNSd9j7MccGPKntclgJM=" rel="preload stylesheet" as=style><link rel=icon href=https://archit15singh.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://archit15singh.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://archit15singh.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://archit15singh.github.io/apple-touch-icon.png><link rel=mask-icon href=https://archit15singh.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.145.0"><link rel=alternate hreflang=en href=https://archit15singh.github.io/posts/2022-07-29-js-execution-model-in-depth/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="JS execution model in depth"><meta property="og:description" content="An in-depth breakdown of the JS execution model"><meta property="og:type" content="article"><meta property="og:url" content="https://archit15singh.github.io/posts/2022-07-29-js-execution-model-in-depth/"><meta property="og:image" content="https://archit15singh.github.io/images/uploads/cosmic-timetraveler.webp"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-29T12:00:00+00:00"><meta property="article:modified_time" content="2022-07-29T12:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://archit15singh.github.io/images/uploads/cosmic-timetraveler.webp"><meta name=twitter:title content="JS execution model in depth"><meta name=twitter:description content="An in-depth breakdown of the JS execution model"><meta name=twitter:site content="@https://twitter.com/archit_singh15"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://archit15singh.github.io/posts/"},{"@type":"ListItem","position":2,"name":"JS execution model in depth","item":"https://archit15singh.github.io/posts/2022-07-29-js-execution-model-in-depth/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"JS execution model in depth","name":"JS execution model in depth","description":"An in-depth breakdown of the JS execution model","keywords":["JavaScript","JavaScript Execution Model"],"articleBody":"JS execution model Alright, let’s break this down recursively and deeply, line by line, starting with the JavaScript execution model intro and progressing through the first sections. I’ll give you:\nLiteral meaning (What it says) Deeper understanding (Why it matters) Mental model / real-world analogy (To cement intuition) 📘 “JavaScript execution model” ✅ Literal meaning: This document explains how JavaScript runs behind the scenes — how it processes code, manages memory, handles functions, etc.\n🔍 Deeper understanding: Think of this as the operating system of JavaScript — what actually happens when you write let a = 5 or setTimeout(...).\n🧠 Analogy: If your code is like a script in a play, the execution model is the stage manager deciding when and how each line of the script gets read and acted upon.\n📝 “This page introduces the basic infrastructure of the JavaScript runtime environment.” ✅ Literal meaning: We’re talking about the runtime — where JS code is executed (not compiled). This includes things like memory, stacks, event loops, etc.\n🔍 Deeper understanding: JavaScript isn’t just interpreted randomly. There’s a whole structure that controls how code gets parsed, run, paused, resumed.\n🧠 Analogy: Imagine a kitchen: the runtime is the kitchen itself (countertop = stack, fridge = heap, bell = job queue). Chefs = JavaScript agents.\n🛠 “The model is largely theoretical and abstract, without any platform-specific or implementation-specific details.” ✅ Literal meaning: This isn’t about Chrome’s V8 engine or Node’s internals — it’s the universal, spec-level blueprint.\n🔍 Deeper understanding: You’re learning how things should behave according to ECMAScript — the spec all JS engines follow (more or less).\n🧠 Analogy: Like learning the rules of chess, not how Magnus Carlsen plays.\n🧠 “Modern JavaScript engines heavily optimize the described semantics.” ✅ Literal meaning: Real engines like V8 or SpiderMonkey tweak things under the hood for speed, but they follow the same rules.\n🔍 Deeper understanding: JS engines may compile JS to bytecode, inline functions, optimize away allocations — but logically, they obey this model.\n🧠 Analogy: Like a Formula 1 pit crew following safety rules — they do things super fast, but not incorrectly.\n📖 “This page is a reference. It assumes you are already familiar with the execution model of other programming languages, such as C and Java.” ✅ Literal meaning: If you’ve worked with languages that have stacks, heaps, and memory — this will feel familiar.\n🔍 Deeper understanding: JS is dynamic and event-driven, but under the hood, it’s not that different from C/Java — it just hides more from you.\n🧠 Analogy: It’s like someone who’s driven automatic cars learning how a manual transmission works under the hood.\n🔧 “It makes heavy references to existing concepts in operating systems and programming languages.” ✅ Literal meaning: Terms like stack, heap, queue, thread — all come from OS/PL theory.\n🔍 Deeper understanding: This section connects JS to how all programming languages manage code execution and memory.\n🧠 Analogy: It’s like learning JavaScript’s “internals” by understanding its plumbing — threads, memory, job queues.\nNext section…\n🔥 The engine and the host 🧩 “JavaScript execution requires the cooperation of two pieces of software: the JavaScript engine and the host environment.” ✅ Literal meaning: JS doesn’t run on its own. It needs:\nA JS engine (like V8, SpiderMonkey) A host (like the browser or Node) 🔍 Deeper understanding: The engine knows how to parse and run JavaScript. The host (browser/Node) knows how to give JS things to do — like making network requests or rendering HTML.\n🧠 Analogy: The JS engine is the actor. The host is the stage, props, lighting, and audience.\n🧠 “The JavaScript engine implements the ECMAScript (JavaScript) language, providing the core functionality.” ✅ Literal meaning: The engine knows what let, function, Promise, etc., mean. That’s ECMAScript.\n🔍 Deeper understanding: Things like setTimeout or document.querySelector? Those are host-provided, not part of the language spec.\n🧠 Analogy: The engine knows English. The host gives it a job — like reading a book, or talking to a user.\n🌍 “In order to interact with the outside world […] we need additional environment-specific mechanisms provided by the host environment.” ✅ Literal meaning: To talk to files, web APIs, timers, you need help from the host — JS alone can’t do it.\n🔍 Deeper understanding: This is where browsers give us document, and Node gives us fs, etc. It’s why JS looks different in each environment.\n🧠 Analogy: JavaScript is a brilliant chef, but it needs the host to supply groceries, an oven, or even the guests to cook for.\n🌐 “For example, the HTML DOM is the host environment when JavaScript is executed in a web browser. Node.js is another host environment…” ✅ Literal meaning: DOM and window exist only in the browser. require and process exist only in Node.\n🔍 Deeper understanding: Same language, different surroundings = different power/tools. JS is host-agnostic; host APIs change.\n🧠 Analogy: Same actor, different movie set. A sci-fi set vs. a historical drama set gives the actor different things to interact with.\nAwesome — let’s dive into a line-by-line, recursive breakdown of the JavaScript Execution Model section. I’ll break down each sentence, unpack the underlying concepts, and relate them to real-world analogies and code where helpful.\n🔹JavaScript execution model This page introduces the basic infrastructure of the JavaScript runtime environment.\nBreakdown: We’re about to learn how JavaScript runs “under the hood.” That means looking beyond syntax into how your code gets executed, managed, and scheduled by the JS engine. The model is largely theoretical and abstract, without any platform-specific or implementation-specific details.\nBreakdown: This is not about how Chrome, Node, or Deno implement JavaScript — it’s about the ECMAScript specification-level model. Think of this as the universal blueprint all JS engines follow. Modern JavaScript engines heavily optimize the described semantics.\nBreakdown: V8 (Chrome), SpiderMonkey (Firefox), and others add many performance improvements — JIT compilation, inlining, hidden classes — but they preserve the behavior defined in this theoretical model. 🔹This page is a reference. It assumes you are already familiar with the execution model of other programming languages, such as C and Java. Breakdown: It expects you know what a call stack, heap, and execution context are from other languages — but don’t worry, we’ll unpack everything from a JavaScript-first view. 🔹The engine and the host JavaScript execution requires the cooperation of two pieces of software: the JavaScript engine and the host environment.\nBreakdown: Engine → Understands \u0026 runs JS (e.g. V8, SpiderMonkey). Host → Provides APIs outside of JS (e.g., the DOM, setTimeout, fs in Node). 📌 Analogy: The engine is the actor, but the host is the stage, props, and audience.\nThe JavaScript engine implements the ECMAScript (JavaScript) language, providing the core functionality. It takes source code, parses it, and executes it.\nBreakdown: Parses → Converts your code into an Abstract Syntax Tree (AST). Executes → Evaluates it via interpreters or compilers. let x = 5; Engine knows how to parse and execute this, but not how to access the DOM. That’s the host’s job. However, in order to interact with the outside world, such as to produce any meaningful output, to interface with external resources, or to implement security- or performance-related mechanisms, we need additional environment-specific mechanisms provided by the host environment.\nBreakdown: Engine alone can’t do I/O, networking, file access. Host provides: console.log, fetch, setTimeout, document, process.env, etc. For example, the HTML DOM is the host environment when JavaScript is executed in a web browser. Node.js is another host environment that allows JavaScript to be run on the server side.\nBreakdown: Browser = JS engine + DOM + window + events. Node = JS engine + fs, http, Buffer, process, etc. While we focus primarily on the mechanisms defined in ECMAScript in this reference, we will occasionally talk about mechanisms defined in the HTML spec, which is often mimicked by other host environments like Node.js or Deno.\nBreakdown: Core focus = ECMAScript (language spec). But we’ll touch on HTML-defined behaviors (like the Event Loop, microtasks) — because Node/Deno borrow them too. 🔹Agent Execution Model In the JavaScript specification, each autonomous executor of JavaScript is called an agent, which maintains its facilities for code execution:\nBreakdown: Think of an agent as an independent “runner” of JavaScript — like a tab, worker, or Node thread. Each agent has its own heap, call stack, and job queue. Now, let’s recursively unpack the three components of an agent:\n🔸 Heap (of objects) This is just a name to denote a large (mostly unstructured) region of memory. It gets populated as objects get created in the program.\nBreakdown: Heap = where reference types live: objects, arrays, closures, functions. Variables like let obj = {} create entries in the heap. let obj = { name: \"you\" }; The object lives in the heap; obj points to it.\nNote that in the case of shared memory, each agent has its own heap with its own version of a SharedArrayBuffer object, but the underlying memory represented by the buffer is shared.\nBreakdown: Each worker/tab has its own isolated heap — but shared memory (via SharedArrayBuffer) creates cross-agent bridges. Shared memory enables atomic operations between agents. 📌 Think: Multiple agents → own memory → but one shared space for coordination.\n🔸 Queue (of jobs) This is known in HTML (and also commonly) as the event loop which enables asynchronous programming in JavaScript while being single-threaded.\nBreakdown: Queue = Job Queue / Task Queue. Works with the event loop to schedule async tasks (like setTimeout, Promises). It’s called a queue because it’s generally first-in-first-out: earlier jobs are executed before later ones.\nBreakdown: Classic FIFO structure. Tasks are queued and executed one by one, preserving order. 🔸 Stack (of execution contexts) This is what’s known as a call stack and allows transferring control flow by entering and exiting execution contexts like functions.\nBreakdown: Stack = execution history — functions being called and exited. LIFO — last-in, first-out. function a() { b(); } function b() { c(); } a(); // a → b → c → return → return → return It’s called a stack because it’s last-in-first-out. Every job enters by pushing a new frame onto the (empty) stack, and exits by emptying the stack.\nBreakdown: A function call pushes a frame onto the stack. When it returns, the frame is popped off. These are three distinct data structures that keep track of different data.\nHeap → Long-lived objects. Queue → Pending jobs (like fetch().then()). Stack → Current execution chain (call stack). We will introduce the queue and the stack in more detail in the following sections. To read more about how heap memory is allocated and freed, see memory management.\nBreakdown: Stack and queue will be our main focus because they control how code runs. Heap is for storage, not flow. 🧠 Up Next: We’ll dive into the next section — realms, agents on the web (workers, windows), and how these fit together using the diagram you shared.\nWant to continue into that next?\nAwesome — let’s go line by line, step by step, recursively breaking down every idea here. I’ll unpack it intuitively, back it up with examples, and link it to real-world behavior.\n🔹 Line 1: “These are three distinct data structures that keep track of different data.”\n🧠 Intuition: In the agent model, three “buckets” manage different responsibilities:\nStructure Purpose Example Heap Stores all dynamic data (objects, functions) {name: \"John\"} or an array [1,2,3] lives here Queue List of “jobs” waiting to run (asynchronous tasks) setTimeout(() =\u003e {}, 1000) gets added to queue Stack Keeps track of what function is running right now When calling functions, stack tracks “who called who” 🎯 Real-World Analogy: Heap = Warehouse of data Stack = A to-do list that follows last in, first out — newest task gets done first Queue = A waiting room — first in, first out — oldest task gets picked up first 🔹 Line 2: “We will introduce the queue and the stack in more detail in the following sections.”\n🧠 Intuition: They’re setting you up: heap is mostly a memory detail (not directly manipulated much), but queue and stack are critical to how JavaScript behaves, especially: Why async code works Why console.log runs before a setTimeout Why promises feel synchronous sometimes You’ll learn:\nStack: Why recursion fails with “maximum call stack size exceeded” Queue: Why this logs in order: console.log(\"A\"); setTimeout(() =\u003e console.log(\"B\")); console.log(\"C\"); // Output: A C B 🔹 Line 3: “To read more about how heap memory is allocated and freed, see memory management.”\n🧠 Intuition: The heap is where all your objects live — and they stick around as long as something references them.\nlet x = { name: \"Alice\" }; // stored in the heap x = null; // garbage collected (freed from heap eventually) No manual memory management in JS. The garbage collector watches references.\n🔹 Line 4: “Each agent is analogous to a thread (note that the underlying implementation may or may not be an actual operating system thread).”\n🧠 Key Concept: Agent ≈ Thread But not exactly.\nJavaScript itself is single-threaded — only one agent running main code. But environments (like browsers or Node.js) spawn multiple agents (like Web Workers). 🔍 Important: Just because JavaScript feels single-threaded doesn’t mean there’s only one thread underneath.\nExample: If you use a Web Worker, that code runs in its own agent, with its own heap, queue, and stack.\n// main.js const worker = new Worker(\"worker.js\"); // worker.js onmessage = (e) =\u003e { // This is a separate agent! postMessage(\"Got it\"); }; 🔹 Line 5: “Each agent can own multiple realms (which 1-to-1 correlate with global objects) that can synchronously access each other, and thus needs to run in a single execution thread.”\n🧠 Intuition: A realm is like a sandboxed environment: it has its own globalThis, Array, Function, etc. Inside one agent, multiple realms can talk to each other synchronously (because they share the same stack/queue). 📦 Real-world example:\nIn a browser, your main page and a same-origin iframe are in the same agent, but different realms. \u003ciframe src=\"same-origin.html\"\u003e\u003c/iframe\u003e Inside both:\nconsole.log(window.Array === iframe.contentWindow.Array); // ❌ false Why? Different realms, different versions of built-in objects like Array.\n🔹 Line 6: “An agent also has a single memory model, indicating whether it’s little-endian, whether it can be synchronously blocked, whether atomic operations are lock-free, etc.”\n🧠 What this means: This dives into low-level behavior, useful when you’re dealing with shared memory (e.g., SharedArrayBuffer) and concurrency.\nLittle-endian: Byte ordering in memory (most systems are little-endian). Lock-free atomic operations: Allows agents to coordinate via memory safely. Synchronous blocking: Whether one agent can halt another (usually avoided in JS for responsiveness). 🛠 You’ll care about this if you’re:\nUsing Atomics.wait / Atomics.notify Coordinating workers via shared memory Doing real-time or performance-critical code ✅ Summary Table Concept What It Does Practical Example Heap Stores all objects { user: \"A\" } Stack Tracks function calls foo() calls bar() Queue Holds async jobs setTimeout(), Promise.then() Agent Self-contained executor (heap+stack+queue) Main thread or Worker Realm Global environment inside an agent Main page vs iframe Memory Model Rules for memory access SharedArrayBuffer, Atomics 🔥 Want to go deeper into one of these now? I can:\nVisualize how a realm compares to an agent Show a step-by-step simulation of the stack and queue Break down how two agents use shared memory safely Let me know your next target — I’m ready to go recursive on it.\nGreat! Let’s continue the recursive breakdown from where we left off. We just finished:\n“An agent also has a single memory model, indicating whether it’s little-endian, whether it can be synchronously blocked, whether atomic operations are lock-free, etc.”\nNow, the next part of the MDN doc says:\n📌 Next block: “An agent on the web can be one of the following: A Similar-origin window agent, which contains various Window objects which can potentially reach each other, either directly or by using document.domain. If the window is origin-keyed, then only same-origin windows can reach each other. A Dedicated worker agent containing a single DedicatedWorkerGlobalScope. A Shared worker agent containing a single SharedWorkerGlobalScope. A Service worker agent containing a single ServiceWorkerGlobalScope. A Worklet agent containing a single WorkletGlobalScope.” ✅ Let’s go line-by-line and recursively break this down: 🔹 Line 1: “An agent on the web can be one of the following:”\n🧠 Big idea: On the web, each type of “execution environment” (like a browser tab, a worker, etc.) is backed by its own agent — meaning it has its own heap, stack, and queue.\nThink of each agent as its own little JS runtime.\n🔹 Line 2: “A Similar-origin window agent, which contains various Window objects which can potentially reach each other, either directly or by using document.domain. If the window is origin-keyed, then only same-origin windows can reach each other.”\n🧠 What’s going on here? A window agent = Your main page + all same-origin iframes you embed in it.\n🔄 Shared Agent Example: \u003ciframe src=\"https://yourdomain.com/page.html\"\u003e\u003c/iframe\u003e These two can share memory and synchronously access each other:\n// From parent page console.log(window.frames[0].document.body); 🧪 But if the iframe is cross-origin, access is blocked for security.\n⚠️ Security twist: If document.domain is set (deprecated but still used), two subdomains can loosen the restriction a bit.\n// both pages set document.domain = \"example.com\"; Then they can reach each other, even if one is a.example.com and one is b.example.com.\n🔹 Line 3: “A Dedicated worker agent containing a single DedicatedWorkerGlobalScope.”\n🧠 What is a Dedicated Worker Agent? When you create a Web Worker in the browser:\nconst worker = new Worker(\"worker.js\"); That script (worker.js) runs in its own dedicated worker agent — with its own heap, queue, and stack — completely separate from the main thread.\n🔁 Communication is done asynchronously via postMessage() — like this:\n// main.js worker.postMessage(\"hi\"); // worker.js onmessage = (e) =\u003e { console.log(\"Got:\", e.data); }; ⚠️ You cannot synchronously access memory between main thread and a dedicated worker (unless using SharedArrayBuffer).\n🔹 Line 4: “A Shared worker agent containing a single SharedWorkerGlobalScope.”\n🧠 Difference between Shared Worker and Dedicated Worker? Dedicated Worker: Only 1 page can talk to it. Shared Worker: Multiple tabs (from the same origin) can talk to the same worker. // In two tabs of the same site: const sharedWorker = new SharedWorker(\"worker.js\"); Now both tabs talk to the same long-living agent!\nWhy use this?\nShare data between tabs Maintain a centralized cache Reduce memory usage 📦 But again — it’s a separate agent with its own stack/heap/queue.\n🔹 Line 5: “A Service worker agent containing a single ServiceWorkerGlobalScope.”\n🧠 What’s special about Service Workers? They’re background scripts that sit between your site and the network. Intercept requests (fetch), cache stuff, serve offline pages. // Registering a service worker navigator.serviceWorker.register(\"sw.js\"); 🧠 They:\nOutlive pages Don’t have access to DOM Run in their own agent 💡 Use case:\nself.addEventListener(\"fetch\", (event) =\u003e { event.respondWith(caches.match(event.request)); }); Service workers have a completely isolated memory space and no direct access to the DOM.\n🔹 Line 6: “A Worklet agent containing a single WorkletGlobalScope.”\n🧠 What’s a Worklet? Advanced topic — used for things like:\nCSS Paint API Web Audio API (AudioWorklet) Animations 🔊 Example: An AudioWorklet lets you do low-latency audio processing on a separate thread (agent).\n// In main thread audioContext.audioWorklet.addModule(\"processor.js\"); // processor.js class MyProcessor extends AudioWorkletProcessor { process(inputs, outputs, parameters) { // run audio processing return true; } } registerProcessor(\"my-processor\", MyProcessor); These agents are super-lightweight, meant for tiny, focused jobs like drawing or audio frames.\n🧠 Summary: Agent Type Runs in Has Own Stack/Heap/Queue? Use Case Similar-origin Window Agent Main page + iframes (same origin) ✅ Yes Regular DOM pages Dedicated Worker Agent Worker created via new Worker() ✅ Yes Offload CPU-intensive tasks Shared Worker Agent Shared among multiple tabs ✅ Yes Tab-to-tab communication Service Worker Agent Background fetch/caching logic ✅ Yes Offline apps, PWA Worklet Agent Lightweight visual/audio tasks ✅ Yes Audio, CSS, animations You want to continue to the next part after this? It’s:\n“In other words, each worker creates its own agent, while one or more windows may be within the same agent—usually a main document and its similar-origin iframes…”\nJust say the word and we’ll keep recursively breaking it down with visuals and mental models.\nPerfect! Let’s do a recursive breakdown of this next section, line by line, with intuitive mental models, visuals-in-your-head, and real-world JavaScript usage.\n🧠 Big Context: You just learned that each agent is like an isolated JavaScript runtime: it has its own heap, call stack, and job queue.\nNow you’re learning:\n🔍 “What are the different types of agents on the web?”\nLet’s go line by line:\n🔹 1. “An agent on the web can be one of the following:” ✅ Translation:\nOn the web, there are several “execution environments” where JavaScript can run.\nEach is backed by a separate agent, i.e., its own isolated execution infrastructure.\n🧩 Now we explore each type: 🔹 2. “A Similar-origin window agent, which contains various Window objects which can potentially reach each other, either directly or by using document.domain. If the window is origin-keyed, then only same-origin windows can reach each other.” 🧠 What this means: This is your main webpage, plus any iframes inside it that share the same origin (protocol + host + port). These “windows” share the same agent, and can talk to each other synchronously. 🧪 Real-World Example: \u003ciframe src=\"https://yourdomain.com/page.html\"\u003e\u003c/iframe\u003e You can do this from the parent:\nconst iframeDoc = window.frames[0].document; console.log(iframeDoc.title); // works if same origin ⚠️ If they’re cross-origin, that line throws a security error (unless both set document.domain).\n📌 What is document.domain? A deprecated way to let subdomains trust each other:\n// a.example.com and b.example.com both set: document.domain = \"example.com\"; → Now they can talk synchronously.\n🔹 3. “A Dedicated worker agent containing a single DedicatedWorkerGlobalScope.” 🧠 What this means: When you use a Web Worker, like this:\nconst worker = new Worker(\"worker.js\"); You’re spinning up a new agent behind the scenes.\nThat agent has:\nIts own heap Its own stack Its own event queue It runs worker.js in isolation.\n💡 Real-World Use Case: // main.js worker.postMessage({ task: \"fibonacci\", n: 40 }); // worker.js onmessage = (e) =\u003e { const result = doHeavyFibonacci(e.data.n); postMessage(result); }; → This keeps your UI thread smooth and responsive while the heavy calculation runs in another agent (aka thread-like sandbox).\n🔹 4. “A Shared worker agent containing a single SharedWorkerGlobalScope.” 🧠 Meaning: Unlike a dedicated worker, a SharedWorker is shared across multiple tabs.\nYou create it like:\nconst sharedWorker = new SharedWorker(\"worker.js\"); This launches an agent that lives beyond a single page, shared between tabs of the same origin.\n📌 Use case: You’re building a real-time dashboard with multiple tabs.\nYou want all tabs to share a single:\nWebSocket connection Cache State The shared worker agent holds that logic, and all tabs send messages to it.\n🔹 5. “A Service worker agent containing a single ServiceWorkerGlobalScope.” 🧠 Meaning: Service workers are special. They’re not tied to a tab.\nThey sit in the background and intercept network requests.\nYou register one like:\nnavigator.serviceWorker.register(\"/sw.js\"); The sw.js file runs in its own agent with:\nNo DOM access Its own global scope (ServiceWorkerGlobalScope) A lifetime independent from your pages 📌 Use case: Offline support Background sync Push notifications // sw.js self.addEventListener(\"fetch\", (event) =\u003e { event.respondWith(caches.match(event.request)); }); This runs in a background agent even when no tabs are open.\n🔹 6. “A Worklet agent containing a single WorkletGlobalScope.” 🧠 What is a Worklet? Worklets are tiny, low-latency JS programs.\nThey’re used for audio processing, custom painting, etc.\nThey are isolated agents that are super-performant, meant for frame-by-frame rendering or DSP (digital signal processing).\n🧪 Use Case: // AudioWorklet audioContext.audioWorklet.addModule(\"processor.js\"); // processor.js registerProcessor(\"my-processor\", class extends AudioWorkletProcessor { process(inputs, outputs, params) { // handle audio here return true; } }); Each worklet runs in a micro-agent with hard real-time constraints.\n🔹 7. “In other words, each worker creates its own agent, while one or more windows may be within the same agent—usually a main document and its similar-origin iframes.” 🔁 Recap: Workers (dedicated, shared, service, worklet) → always create new agents Windows (tabs, iframes) → may share one agent if they are same origin 📦 So:\nIf you new Worker(), you get a new agent. If you create a same-origin iframe, it’s part of your agent. If it’s a cross-origin iframe, it likely gets its own agent. 🔹 8. “In Node.js, a similar concept called worker threads is available.” 🧠 In Node.js: const { Worker } = require(\"worker_threads\"); new Worker(\"./worker.js\"); That is exactly equivalent to a dedicated worker agent on the web.\nIt has its own stack, heap, queue Communicates via postMessage Can use SharedArrayBuffer for shared memory 🔧 This is Node’s way of mimicking browser agents in the backend.\n✅ Summary Mental Model: Imagine each agent as a little isolated mini JavaScript world with:\n📦 its own memory (heap) 🧠 its own thinking (call stack) 🕓 its own scheduler (job queue) Then:\nnew Worker() → new agent SharedWorker → shared agent across tabs ServiceWorker → background agent Worklet → real-time micro-agent Same-origin iframe → stays in same agent as parent Want to move to the next block (i.e., Realms)?\nIt starts with:\n“Each agent owns one or more realms…”\nJust say “next”, and I’ll recursively break that one down too.\nPerfect. Let’s do a deep recursive breakdown of this “Realms” section—line by line, with intuition, real examples, and mental models.\n🔰 Topic: What is a Realm? A Realm is like a self-contained JS universe inside an agent.\nThink of it as a “VM inside a thread”.\n🔹 Line 1: “Each agent owns one or more realms.”\n🧠 Intuition:\nWe already learned that an agent is like a JS thread — with its own stack, heap, and event queue.\nA realm lives inside an agent.\nSo one agent can have many realms.\n💡 Real-world Analogy: Agent = one CPU core running JavaScript Realm = one JavaScript sandbox running a specific program (like a tab or an iframe) 🧪 On the web:\nA main tab is one realm. A same-origin iframe is a different realm. But both can live inside the same agent (thread). 🔹 Line 2: “Each piece of JavaScript code is associated with a realm when it’s loaded, which remains the same even when called from another realm.”\n🧠 What’s happening? When a JS file loads in a context (tab, iframe, worker), it’s bound to the realm of that context.\nEven if it’s later called from another realm, it still uses the original realm it was loaded in.\n📦 Example: \u003ciframe id=\"frame\" src=\"iframe.html\"\u003e\u003c/iframe\u003e \u003cscript\u003e const fn = window.frames[0].someFunction; fn(); // This still executes in iframe.html’s realm! \u003c/script\u003e Even though you called the function from the main page, it still executes with the context of the iframe realm. Why? Because that’s where it was created.\n🧠 Functions are sticky to the realm they were born in.\n🔹 Line 3–5: “A realm consists of the following information:\nA list of intrinsic objects like Array, Array.prototype, etc. Globally declared variables, the value of globalThis, and the global object A cache of template literal arrays, because evaluation of the same tagged template literal expression always causes the tag to receive the same array object” 🔸 1. Intrinsic objects (e.g. Array, Object, Function, etc.) Every realm gets its own versions of core JS constructors:\n// iframe.html Array !== parent.Array; // true Each realm gets its own Array, Object, Function, etc.\nThey might behave the same — but they are different objects in memory.\n🔸 2. Global variables and globalThis Every realm has its own global scope — this includes:\nwindow in main thread self in workers globalThis (unified access) So in two realms:\n// Realm A globalThis === window; // true // Realm B (worker) globalThis === self; // true But:\nrealmA.globalThis !== realmB.globalThis; // true Each has its own isolated namespace.\n🔸 3. Template literal cache This is a performance optimization:\nWhen you use tagged template literals, the same template array object is reused:\nfunction tag(strings) { console.log(strings); // same array on repeated calls } tag`Hello ${name}`; tag`Hello ${name}`; This cache is per-realm, not global.\n🔹 Line 6: “On the web, the realm and the global object are 1-to-1 corresponded. The global object is either a Window, a WorkerGlobalScope, or a WorkletGlobalScope.”\n🧠 Translation:\nEach realm has exactly one global object, and vice versa.\nOn the web:\nRealm Global Object Tab / iframe Window Worker WorkerGlobalScope Worklet WorkletGlobalScope That’s why if you get the window in the main page and compare it to an iframe’s, they’re not equal.\n🔹 Line 7: “So for example, every iframe executes in a different realm, though it may be in the same agent as the parent window.”\n✅ Recap of layers:\niframe.html = different realm index.html = different realm But both can share the same agent (thread), and thus talk synchronously const iframe = window.frames[0]; iframe.document !== document // ✅ different realm typeof iframe.Array === \"function\" // ✅ iframe has its own Array constructor 🔹 Line 8: “Realms are usually mentioned when talking about the identities of global objects.”\n🧠 This sets up the next gotcha:\nObjects might “look” the same (e.g. arrays from two realms) But under the hood, their identity is different 🔹 Final Line: “For example, we need methods such as Array.isArray() or Error.isError(), because an array constructed in another realm will have a different prototype object than the Array.prototype object in the current realm, so instanceof Array will wrongly return false.”\n🧪 Mind-blowing Real World Bug: // index.html const arr = window.frames[0].contentWindow.eval(\"[]\"); console.log(arr instanceof Array); // ❌ false Array.isArray(arr); // ✅ true Why? Because:\ninstanceof uses current realm’s Array.prototype But arr was created in another realm, so it’s linked to iframe’s Array.prototype → So they’re not the same prototype — instanceof fails.\n✅ Array.isArray() uses internal tags and works across realms.\n🔄 Summary (Mental Model) Concept Meaning Realm A self-contained JS “universe” with its own global scope and built-in objects Agent A thread-like runner that can host one or more realms Function’s Realm Determined by where it was created, not called Cross-realm instanceof fails Because prototype objects are realm-specific Global object The realm’s anchor: Window, WorkerGlobalScope, etc. Tag template cache Cached per-realm to avoid array recreation Would you like to move on to the next section:\n“Stack and execution contexts”\nJust say “next” and I’ll break that down in the same step-by-step, deeply intuitive style. Absolutely. Let’s run your recursive breakdown prompt on this snippet from the JavaScript execution model.\n🔁 Break this down recursively, step by step.\nFor each line or idea in the text:\nExplain it in simple words like I’m 5. Add practical understanding and intuition. Give real-world metaphors or analogies. Show code examples if possible. Call out connections to other concepts (heap, call stack, event loop, etc). If there are any edge cases or gotchas, point them out. 🧠 Here’s the snippet: Each agent owns one or more realms.\n🧵 TL;DR: An agent (think: thread of JS execution) contains one or more realms, which are like complete JS “universes.”\n👶 Like I’m 5: Imagine a school (agent) with multiple classrooms (realms). Each classroom has its own set of blackboards, students, and books. They don’t share these things directly, even though they’re all in the same school.\n💡 Intuition: A realm is an isolated set of JavaScript built-ins and global variables. Even if two pieces of code are running on the same thread (agent), if they are in different realms, their core object identities are different.\n🧑‍💻 Technical Precision: Each realm has its own: Global object (window, self, etc.) Built-in constructors (Object, Array, Map, etc.) Internal references (prototypes, etc.) Each piece of JavaScript code is associated with a realm when it’s loaded, which remains the same even when called from another realm.\n🔍 Key Insight: Once JS code is “born” in a realm, it stays “tagged” with that realm forever. Even if it’s called from a different realm, its identity doesn’t shift. 🧪 Code Example: // Frame A (iframe1.html) window.foo = []; // Frame B (iframe2.html) console.log(foo instanceof Array); // false foo was created in iframe1’s realm. The Array constructor in iframe2 is from a different realm, so the instanceof fails!\n🧠 Mental Model: Think of realms like sandboxes. Once a toy (object/function) is built in sandbox A, it keeps using A’s rules and tools, even if someone in sandbox B tries to use it.\nA realm consists of the following information:\nWe’ll now decompose each of these bullet points.\n✅ A list of intrinsic objects like Array, Array.prototype, etc.\n🤓 Technical Insight: Intrinsics are ECMAScript-provided, built-in constructors and objects. Every realm has its own fresh copies of these: Object Function Error Array …and their prototypes These are all baked into the realm and created at initialization.\n🪤 Gotcha: Even if two Array constructors look identical (toString()), they are different in identity across realms:\niframe1.Array === iframe2.Array // false ✅ Globally declared variables, the value of globalThis, and the global object\n🧠 Translation: globalThis is realm-specific. Each realm has its own: Top-level variables (var x = ...) window or self globalThis 🧪 Real World Example: // iframe.html var foo = 42; console.log(window.foo); // 42 This foo only exists in that iframe’s global object (its realm).\n✅ A cache of template literal arrays, because evaluation of the same tagged template literal expression always causes the tag to receive the same array object\n🧠 Why does this matter? In tagged templates like:\nfunction tag(strings) { console.log(strings); // same array every time } tag`Hello ${user}`; tag`Hello ${user}`; JavaScript ensures that the template string array passed into tag() is cached per realm.\nDifferent realms? Different caches.\n💥 Performance: This caching helps speed up repeated template evaluation and ensures referential equality:\ntag`hello` === tag`hello`; // true — same object Only within the same realm!\nOn the web, the realm and the global object are 1-to-1 corresponded. The global object is either a Window, a WorkerGlobalScope, or a WorkletGlobalScope.\n🧠 Important Connection: This means: Each realm = one global scope = one top-level execution environment\nMain page → Window Web worker → WorkerGlobalScope Audio/paint worklet → WorkletGlobalScope So for example, every iframe executes in a different realm, though it may be in the same agent as the parent window.\n🧪 Key Example: \u003ciframe src=\"child.html\"\u003e\u003c/iframe\u003e Both windows may run in the same thread (same agent), but they have separate realms:\nSeparate window Separate built-ins Separate Array.prototype Realms are usually mentioned when talking about the identities of global objects.\n🧠 This is important for comparing object types: instanceof, typeof, and even object shape can mislead across realms. That’s why we use Array.isArray() and Object.prototype.toString.call(x) for better checks. For example, we need methods such as Array.isArray() or Error.isError(), because an array constructed in another realm will have a different prototype object than the Array.prototype object in the current realm, so instanceof Array will wrongly return false.\n💥 🔥 This is the key gotcha: instanceof checks the prototype chain:\nobj instanceof Array; // internally: obj.[[Prototype]] === Array.prototype If obj came from another realm, its [[Prototype]] points to that realm’s Array.prototype.\nSo your current realm’s Array.prototype !== obj.[[Prototype]].\n✅ Fix: Use Array.isArray(obj) — it works across realms.\n🔄 Summary: Realm Mental Model Thing Scoped to Realm? Notes globalThis ✅ Yes Same as window in browsers Array, Error, Map ✅ Yes Intrinsics are realm-bound Template literals cache ✅ Yes Same tag + literal = same object only within realm instanceof ❌ Unsafe across realms Use .isArray() instead 🧠 You now understand realms:\nWhat they contain (globals, intrinsics, caches) How they interact (or don’t) Why cross-realm identity breaks matter Let me know when you’re ready for the next snippet 🔥\nAbsolutely — let’s break this down recursively and deeply, exactly as you instructed.\nWe’ll go concept by concept, technically and intuitively, and build up mental models for each.\n🔁 Breakdown: Stack and Execution Contexts 📌 “We first consider synchronous code execution.” 🧠 Simple: Let’s start by looking at normal code that runs step-by-step (not async like setTimeout or fetch).\n🧬 Intuition: Imagine reading a recipe. You follow instructions one by one: get pan, heat it, crack eggs. That’s synchronous — no skipping, no pausing.\n💡 Connection: This section is setting the stage for how JS handles function calls in a single thread.\n📌 “Each job enters by calling its associated callback.” 🧠 Simple: A “job” is a unit of work. That work begins by running a function (called a callback).\n🧬 Metaphor: Think of a “job” as a task on your to-do list. You can’t start the job until you “open the task” — i.e., call the function.\n💻 Example:\nsetTimeout(() =\u003e console.log(\"Hi\"), 0); // The callback here is () =\u003e console.log(\"Hi\") // This becomes a 'job' when placed into the job queue 🔗 Links: Ties into the Job Queue / Event Loop model. This is the beginning of “run-to-completion.”\n📌 “Code inside this callback may create variables, call functions, or exit.” 🧠 Simple: Once the function starts running, it can do things — define variables, call other functions, or finish and return.\n🔁 Recursive: Calling another function pushes a new execution context (stack frame) on the stack.\n📌 “Each function needs to keep track of its own variable environments and where to return to.” 🧠 Simple: Every function has its own scope — a separate box for its variables — and knows where to go back when it finishes.\n🧬 Analogy: Like Russian dolls. Open one, go into the next. But you have to close the inner ones before returning to outer.\n💻 Code:\nfunction greet() { const name = \"Alice\"; return `Hi ${name}`; } JS must remember: name = \"Alice\" Where to go after greet() is done. 📌 “To handle this, the agent needs a stack to keep track of the execution contexts.” 🧠 Simple: JavaScript uses a stack to remember what function it’s currently in — and where to return.\n🧩 Engine Insight: This is the call stack — last-in, first-out (LIFO).\n🔗 Related:\nStack Overflow = when too many nested calls fill up memory. Execution Context = everything needed to run a chunk of code. 📌 “An execution context, also known generally as a stack frame, is the smallest unit of execution.” 🧠 Simple: Each stack frame = one function’s “sandbox.” JS creates one per function call.\n💻 Contains:\nThe function arguments and variables. The value of this. Which realm we’re in. Internal stuff like await, yield, return address. 📌 “It tracks the following information…” 🔹 Code evaluation state 🧠 What line are we on? Are we paused (e.g., generator)? Are we done?\n🔹 The module or script, the function (if applicable), and the currently executing generator 🧠 JS knows: Are we inside a module or a classic script?\nWhich function is running. Are we inside a paused generator? 🔹 The current realm 🧠 Which global environment are we in? (e.g., iframe vs parent)\n🔗 Ties into realms. Important for prototype identity (instanceof, etc.)\n🔹 Bindings 🧠 All the stuff declared inside the function:\nlet, const, var function foo() {} class A {} #privateField this 💻 These are stored in a Lexical Environment.\n🧠 Trace: The Example function foo(b) { const a = 10; return a + b + 11; } function bar(x) { const y = 3; return foo(x * y); } const baz = bar(7); // assigns 42 to baz 📍 Step-by-step Stack Trace:\nbar(7) is called Stack: [global, bar] x = 7, y = 3 foo(21) is called inside bar Stack: [global, bar, foo] b = 21, a = 10 foo returns 42, stack pops back to bar bar returns 42, stack pops back to global baz = 42 🧬 Intuition: JS stacks frames like Jenga blocks. When one returns, it pops off and reveals the one underneath.\n🔁 Generators and Reentry 📌 “When a frame is popped, it’s not necessarily gone forever…” 🧠 Generators let you pause function execution in the middle, and resume later.\n💻 Code:\nfunction* gen() { console.log(1); yield; console.log(2); } 📍 gen() creates a paused execution context. 📍 g.next() resumes it. 📍 yield suspends it again — it lives!\n🧬 Metaphor: Like pausing a game and saving your state. You can resume from where you left.\n🧬 Tail Calls 📌 “If a function call is in tail position…” 🧠 When a function ends with return anotherFunction(), you don’t need a new frame — just reuse the current one.\n💻 Example:\nfunction f() { return g(); // Tail call! } 🔥 PTC (Proper Tail Call) optimization:\nDon’t grow the stack. Especially useful in tail-recursive functions. 🧩 ⚠️ Only Safari (JavaScriptCore) supports it. Most engines do not implement this due to debugging stack traces.\n🔁 Closures 📌 “Whenever a function is created, it also memorizes…” 🧠 A closure is a function bundled with the variables from the scope in which it was created.\n💻\nfunction outer() { let x = 10; return () =\u003e x; // \u003c- closure } const f = outer(); console.log(f()); // 10 🧬 Mental model: Think of the returned function as carrying a backpack filled with variables it saw when it was created.\n🔗 Related:\nLexical Environment var, let, const scoping Let me know when you’re ready for the next section — or if you’d like me to turn this into an Anki-style Q\u0026A deck for reinforcement. Absolutely — let’s do a line-by-line recursive breakdown of this Job Queue and Event Loop section with full senior-engineer depth, intuition, code traces, runtime metaphors, and links to memory model concepts.\n🔁 Section: Job Queue and Event Loop 📌 “An agent is a thread, which means the interpreter can only process one statement at a time.” 🧠 Simple: JavaScript is single-threaded — only one thing runs at a time per agent.\n🧩 Engine Insight:\nIn the browser, an agent could be your main window (the tab), or a worker. Think of the JS engine as a tiny CPU that processes one instruction at a time — no matter how many cores your real CPU has. 🧬 Analogy: Like a chef who can only cook one dish at a time. Others must wait their turn.\n📌 “When the code is all synchronous, this is fine because we can always make progress.” 🧠 This means: As long as the code doesn’t pause for anything (like network or timers), it just runs straight to the end.\n🔗 Related: Synchronous code uses the call stack, not the job queue.\n💻\nfunction add(a, b) { return a + b; } add(2, 3); // runs synchronously 📌 “But if the code needs to perform asynchronous action, then we cannot progress unless that action is completed.” 🧠 Async actions (e.g. fetch, setTimeout) pause until external conditions are ready (data returned, timer elapsed).\n⚠️ If JS waited synchronously for async things → the browser would freeze.\n📌 “However, it would be detrimental to user experience if that halts the whole program…” 🧬 Metaphor: Imagine a barista who freezes every time a customer orders a coffee — until it’s brewed. The line would stall.\n🔥 Why JS must be async: It’s embedded in browsers. You must be able to scroll, type, click even if some JS is waiting.\n📌 “Therefore, the code that handles the completion of that asynchronous action is defined as a callback.” 🧠 The logic to run after a wait is defined ahead of time as a callback function.\n💻\nsetTimeout(() =\u003e { console.log('Done waiting!'); }, 1000); () =\u003e console.log(...) is the callback It is queued, not run immediately. 📌 “This callback defines a job, which gets placed into a job queue—or, in HTML terminology, an event loop—once the action is completed.” 🧩 The callback becomes a job → a mini “task” to execute later.\n🧠 The event loop is the orchestrator: it picks the next job from the queue when the call stack is empty.\n🔄 Summary Mental Model So Far: [ Main Thread ] --\u003e Executes sync code until stack is empty | When async completes: [ Event Loop ] ---+\u003e Pulls next job from Job Queue [ Job Queue ] ----\u003e Contains callbacks from timers, promises, events 📌 “Every time, the agent pulls a job from the queue and executes it.” 🧠 The engine continuously pulls and runs jobs in a loop (hence: “event loop”).\n🔁 The cycle:\nJob queue: filled by browser or platform APIs Event loop: pulls job → creates execution context → pushes on stack → runs → pops 📌 “When the job is executed, it may create more jobs…” 🧠 Example: You can queue new async work from inside another job.\n💻\nsetTimeout(() =\u003e { console.log(\"first\"); setTimeout(() =\u003e console.log(\"second\"), 0); }, 0); 📌 “Jobs might not be pulled with uniform priority…” 🧠 Some jobs are more urgent than others!\n🔗 Microtasks vs Tasks\nMicrotasks: promise callbacks, queueMicrotask Tasks: setTimeout, setInterval, UI events 🧩 Microtasks are always drained first, after each job.\n💻\nPromise.resolve().then(() =\u003e console.log(\"microtask\")); setTimeout(() =\u003e console.log(\"task\"), 0); // Output: microtask, then task 📌 “If the job queue is empty, the agent waits for more jobs to be added.” 🧠 Idle state. The event loop sleeps until the browser or platform API triggers new work.\n🧬 Like a delivery robot that naps until someone rings the bell.\n⚡ “Run-to-completion” 📌 “Each job is processed completely before any other job is processed.” 🧠 JS never interrupts mid-function.\n🧬 Analogy: Once a doctor starts surgery, no one can stop them to ask a question — they must finish.\n🔗 Contrast: In C/Java, threads can preempt each other. In JS, once a job starts, it owns the CPU until it finishes.\n📌 “whenever a function runs, it cannot be preempted…” 🧠 This is why JS avoids race conditions inside jobs.\n💻 Code:\nlet i = 0; Promise.resolve().then(() =\u003e { i++; console.log(i); }); Promise.resolve().then(() =\u003e { i++; console.log(i); }); 🧬 Each .then() is a microtask → runs separately → but not simultaneously\n📤 Output: 1 then 2 — always predictable.\n🚨 Downside: Long jobs freeze the app 📌 “if a job takes too long to complete, the web application is unable to process user interactions…” 🧠 While a job is running, the browser can’t repaint, handle scroll, or click events.\n🧩 This is why infinite loops freeze tabs.\n🔥 Modern browsers will warn: “Script is taking too long”\n✅ Best Practice:\nBreak up big tasks using setTimeout or requestIdleCallback 💻 Example:\nfunction heavyWork() { for (let i = 0; i \u003c 1e9; i++) { /*...*/ } } // bad – blocks UI ✅ Never Blocking 📌 “Handling I/O is typically performed via events and callbacks…” 🧠 This is the heart of JS’s async model. It uses non-blocking I/O.\n💻 When you call fetch(), JS:\nStarts network request in background Finishes current script Runs your callback when data is ready 📌 “…which defines a job to be added to the job queue once the action completes.” 🔁 Consistent pattern:\nYou give JS a function → it adds it as a job when the async work completes 💻\nfetch(url).then(data =\u003e { // this is a job }); 📌 “Some legacy exceptions exist like alert() or synchronous XHR.” 🧠 These are blocking APIs — they freeze the event loop.\n🚫 Avoid:\nalert() confirm() synchronous XMLHttpRequest They break the “never blocking” contract.\n✅ Final Takeaway Mental Model [ Call Stack ] | runs sync code | while stack is empty, pull jobs... [ Event Loop ] ↳ prioritizes Microtask Queue (Promises) ↳ then Task Queue (Timers, Events) [ Microtask Queue ] ↳ .then(), catch(), queueMicrotask() [ Task Queue ] ↳ setTimeout, DOM events, fetch completion Let me know when you’re ready for the next section, or if you want a code visualization to simulate this step-by-step.\nAwesome — you’re diving into the deepest part of the JavaScript execution model: 🧠 agent clusters, memory sharing, and concurrency guarantees.\nLet’s now break it down recursively, step-by-step with:\n🧠 ELI5 (but senior engineer depth) 🧬 Metaphors + system-level mental models 💻 Code examples 🔁 Runtime traces if needed ⚠️ Gotchas + edge cases 🔗 Connections to internals (e.g., call stack, Web Workers, SharedArrayBuffer, Atomics) 📦 [SECTION 1] — Agent clusters and memory sharing 🔹 “Multiple agents can communicate via memory sharing, forming an agent cluster.” 🧠 What’s an agent?\nThink of an agent as an independent JavaScript execution thread.\nOn the web, this includes Window, Dedicated Worker, Shared Worker, Service Worker, Worklet, etc. 🧬 Metaphor: Each agent is a chef in their own kitchen. Normally, they can’t see or touch each other’s tools or food, but if we allow shared ingredients (memory), they become part of the same restaurant (agent cluster).\n💡 Agent cluster = a group of agents that can share memory, especially SharedArrayBuffer.\n🔹 “Agents are within the same cluster if and only if they can share memory.” 🔒 Memory sharing is the defining rule for clustering.\nNo memory sharing = not in the same cluster.\n🧠 Think: A dedicated worker created by a window can share memory with it — they live in the same memory “neighborhood.”\n🔹 “There is no built-in mechanism for two agent clusters to exchange any information… regarded as completely isolated execution models.” ⚠️ Once memory isn’t shared, you’re in a different universe.\n💬 Agents in different clusters can’t see or affect each other. No messaging, no memory sync.\nThis protects data integrity, prevents deadlocks, and improves security/sandboxing.\n🧱 [SECTION 2] — When are agents in the same cluster? Let’s go line-by-line on the examples.\n✅ CAN share memory (same agent cluster) A Window and a DedicatedWorker it created\n→ This is the classic case:\nconst worker = new Worker(\"worker.js\"); They’re “parent-child” and can share SharedArrayBuffer.\nAny worker and a dedicated worker it created\n→ Nested workers:\n// In worker A const nested = new Worker(\"nested.js\"); A Window and a same-origin iframe it created\n→ Same-origin iframe = same memory model.\nA Window and a same-origin window that opened it\n→ If window.open() is used and both have same origin → shared memory is possible.\nA Window and a worklet it created\n→ Worklets (e.g., AudioWorklet) run in a specialized context, but under the hood they’re still in the cluster.\n❌ CANNOT share memory (different agent clusters) A Window and a shared worker it created\nShared workers have global scope across tabs — memory isolation enforced. Any worker and a shared worker it created\nAgain: shared workers are multi-tenant → no memory sharing. A Window and a service worker it created\nService workers are meant to be persistent proxies — not memory-bound to their creators. Window and an iframe with a different origin\nSame document origin = OK. Otherwise → cross-origin sandboxing. Two unrelated Window objects (even if same-origin!)\nIf there’s no opener/ancestor relationship → isolation. 📤 [SECTION 3] — Cross-agent communication and memory model 🔹 “Agents communicate via memory sharing” 💡 On the web, you can use:\npostMessage() → sends data by copying (structured clone). SharedArrayBuffer → sends a reference to the same memory. 🔹 “Typically, data is passed by value only (via structured cloning)” 🧠 This means that postMessage() copies the data:\nworker.postMessage({ name: \"foo\" }); // copied, not shared 💡 No concurrency issues — each agent has its own version.\n🔹 “To share memory, one must post a SharedArrayBuffer…” 💻 Example:\nconst shared = new SharedArrayBuffer(1024); worker.postMessage(shared); // shared, not cloned 🧠 Now both sides have shared view of the same memory. Enter: ⚠️ concurrency risk.\n🔹 “Once agents share memory… they can synchronize via Atomics” 💡 Atomics = low-level tools like locks or barriers:\nconst arr = new Int32Array(sharedBuffer); Atomics.store(arr, 0, 123); Atomics.notify(arr, 0, 1); Atomics.wait, notify, add, compareExchange — ensure safe coordination. 🔹 “Normal memory access is not atomic” ⚠️ You risk data races without Atomics. For example:\narr[0] = arr[0] + 1; // NOT safe in concurrent context 🔹 “Atomic access is sequentially consistent” 🧠 Means all agents see memory changes in the same order.\n🧬 Metaphor: Everyone reads from the same official whiteboard, in strict timestamp order.\n🔹 “Non-atomic access is unordered” 💣 You can’t assume what value an agent will see. Could read half-updated memory!\n🔒 [SECTION 4] — Guidelines for shared memory programs 🧠 Rule #1: Make it data-race free That means:\n✅ Only one agent accesses a memory location at a time\n✅ If concurrent access happens, must use Atomics\n💡 If race-free, you don’t need to memorize weird memory model details.\n🧠 Rule #2: Use strongly typed memory access → Don’t mix atomic and non-atomic access on same cell\n→ Don’t access memory with different sizes (e.g., Int8 and Int32) at once\n⚠️ Otherwise: value tearing = corrupted memory values\n🚧 [SECTION 5] — Concurrency and forward progress 🔹 “An agent can become blocked… waiting on another agent” 💡 Unlike promises (which yield control back), Atomics.wait() can halt the whole thread:\nAtomics.wait(sharedArray, 0, 0); // blocking call 🧠 This blocks until someone else wakes it up with Atomics.notify.\n🔹 Forward progress guarantees: These prevent deadlocks:\n✅ If agent has its own thread → it will eventually run ✅ If many agents share a thread → one will eventually run ✅ Agents only block each other via explicit APIs (Atomics.wait, sync XHR, etc.) 🔹 Only certain agents can be blocked 📌 On web:\n✅ Dedicated workers and shared workers → can block ❌ Service workers, same-origin windows → cannot block (must stay responsive) 🔹 Agent clusters cannot be partially deactivated 💡 Ensures one agent doesn’t starve others:\nE.g., if a window goes inactive, it can’t suspend its worker if that worker is holding a lock needed by others.\n💥 [SECTION 6] — Cluster termination 🔹 “An agent may be paused/resumed/terminated without its knowledge” 🧬 Real-world analogy: The OS may freeze your app if tab is in the background.\n🔹 “If one agent in a cluster is terminated, all are terminated” 📌 To avoid weird bugs:\nPrevent lock holder (e.g. a dedicated worker) from holding up others Clean, deterministic teardown 🧠 Summary Concept What it means Agent A JS execution context (Window, Worker) Agent cluster A group of agents that can share memory Shared memory Via SharedArrayBuffer Synchronization Via Atomics Race-free design Avoids memory corruption Blocked agent Can halt progress if not designed carefully Cluster termination Whole cluster dies if one dies Want to go deeper into:\nCode examples using SharedArrayBuffer and Atomics? Agent cluster detection or visualization? Simulation of race conditions? Let’s pick a direction!\n","wordCount":"9066","inLanguage":"en","image":"https://archit15singh.github.io/images/uploads/cosmic-timetraveler.webp","datePublished":"2022-07-29T12:00:00Z","dateModified":"2022-07-29T12:00:00Z","author":{"@type":"Person","name":"Archit Singh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://archit15singh.github.io/posts/2022-07-29-js-execution-model-in-depth/"},"publisher":{"@type":"Organization","name":"Archit's Space","logo":{"@type":"ImageObject","url":"https://archit15singh.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://archit15singh.github.io/ accesskey=h title="Archit's Space (Alt + H)">Archit's Space</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://archit15singh.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://archit15singh.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://archit15singh.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://archit15singh.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://archit15singh.github.io/posts/>Posts</a></div><h1 class=post-title>JS execution model in depth</h1><div class=post-description>An in-depth breakdown of the JS execution model</div><div class=post-meta><span title="2022-07-29 12:00:00 +0000 UTC">July 29, 2022</span>&nbsp;·&nbsp;43 min</div></header><figure class=entry-cover><img loading=lazy src=https://archit15singh.github.io/images/uploads/cosmic-timetraveler.webp alt="JS execution model"><p>JS execution model</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#js-execution-model aria-label="JS execution model">JS execution model</a><ul><ul><li><a href=#- aria-label="📘 &ldquo;JavaScript execution model&rdquo;">📘 <strong>&ldquo;JavaScript execution model&rdquo;</strong></a><ul><li><a href=#-literal-meaning aria-label="✅ Literal meaning:">✅ Literal meaning:</a></li><li><a href=#-deeper-understanding aria-label="🔍 Deeper understanding:">🔍 Deeper understanding:</a></li><li><a href=#-analogy aria-label="🧠 Analogy:">🧠 Analogy:</a></li></ul></li><li><a href=#--1 aria-label="📝 &ldquo;This page introduces the basic infrastructure of the JavaScript runtime environment.&rdquo;">📝 <strong>&ldquo;This page introduces the basic infrastructure of the JavaScript runtime environment.&rdquo;</strong></a><ul><li><a href=#-literal-meaning-1 aria-label="✅ Literal meaning:">✅ Literal meaning:</a></li><li><a href=#-deeper-understanding-1 aria-label="🔍 Deeper understanding:">🔍 Deeper understanding:</a></li><li><a href=#-analogy-1 aria-label="🧠 Analogy:">🧠 Analogy:</a></li></ul></li><li><a href=#--2 aria-label="🛠 &ldquo;The model is largely theoretical and abstract, without any platform-specific or implementation-specific details.&rdquo;">🛠 <strong>&ldquo;The model is largely theoretical and abstract, without any platform-specific or implementation-specific details.&rdquo;</strong></a><ul><li><a href=#-literal-meaning-2 aria-label="✅ Literal meaning:">✅ Literal meaning:</a></li><li><a href=#-deeper-understanding-2 aria-label="🔍 Deeper understanding:">🔍 Deeper understanding:</a></li><li><a href=#-analogy-2 aria-label="🧠 Analogy:">🧠 Analogy:</a></li></ul></li><li><a href=#--3 aria-label="🧠 &ldquo;Modern JavaScript engines heavily optimize the described semantics.&rdquo;">🧠 <strong>&ldquo;Modern JavaScript engines heavily optimize the described semantics.&rdquo;</strong></a><ul><li><a href=#-literal-meaning-3 aria-label="✅ Literal meaning:">✅ Literal meaning:</a></li><li><a href=#-deeper-understanding-3 aria-label="🔍 Deeper understanding:">🔍 Deeper understanding:</a></li><li><a href=#-analogy-3 aria-label="🧠 Analogy:">🧠 Analogy:</a></li></ul></li><li><a href=#--4 aria-label="📖 &ldquo;This page is a reference. It assumes you are already familiar with the execution model of other programming languages, such as C and Java.&rdquo;">📖 <strong>&ldquo;This page is a reference. It assumes you are already familiar with the execution model of other programming languages, such as C and Java.&rdquo;</strong></a><ul><li><a href=#-literal-meaning-4 aria-label="✅ Literal meaning:">✅ Literal meaning:</a></li><li><a href=#-deeper-understanding-4 aria-label="🔍 Deeper understanding:">🔍 Deeper understanding:</a></li><li><a href=#-analogy-4 aria-label="🧠 Analogy:">🧠 Analogy:</a></li></ul></li><li><a href=#--5 aria-label="🔧 &ldquo;It makes heavy references to existing concepts in operating systems and programming languages.&rdquo;">🔧 <strong>&ldquo;It makes heavy references to existing concepts in operating systems and programming languages.&rdquo;</strong></a><ul><li><a href=#-literal-meaning-5 aria-label="✅ Literal meaning:">✅ Literal meaning:</a></li><li><a href=#-deeper-understanding-5 aria-label="🔍 Deeper understanding:">🔍 Deeper understanding:</a></li><li><a href=#-analogy-5 aria-label="🧠 Analogy:">🧠 Analogy:</a></li></ul></li></ul><li><a href=#-the-engine-and-the-host aria-label="🔥 The engine and the host">🔥 <strong>The engine and the host</strong></a><ul><li><a href=#--6 aria-label="🧩 &ldquo;JavaScript execution requires the cooperation of two pieces of software: the JavaScript engine and the host environment.&rdquo;">🧩 <strong>&ldquo;JavaScript execution requires the cooperation of two pieces of software: the JavaScript engine and the host environment.&rdquo;</strong></a><ul><li><a href=#-literal-meaning-6 aria-label="✅ Literal meaning:">✅ Literal meaning:</a></li><li><a href=#-deeper-understanding-6 aria-label="🔍 Deeper understanding:">🔍 Deeper understanding:</a></li><li><a href=#-analogy-6 aria-label="🧠 Analogy:">🧠 Analogy:</a></li></ul></li><li><a href=#--7 aria-label="🧠 &ldquo;The JavaScript engine implements the ECMAScript (JavaScript) language, providing the core functionality.&rdquo;">🧠 <strong>&ldquo;The JavaScript engine implements the ECMAScript (JavaScript) language, providing the core functionality.&rdquo;</strong></a><ul><li><a href=#-literal-meaning-7 aria-label="✅ Literal meaning:">✅ Literal meaning:</a></li><li><a href=#-deeper-understanding-7 aria-label="🔍 Deeper understanding:">🔍 Deeper understanding:</a></li><li><a href=#-analogy-7 aria-label="🧠 Analogy:">🧠 Analogy:</a></li></ul></li><li><a href=#--8 aria-label="🌍 &ldquo;In order to interact with the outside world [&mldr;] we need additional environment-specific mechanisms provided by the host environment.&rdquo;">🌍 <strong>&ldquo;In order to interact with the outside world [&mldr;] we need additional environment-specific mechanisms provided by the host environment.&rdquo;</strong></a><ul><li><a href=#-literal-meaning-8 aria-label="✅ Literal meaning:">✅ Literal meaning:</a></li><li><a href=#-deeper-understanding-8 aria-label="🔍 Deeper understanding:">🔍 Deeper understanding:</a></li><li><a href=#-analogy-8 aria-label="🧠 Analogy:">🧠 Analogy:</a></li></ul></li><li><a href=#--9 aria-label="🌐 &ldquo;For example, the HTML DOM is the host environment when JavaScript is executed in a web browser. Node.js is another host environment&mldr;&rdquo;">🌐 <strong>&ldquo;For example, the HTML DOM is the host environment when JavaScript is executed in a web browser. Node.js is another host environment&mldr;&rdquo;</strong></a><ul><li><a href=#-literal-meaning-9 aria-label="✅ Literal meaning:">✅ Literal meaning:</a></li><li><a href=#-deeper-understanding-9 aria-label="🔍 Deeper understanding:">🔍 Deeper understanding:</a></li><li><a href=#-analogy-9 aria-label="🧠 Analogy:">🧠 Analogy:</a></li></ul></li><li><a href=#javascript-execution-model aria-label="🔹JavaScript execution model">🔹<strong>JavaScript execution model</strong></a></li><li><a href=#this-page-is-a-reference-it-assumes-you-are-already-familiar-with-the-execution-model-of-other-programming-languages-such-as-c-and-java aria-label="🔹This page is a reference. It assumes you are already familiar with the execution model of other programming languages, such as C and Java.">🔹<strong>This page is a reference. It assumes you are already familiar with the execution model of other programming languages, such as C and Java.</strong></a></li><li><a href=#the-engine-and-the-host aria-label="🔹The engine and the host">🔹<strong>The engine and the host</strong></a></li><li><a href=#agent-execution-model aria-label="🔹Agent Execution Model">🔹<strong>Agent Execution Model</strong></a><ul><li><a href=#-heap-of-objects aria-label="🔸 Heap (of objects)">🔸 <strong>Heap (of objects)</strong></a></li><li><a href=#-queue-of-jobs aria-label="🔸 Queue (of jobs)">🔸 <strong>Queue (of jobs)</strong></a></li><li><a href=#-stack-of-execution-contexts aria-label="🔸 Stack (of execution contexts)">🔸 <strong>Stack (of execution contexts)</strong></a></li></ul></li><li><a href=#-up-next aria-label="🧠 Up Next:">🧠 Up Next:</a></li></ul></li><li><a href=#-line-1 aria-label="🔹 Line 1:">🔹 Line 1:</a><ul><li><a href=#-intuition aria-label="🧠 Intuition:">🧠 Intuition:</a></li><li><a href=#-real-world-analogy aria-label="🎯 Real-World Analogy:">🎯 Real-World Analogy:</a></li></ul></li><li><a href=#-line-2 aria-label="🔹 Line 2:">🔹 Line 2:</a><ul><li><a href=#-intuition-1 aria-label="🧠 Intuition:">🧠 Intuition:</a></li></ul></li><li><a href=#-line-3 aria-label="🔹 Line 3:">🔹 Line 3:</a><ul><li><a href=#-intuition-2 aria-label="🧠 Intuition:">🧠 Intuition:</a></li></ul></li><li><a href=#-line-4 aria-label="🔹 Line 4:">🔹 Line 4:</a><ul><li><a href=#-key-concept-agent--thread aria-label="🧠 Key Concept: Agent ≈ Thread">🧠 Key Concept: <strong>Agent ≈ Thread</strong></a></li></ul></li><li><a href=#-line-5 aria-label="🔹 Line 5:">🔹 Line 5:</a><ul><li><a href=#-intuition-3 aria-label="🧠 Intuition:">🧠 Intuition:</a></li></ul></li><li><a href=#-line-6 aria-label="🔹 Line 6:">🔹 Line 6:</a><ul><li><a href=#-what-this-means aria-label="🧠 What this means:">🧠 What this means:</a></li></ul></li><li><a href=#-summary-table aria-label="✅ Summary Table">✅ Summary Table</a><ul><li><a href=#-want-to-go-deeper-into-one-of-these-now aria-label="🔥 Want to go deeper into one of these now?">🔥 Want to go deeper into one of these now?</a></li></ul></li><li><a href=#-next-block aria-label="📌 Next block:">📌 Next block:</a><ul><li><a href=#an-agent-on-the-web-can-be-one-of-the-following aria-label="“An agent on the web can be one of the following:">“An agent on the web can be one of the following:</a></li><li><a href=#-lets-go-line-by-line-and-recursively-break-this-down aria-label="✅ Let&rsquo;s go line-by-line and recursively break this down:">✅ Let&rsquo;s go <strong>line-by-line and recursively break this down</strong>:</a></li><li><a href=#-line-1-1 aria-label="🔹 Line 1:">🔹 Line 1:</a></li><li><a href=#-line-2-1 aria-label="🔹 Line 2:">🔹 Line 2:</a></li><li><a href=#-whats-going-on-here aria-label="🧠 What&rsquo;s going on here?">🧠 What&rsquo;s going on here?</a><ul><li><a href=#-shared-agent-example aria-label="🔄 Shared Agent Example:">🔄 Shared Agent Example:</a></li><li><a href=#-security-twist aria-label="⚠️ Security twist:">⚠️ Security twist:</a></li></ul></li><li><a href=#-line-3-1 aria-label="🔹 Line 3:">🔹 Line 3:</a></li><li><a href=#-what-is-a-dedicated-worker-agent aria-label="🧠 What is a Dedicated Worker Agent?">🧠 What is a <strong>Dedicated Worker Agent</strong>?</a></li><li><a href=#-line-4-1 aria-label="🔹 Line 4:">🔹 Line 4:</a></li><li><a href=#-difference-between-shared-worker-and-dedicated-worker aria-label="🧠 Difference between Shared Worker and Dedicated Worker?">🧠 Difference between <strong>Shared Worker</strong> and <strong>Dedicated Worker</strong>?</a></li><li><a href=#-line-5-1 aria-label="🔹 Line 5:">🔹 Line 5:</a></li><li><a href=#-whats-special-about-service-workers aria-label="🧠 What’s special about Service Workers?">🧠 What’s special about <strong>Service Workers</strong>?</a></li><li><a href=#-line-6-1 aria-label="🔹 Line 6:">🔹 Line 6:</a></li><li><a href=#-whats-a-worklet aria-label="🧠 What’s a Worklet?">🧠 What’s a <strong>Worklet</strong>?</a></li></ul></li><li><a href=#-summary aria-label="🧠 Summary:">🧠 Summary:</a></li><li><a href=#-big-context aria-label="🧠 Big Context:">🧠 Big Context:</a><ul><li><a href=#-1-an-agent-on-the-web-can-be-one-of-the-following aria-label="🔹 1. “An agent on the web can be one of the following:”">🔹 1. “An agent on the web can be one of the following:”</a></li></ul></li><li><a href=#-now-we-explore-each-type aria-label="🧩 Now we explore each type:">🧩 Now we explore each type:</a><ul><li><a href=#-2-a-similar-origin-window-agent-which-contains-various-window-objects-which-can-potentially-reach-each-other-either-directly-or-by-using-documentdomain-if-the-window-is-origin-keyed-then-only-same-origin-windows-can-reach-each-other aria-label="🔹 2. “A Similar-origin window agent, which contains various Window objects which can potentially reach each other, either directly or by using document.domain. If the window is origin-keyed, then only same-origin windows can reach each other.”">🔹 2. “A Similar-origin window agent, which contains various Window objects which can potentially reach each other, either directly or by using <code>document.domain</code>. If the window is origin-keyed, then only same-origin windows can reach each other.”</a></li><li><a href=#-what-this-means-1 aria-label="🧠 What this means:">🧠 What this means:</a><ul><li><a href=#-real-world-example aria-label="🧪 Real-World Example:">🧪 Real-World Example:</a></li><li><a href=#-what-is-documentdomain aria-label="📌 What is document.domain?">📌 What is <code>document.domain</code>?</a></li></ul></li><li><a href=#-3-a-dedicated-worker-agent-containing-a-single-dedicatedworkerglobalscope aria-label="🔹 3. “A Dedicated worker agent containing a single DedicatedWorkerGlobalScope.”">🔹 3. “A Dedicated worker agent containing a single <code>DedicatedWorkerGlobalScope</code>.”</a></li><li><a href=#-what-this-means-2 aria-label="🧠 What this means:">🧠 What this means:</a><ul><li><a href=#-real-world-use-case aria-label="💡 Real-World Use Case:">💡 Real-World Use Case:</a></li></ul></li><li><a href=#-4-a-shared-worker-agent-containing-a-single-sharedworkerglobalscope aria-label="🔹 4. “A Shared worker agent containing a single SharedWorkerGlobalScope.”">🔹 4. “A Shared worker agent containing a single <code>SharedWorkerGlobalScope</code>.”</a></li><li><a href=#-meaning aria-label="🧠 Meaning:">🧠 Meaning:</a><ul><li><a href=#-use-case aria-label="📌 Use case:">📌 Use case:</a></li></ul></li><li><a href=#-5-a-service-worker-agent-containing-a-single-serviceworkerglobalscope aria-label="🔹 5. “A Service worker agent containing a single ServiceWorkerGlobalScope.”">🔹 5. “A Service worker agent containing a single <code>ServiceWorkerGlobalScope</code>.”</a></li><li><a href=#-meaning-1 aria-label="🧠 Meaning:">🧠 Meaning:</a><ul><li><a href=#-use-case-1 aria-label="📌 Use case:">📌 Use case:</a></li></ul></li><li><a href=#-6-a-worklet-agent-containing-a-single-workletglobalscope aria-label="🔹 6. “A Worklet agent containing a single WorkletGlobalScope.”">🔹 6. “A Worklet agent containing a single <code>WorkletGlobalScope</code>.”</a></li><li><a href=#-what-is-a-worklet aria-label="🧠 What is a Worklet?">🧠 What is a <strong>Worklet</strong>?</a><ul><li><a href=#-use-case-2 aria-label="🧪 Use Case:">🧪 Use Case:</a></li></ul></li><li><a href=#-7-in-other-words-each-worker-creates-its-own-agent-while-one-or-more-windows-may-be-within-the-same-agentusually-a-main-document-and-its-similar-origin-iframes aria-label="🔹 7. “In other words, each worker creates its own agent, while one or more windows may be within the same agent—usually a main document and its similar-origin iframes.”">🔹 7. “In other words, each worker creates its own agent, while one or more windows may be within the same agent—usually a main document and its similar-origin iframes.”</a></li><li><a href=#-recap aria-label="🔁 Recap:">🔁 Recap:</a></li><li><a href=#-8-in-nodejs-a-similar-concept-called-worker-threads-is-available aria-label="🔹 8. “In Node.js, a similar concept called worker threads is available.”">🔹 8. “In Node.js, a similar concept called worker threads is available.”</a></li><li><a href=#-in-nodejs aria-label="🧠 In Node.js:">🧠 In Node.js:</a></li></ul></li><li><a href=#-summary-mental-model aria-label="✅ Summary Mental Model:">✅ Summary Mental Model:</a><ul><li><a href=#-topic-what-is-a-realm aria-label="🔰 Topic: What is a Realm?">🔰 Topic: <strong>What is a Realm?</strong></a></li></ul></li><li><a href=#-line-1-2 aria-label="🔹 Line 1:">🔹 Line 1:</a><ul><li><a href=#-real-world-analogy-1 aria-label="💡 Real-world Analogy:">💡 Real-world Analogy:</a></li></ul></li><li><a href=#-line-2-2 aria-label="🔹 Line 2:">🔹 Line 2:</a><ul><li><a href=#-whats-happening aria-label="🧠 What&rsquo;s happening?">🧠 What&rsquo;s happening?</a><ul><li><a href=#-example aria-label="📦 Example:">📦 Example:</a></li></ul></li></ul></li><li><a href=#-line-35 aria-label="🔹 Line 3–5:">🔹 Line 3–5:</a><ul><li><a href=#-1-intrinsic-objects-eg-array-object-function-etc aria-label="🔸 1. Intrinsic objects (e.g. Array, Object, Function, etc.)">🔸 1. <strong>Intrinsic objects</strong> (e.g. <code>Array</code>, <code>Object</code>, <code>Function</code>, etc.)</a></li><li><a href=#-2-global-variables-and aria-label="🔸 2. Global variables and globalThis">🔸 2. <strong>Global variables and <code>globalThis</code></strong></a></li><li><a href=#-3-template-literal-cache aria-label="🔸 3. Template literal cache">🔸 3. <strong>Template literal cache</strong></a></li></ul></li><li><a href=#-line-6-2 aria-label="🔹 Line 6:">🔹 Line 6:</a></li><li><a href=#-line-7 aria-label="🔹 Line 7:">🔹 Line 7:</a></li><li><a href=#-line-8 aria-label="🔹 Line 8:">🔹 Line 8:</a></li><li><a href=#-final-line aria-label="🔹 Final Line:">🔹 Final Line:</a><ul><li><a href=#-mind-blowing-real-world-bug aria-label="🧪 Mind-blowing Real World Bug:">🧪 Mind-blowing Real World Bug:</a><ul><li><a href=#why aria-label=Why?>Why?</a></li></ul></li></ul></li><li><a href=#-summary-mental-model-1 aria-label="🔄 Summary (Mental Model)">🔄 Summary (Mental Model)</a><ul><li><a href=#-heres-the-snippet aria-label="🧠 Here&rsquo;s the snippet:">🧠 Here&rsquo;s the snippet:</a><ul><li><a href=#-tldr aria-label="🧵 TL;DR:">🧵 TL;DR:</a></li><li><a href=#-like-im-5 aria-label="👶 Like I’m 5:">👶 Like I’m 5:</a></li><li><a href=#-intuition-4 aria-label="💡 Intuition:">💡 Intuition:</a></li><li><a href=#-technical-precision aria-label="🧑‍💻 Technical Precision:">🧑‍💻 Technical Precision:</a></li><li><a href=#-key-insight aria-label="🔍 Key Insight:">🔍 Key Insight:</a></li><li><a href=#-code-example aria-label="🧪 Code Example:">🧪 Code Example:</a></li><li><a href=#-mental-model aria-label="🧠 Mental Model:">🧠 Mental Model:</a></li><li><a href=#-technical-insight aria-label="🤓 Technical Insight:">🤓 Technical Insight:</a></li><li><a href=#-gotcha aria-label="🪤 Gotcha:">🪤 Gotcha:</a></li><li><a href=#-translation aria-label="🧠 Translation:">🧠 Translation:</a></li><li><a href=#-real-world-example-1 aria-label="🧪 Real World Example:">🧪 Real World Example:</a></li><li><a href=#-why-does-this-matter aria-label="🧠 Why does this matter?">🧠 Why does this matter?</a></li><li><a href=#-performance aria-label="💥 Performance:">💥 Performance:</a></li><li><a href=#-important-connection aria-label="🧠 Important Connection:">🧠 Important Connection:</a></li><li><a href=#-key-example aria-label="🧪 Key Example:">🧪 Key Example:</a></li><li><a href=#-this-is-important-for-comparing-object-types aria-label="🧠 This is important for comparing object types:">🧠 This is important for comparing object types:</a></li><li><a href=#--this-is-the-key-gotcha aria-label="💥 🔥 This is the key gotcha:">💥 🔥 This is <strong>the key gotcha</strong>:</a></li></ul></li><li><a href=#-summary-realm-mental-model aria-label="🔄 Summary: Realm Mental Model">🔄 Summary: Realm Mental Model</a></li></ul></li><li><a href=#-breakdown-stack-and-execution-contexts aria-label="🔁 Breakdown: Stack and Execution Contexts">🔁 Breakdown: Stack and Execution Contexts</a><ul><li><a href=#-we-first-consider-synchronous-code-execution aria-label="📌 “We first consider synchronous code execution.”">📌 <strong>“We first consider synchronous code execution.”</strong></a></li><li><a href=#-each-job-enters-by-calling-its-associated-callback aria-label="📌 “Each job enters by calling its associated callback.”">📌 <strong>“Each job enters by calling its associated callback.”</strong></a></li><li><a href=#-code-inside-this-callback-may-create-variables-call-functions-or-exit aria-label="📌 “Code inside this callback may create variables, call functions, or exit.”">📌 <strong>“Code inside this callback may create variables, call functions, or exit.”</strong></a></li><li><a href=#-each-function-needs-to-keep-track-of-its-own-variable-environments-and-where-to-return-to aria-label="📌 “Each function needs to keep track of its own variable environments and where to return to.”">📌 <strong>“Each function needs to keep track of its own variable environments and where to return to.”</strong></a></li><li><a href=#-to-handle-this-the-agent-needs-a-stack-to-keep-track-of-the-execution-contexts aria-label="📌 “To handle this, the agent needs a stack to keep track of the execution contexts.”">📌 <strong>“To handle this, the agent needs a stack to keep track of the execution contexts.”</strong></a></li><li><a href=#-an-execution-context-also-known-generally-as-a-stack-frame-is-the-smallest-unit-of-execution aria-label="📌 “An execution context, also known generally as a stack frame, is the smallest unit of execution.”">📌 <strong>“An execution context, also known generally as a stack frame, is the smallest unit of execution.”</strong></a></li><li><a href=#-it-tracks-the-following-information aria-label="📌 “It tracks the following information…”">📌 <strong>“It tracks the following information…”</strong></a><ul><li><a href=#-code-evaluation-state aria-label="🔹 Code evaluation state">🔹 <strong>Code evaluation state</strong></a></li><li><a href=#-the-module-or-script-the-function-if-applicable-and-the-currently-executing-generator aria-label="🔹 The module or script, the function (if applicable), and the currently executing generator">🔹 <strong>The module or script, the function (if applicable), and the currently executing generator</strong></a></li><li><a href=#-the-current-realm aria-label="🔹 The current realm">🔹 <strong>The current realm</strong></a></li><li><a href=#-bindings aria-label="🔹 Bindings">🔹 <strong>Bindings</strong></a></li></ul></li></ul></li><li><a href=#-trace-the-example aria-label="🧠 Trace: The Example">🧠 Trace: The Example</a></li><li><a href=#-generators-and-reentry aria-label="🔁 Generators and Reentry">🔁 Generators and Reentry</a><ul><li><a href=#-when-a-frame-is-popped-its-not-necessarily-gone-forever aria-label="📌 “When a frame is popped, it’s not necessarily gone forever&mldr;”">📌 <strong>“When a frame is popped, it’s not necessarily gone forever&mldr;”</strong></a></li></ul></li><li><a href=#-tail-calls aria-label="🧬 Tail Calls">🧬 Tail Calls</a><ul><li><a href=#-if-a-function-call-is-in-tail-position aria-label="📌 “If a function call is in tail position…”">📌 <strong>“If a function call is in tail position…”</strong></a></li></ul></li><li><a href=#-closures aria-label="🔁 Closures">🔁 Closures</a><ul><li><a href=#-whenever-a-function-is-created-it-also-memorizes aria-label="📌 “Whenever a function is created, it also memorizes…”">📌 <strong>“Whenever a function is created, it also memorizes…”</strong></a></li></ul></li><li><a href=#-section-job-queue-and-event-loop aria-label="🔁 Section: Job Queue and Event Loop">🔁 Section: <strong>Job Queue and Event Loop</strong></a><ul><li><a href=#-an-agent-is-a-thread-which-means-the-interpreter-can-only-process-one-statement-at-a-time aria-label="📌 “An agent is a thread, which means the interpreter can only process one statement at a time.”">📌 <strong>“An agent is a thread, which means the interpreter can only process one statement at a time.”</strong></a></li><li><a href=#-when-the-code-is-all-synchronous-this-is-fine-because-we-can-always-make-progress aria-label="📌 “When the code is all synchronous, this is fine because we can always make progress.”">📌 <strong>“When the code is all synchronous, this is fine because we can always make progress.”</strong></a></li><li><a href=#-but-if-the-code-needs-to-perform-asynchronous-action-then-we-cannot-progress-unless-that-action-is-completed aria-label="📌 “But if the code needs to perform asynchronous action, then we cannot progress unless that action is completed.”">📌 <strong>“But if the code needs to perform asynchronous action, then we cannot progress unless that action is completed.”</strong></a></li><li><a href=#-however-it-would-be-detrimental-to-user-experience-if-that-halts-the-whole-program aria-label="📌 “However, it would be detrimental to user experience if that halts the whole program&mldr;”">📌 <strong>“However, it would be detrimental to user experience if that halts the whole program&mldr;”</strong></a></li><li><a href=#-therefore-the-code-that-handles-the-completion-of-that-asynchronous-action-is-defined-as-a-callback aria-label="📌 “Therefore, the code that handles the completion of that asynchronous action is defined as a callback.”">📌 <strong>“Therefore, the code that handles the completion of that asynchronous action is defined as a callback.”</strong></a></li><li><a href=#-this-callback-defines-a-job-which-gets-placed-into-a-job-queueor-in-html-terminology-an-event-looponce-the-action-is-completed aria-label="📌 “This callback defines a job, which gets placed into a job queue—or, in HTML terminology, an event loop—once the action is completed.”">📌 <strong>“This callback defines a job, which gets placed into a job queue—or, in HTML terminology, an event loop—once the action is completed.”</strong></a></li></ul></li><li><a href=#-summary-mental-model-so-far aria-label="🔄 Summary Mental Model So Far:">🔄 Summary Mental Model So Far:</a><ul><li><a href=#-every-time-the-agent-pulls-a-job-from-the-queue-and-executes-it aria-label="📌 “Every time, the agent pulls a job from the queue and executes it.”">📌 <strong>“Every time, the agent pulls a job from the queue and executes it.”</strong></a></li><li><a href=#-when-the-job-is-executed-it-may-create-more-jobs aria-label="📌 “When the job is executed, it may create more jobs…”">📌 <strong>“When the job is executed, it may create more jobs…”</strong></a></li><li><a href=#-jobs-might-not-be-pulled-with-uniform-priority aria-label="📌 “Jobs might not be pulled with uniform priority&mldr;”">📌 <strong>“Jobs might not be pulled with uniform priority&mldr;”</strong></a></li><li><a href=#-if-the-job-queue-is-empty-the-agent-waits-for-more-jobs-to-be-added aria-label="📌 “If the job queue is empty, the agent waits for more jobs to be added.”">📌 <strong>“If the job queue is empty, the agent waits for more jobs to be added.”</strong></a></li></ul></li><li><a href=#-run-to-completion aria-label="⚡ &ldquo;Run-to-completion&rdquo;">⚡ &ldquo;Run-to-completion&rdquo;</a><ul><li><a href=#-each-job-is-processed-completely-before-any-other-job-is-processed aria-label="📌 “Each job is processed completely before any other job is processed.”">📌 <strong>“Each job is processed completely before any other job is processed.”</strong></a></li><li><a href=#-whenever-a-function-runs-it-cannot-be-preempted aria-label="📌 “whenever a function runs, it cannot be preempted…”">📌 <strong>“whenever a function runs, it cannot be preempted…”</strong></a></li></ul></li><li><a href=#-downside-long-jobs-freeze-the-app aria-label="🚨 Downside: Long jobs freeze the app">🚨 Downside: Long jobs freeze the app</a><ul><li><a href=#-if-a-job-takes-too-long-to-complete-the-web-application-is-unable-to-process-user-interactions aria-label="📌 “if a job takes too long to complete, the web application is unable to process user interactions&mldr;”">📌 <strong>“if a job takes too long to complete, the web application is unable to process user interactions&mldr;”</strong></a></li></ul></li><li><a href=#-never-blocking aria-label="✅ Never Blocking">✅ Never Blocking</a><ul><li><a href=#-handling-io-is-typically-performed-via-events-and-callbacks aria-label="📌 “Handling I/O is typically performed via events and callbacks…”">📌 <strong>“Handling I/O is typically performed via events and callbacks…”</strong></a></li><li><a href=#--10 aria-label="📌 “&mldr;which defines a job to be added to the job queue once the action completes.”">📌 <strong>“&mldr;which defines a job to be added to the job queue once the action completes.”</strong></a></li><li><a href=#-some-legacy-exceptions-exist-like-alert-or-synchronous-xhr aria-label="📌 “Some legacy exceptions exist like alert() or synchronous XHR.”">📌 <strong>“Some legacy exceptions exist like alert() or synchronous XHR.”</strong></a></li></ul></li><li><a href=#-final-takeaway-mental-model aria-label="✅ Final Takeaway Mental Model">✅ Final Takeaway Mental Model</a></li><li><a href=#-section-1--agent-clusters-and-memory-sharing aria-label="📦 [SECTION 1] — Agent clusters and memory sharing">📦 [SECTION 1] — <strong>Agent clusters and memory sharing</strong></a><ul><li><a href=#-multiple-agents-can-communicate-via-memory-sharing-forming-an-agent-cluster aria-label="🔹 &ldquo;Multiple agents can communicate via memory sharing, forming an agent cluster.&rdquo;">🔹 &ldquo;<strong>Multiple agents can communicate via memory sharing, forming an agent cluster.</strong>&rdquo;</a></li><li><a href=#-agents-are-within-the-same-cluster-if-and-only-if-they-can-share-memory aria-label="🔹 &ldquo;Agents are within the same cluster if and only if they can share memory.&rdquo;">🔹 &ldquo;<strong>Agents are within the same cluster if and only if they can share memory.</strong>&rdquo;</a></li><li><a href=#-there-is-no-built-in-mechanism-for-two-agent-clusters-to-exchange-any-information aria-label="🔹 &ldquo;There is no built-in mechanism for two agent clusters to exchange any information&mldr; regarded as completely isolated execution models.&rdquo;">🔹 &ldquo;<strong>There is no built-in mechanism for two agent clusters to exchange any information&mldr; regarded as completely isolated execution models.</strong>&rdquo;</a></li></ul></li><li><a href=#-section-2--when-are-agents-in-the-same-cluster aria-label="🧱 [SECTION 2] — When are agents in the same cluster?">🧱 [SECTION 2] — <strong>When are agents in the same cluster?</strong></a><ul><li><a href=#-can-share-memory-same-agent-cluster aria-label="✅ CAN share memory (same agent cluster)">✅ <strong>CAN share memory (same agent cluster)</strong></a></li><li><a href=#-cannot-share-memory-different-agent-clusters aria-label="❌ CANNOT share memory (different agent clusters)">❌ <strong>CANNOT share memory (different agent clusters)</strong></a></li></ul></li><li><a href=#-section-3--cross-agent-communication-and-memory-model aria-label="📤 [SECTION 3] — Cross-agent communication and memory model">📤 [SECTION 3] — <strong>Cross-agent communication and memory model</strong></a><ul><li><a href=#-agents-communicate-via-memory-sharing aria-label="🔹 &ldquo;Agents communicate via memory sharing&rdquo;">🔹 &ldquo;<strong>Agents communicate via memory sharing</strong>&rdquo;</a></li><li><a href=#-typically-data-is-passed-by-value-only-via-structured-cloning aria-label="🔹 &ldquo;Typically, data is passed by value only (via structured cloning)&rdquo;">🔹 &ldquo;<strong>Typically, data is passed by value only (via structured cloning)</strong>&rdquo;</a></li><li><a href=#-to-share-memory-one-must-post-a- aria-label="🔹 &ldquo;To share memory, one must post a SharedArrayBuffer&mldr;&rdquo;">🔹 &ldquo;<strong>To share memory, one must post a <code>SharedArrayBuffer</code>&mldr;</strong>&rdquo;</a></li><li><a href=#-once-agents-share-memory aria-label="🔹 &ldquo;Once agents share memory&mldr; they can synchronize via Atomics&rdquo;">🔹 &ldquo;<strong>Once agents share memory&mldr; they can synchronize via <code>Atomics</code></strong>&rdquo;</a></li><li><a href=#-normal-memory-access-is-not-atomic aria-label="🔹 &ldquo;Normal memory access is not atomic&rdquo;">🔹 &ldquo;<strong>Normal memory access is not atomic</strong>&rdquo;</a></li><li><a href=#-atomic-access-is-sequentially-consistent aria-label="🔹 &ldquo;Atomic access is sequentially consistent&rdquo;">🔹 &ldquo;<strong>Atomic access is sequentially consistent</strong>&rdquo;</a></li><li><a href=#-non-atomic-access-is-unordered aria-label="🔹 &ldquo;Non-atomic access is unordered&rdquo;">🔹 &ldquo;<strong>Non-atomic access is unordered</strong>&rdquo;</a></li></ul></li><li><a href=#-section-4--guidelines-for-shared-memory-programs aria-label="🔒 [SECTION 4] — Guidelines for shared memory programs">🔒 [SECTION 4] — <strong>Guidelines for shared memory programs</strong></a><ul><li><a href=#-rule-1-make-it-data-race-free aria-label="🧠 Rule #1: Make it data-race free">🧠 Rule #1: <strong>Make it data-race free</strong></a></li><li><a href=#-rule-2-use-strongly-typed-memory-access aria-label="🧠 Rule #2: Use strongly typed memory access">🧠 Rule #2: <strong>Use strongly typed memory access</strong></a></li></ul></li><li><a href=#-section-5--concurrency-and-forward-progress aria-label="🚧 [SECTION 5] — Concurrency and forward progress">🚧 [SECTION 5] — <strong>Concurrency and forward progress</strong></a><ul><li><a href=#-an-agent-can-become-blocked aria-label="🔹 &ldquo;An agent can become blocked&mldr; waiting on another agent&rdquo;">🔹 &ldquo;<strong>An agent can become blocked&mldr; waiting on another agent</strong>&rdquo;</a></li><li><a href=#-forward-progress-guarantees aria-label="🔹 Forward progress guarantees:">🔹 <strong>Forward progress guarantees</strong>:</a></li><li><a href=#-only-certain-agents-can-be-blocked aria-label="🔹 Only certain agents can be blocked">🔹 <strong>Only certain agents can be blocked</strong></a></li><li><a href=#-agent-clusters-cannot-be-partially-deactivated aria-label="🔹 Agent clusters cannot be partially deactivated">🔹 <strong>Agent clusters cannot be partially deactivated</strong></a></li></ul></li><li><a href=#-section-6--cluster-termination aria-label="💥 [SECTION 6] — Cluster termination">💥 [SECTION 6] — <strong>Cluster termination</strong></a><ul><li><a href=#-an-agent-may-be-pausedresumedterminated-without-its-knowledge aria-label="🔹 &ldquo;An agent may be paused/resumed/terminated without its knowledge&rdquo;">🔹 &ldquo;<strong>An agent may be paused/resumed/terminated without its knowledge</strong>&rdquo;</a></li><li><a href=#-if-one-agent-in-a-cluster-is-terminated-all-are-terminated aria-label="🔹 &ldquo;If one agent in a cluster is terminated, all are terminated&rdquo;">🔹 &ldquo;<strong>If one agent in a cluster is terminated, all are terminated</strong>&rdquo;</a></li></ul></li><li><a href=#-summary-1 aria-label="🧠 Summary">🧠 Summary</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=js-execution-model>JS execution model<a hidden class=anchor aria-hidden=true href=#js-execution-model>#</a></h1><p>Alright, let’s break this down recursively and deeply, line by line, starting with the <strong>JavaScript execution model</strong> intro and progressing through the first sections. I’ll give you:</p><ol><li><strong>Literal meaning</strong> (What it says)</li><li><strong>Deeper understanding</strong> (Why it matters)</li><li><strong>Mental model / real-world analogy</strong> (To cement intuition)</li></ol><hr><h3 id=->📘 <strong>&ldquo;JavaScript execution model&rdquo;</strong><a hidden class=anchor aria-hidden=true href=#->#</a></h3><h4 id=-literal-meaning>✅ Literal meaning:<a hidden class=anchor aria-hidden=true href=#-literal-meaning>#</a></h4><p>This document explains how JavaScript runs behind the scenes — how it processes code, manages memory, handles functions, etc.</p><h4 id=-deeper-understanding>🔍 Deeper understanding:<a hidden class=anchor aria-hidden=true href=#-deeper-understanding>#</a></h4><p>Think of this as the operating system of JavaScript — what <em>actually happens</em> when you write <code>let a = 5</code> or <code>setTimeout(...)</code>.</p><h4 id=-analogy>🧠 Analogy:<a hidden class=anchor aria-hidden=true href=#-analogy>#</a></h4><p>If your code is like a script in a play, the execution model is the stage manager deciding when and how each line of the script gets read and acted upon.</p><hr><h3 id=--1>📝 <strong>&ldquo;This page introduces the basic infrastructure of the JavaScript runtime environment.&rdquo;</strong><a hidden class=anchor aria-hidden=true href=#--1>#</a></h3><h4 id=-literal-meaning-1>✅ Literal meaning:<a hidden class=anchor aria-hidden=true href=#-literal-meaning-1>#</a></h4><p>We’re talking about the <em>runtime</em> — where JS code is executed (not compiled). This includes things like memory, stacks, event loops, etc.</p><h4 id=-deeper-understanding-1>🔍 Deeper understanding:<a hidden class=anchor aria-hidden=true href=#-deeper-understanding-1>#</a></h4><p>JavaScript isn’t just interpreted randomly. There’s a whole structure that controls how code gets parsed, run, paused, resumed.</p><h4 id=-analogy-1>🧠 Analogy:<a hidden class=anchor aria-hidden=true href=#-analogy-1>#</a></h4><p>Imagine a kitchen: the runtime is the kitchen itself (countertop = stack, fridge = heap, bell = job queue). Chefs = JavaScript agents.</p><hr><h3 id=--2>🛠 <strong>&ldquo;The model is largely theoretical and abstract, without any platform-specific or implementation-specific details.&rdquo;</strong><a hidden class=anchor aria-hidden=true href=#--2>#</a></h3><h4 id=-literal-meaning-2>✅ Literal meaning:<a hidden class=anchor aria-hidden=true href=#-literal-meaning-2>#</a></h4><p>This isn’t about Chrome’s V8 engine or Node’s internals — it’s the universal, spec-level blueprint.</p><h4 id=-deeper-understanding-2>🔍 Deeper understanding:<a hidden class=anchor aria-hidden=true href=#-deeper-understanding-2>#</a></h4><p>You’re learning how things <em>should</em> behave according to ECMAScript — the spec all JS engines follow (more or less).</p><h4 id=-analogy-2>🧠 Analogy:<a hidden class=anchor aria-hidden=true href=#-analogy-2>#</a></h4><p>Like learning the <em>rules</em> of chess, not how Magnus Carlsen plays.</p><hr><h3 id=--3>🧠 <strong>&ldquo;Modern JavaScript engines heavily optimize the described semantics.&rdquo;</strong><a hidden class=anchor aria-hidden=true href=#--3>#</a></h3><h4 id=-literal-meaning-3>✅ Literal meaning:<a hidden class=anchor aria-hidden=true href=#-literal-meaning-3>#</a></h4><p>Real engines like V8 or SpiderMonkey tweak things under the hood for speed, but they follow the same rules.</p><h4 id=-deeper-understanding-3>🔍 Deeper understanding:<a hidden class=anchor aria-hidden=true href=#-deeper-understanding-3>#</a></h4><p>JS engines may compile JS to bytecode, inline functions, optimize away allocations — but logically, they obey this model.</p><h4 id=-analogy-3>🧠 Analogy:<a hidden class=anchor aria-hidden=true href=#-analogy-3>#</a></h4><p>Like a Formula 1 pit crew following safety rules — they do things super fast, but not incorrectly.</p><hr><h3 id=--4>📖 <strong>&ldquo;This page is a reference. It assumes you are already familiar with the execution model of other programming languages, such as C and Java.&rdquo;</strong><a hidden class=anchor aria-hidden=true href=#--4>#</a></h3><h4 id=-literal-meaning-4>✅ Literal meaning:<a hidden class=anchor aria-hidden=true href=#-literal-meaning-4>#</a></h4><p>If you’ve worked with languages that have stacks, heaps, and memory — this will feel familiar.</p><h4 id=-deeper-understanding-4>🔍 Deeper understanding:<a hidden class=anchor aria-hidden=true href=#-deeper-understanding-4>#</a></h4><p>JS is dynamic and event-driven, but under the hood, it&rsquo;s not that different from C/Java — it just hides more from you.</p><h4 id=-analogy-4>🧠 Analogy:<a hidden class=anchor aria-hidden=true href=#-analogy-4>#</a></h4><p>It’s like someone who’s driven automatic cars learning how a manual transmission works under the hood.</p><hr><h3 id=--5>🔧 <strong>&ldquo;It makes heavy references to existing concepts in operating systems and programming languages.&rdquo;</strong><a hidden class=anchor aria-hidden=true href=#--5>#</a></h3><h4 id=-literal-meaning-5>✅ Literal meaning:<a hidden class=anchor aria-hidden=true href=#-literal-meaning-5>#</a></h4><p>Terms like stack, heap, queue, thread — all come from OS/PL theory.</p><h4 id=-deeper-understanding-5>🔍 Deeper understanding:<a hidden class=anchor aria-hidden=true href=#-deeper-understanding-5>#</a></h4><p>This section connects JS to how <em>all</em> programming languages manage code execution and memory.</p><h4 id=-analogy-5>🧠 Analogy:<a hidden class=anchor aria-hidden=true href=#-analogy-5>#</a></h4><p>It’s like learning JavaScript’s &ldquo;internals&rdquo; by understanding its plumbing — threads, memory, job queues.</p><hr><p>Next section&mldr;</p><hr><h2 id=-the-engine-and-the-host>🔥 <strong>The engine and the host</strong><a hidden class=anchor aria-hidden=true href=#-the-engine-and-the-host>#</a></h2><h3 id=--6>🧩 <strong>&ldquo;JavaScript execution requires the cooperation of two pieces of software: the JavaScript engine and the host environment.&rdquo;</strong><a hidden class=anchor aria-hidden=true href=#--6>#</a></h3><h4 id=-literal-meaning-6>✅ Literal meaning:<a hidden class=anchor aria-hidden=true href=#-literal-meaning-6>#</a></h4><p>JS doesn’t run on its own. It needs:</p><ul><li>A <strong>JS engine</strong> (like V8, SpiderMonkey)</li><li>A <strong>host</strong> (like the browser or Node)</li></ul><h4 id=-deeper-understanding-6>🔍 Deeper understanding:<a hidden class=anchor aria-hidden=true href=#-deeper-understanding-6>#</a></h4><p>The engine knows how to <em>parse</em> and <em>run</em> JavaScript.
The host (browser/Node) knows how to <em>give JS things to do</em> — like making network requests or rendering HTML.</p><h4 id=-analogy-6>🧠 Analogy:<a hidden class=anchor aria-hidden=true href=#-analogy-6>#</a></h4><p>The JS engine is the actor. The host is the stage, props, lighting, and audience.</p><hr><h3 id=--7>🧠 <strong>&ldquo;The JavaScript engine implements the ECMAScript (JavaScript) language, providing the core functionality.&rdquo;</strong><a hidden class=anchor aria-hidden=true href=#--7>#</a></h3><h4 id=-literal-meaning-7>✅ Literal meaning:<a hidden class=anchor aria-hidden=true href=#-literal-meaning-7>#</a></h4><p>The engine knows what <code>let</code>, <code>function</code>, <code>Promise</code>, etc., mean. That’s ECMAScript.</p><h4 id=-deeper-understanding-7>🔍 Deeper understanding:<a hidden class=anchor aria-hidden=true href=#-deeper-understanding-7>#</a></h4><p>Things like <code>setTimeout</code> or <code>document.querySelector</code>? Those are host-provided, not part of the language spec.</p><h4 id=-analogy-7>🧠 Analogy:<a hidden class=anchor aria-hidden=true href=#-analogy-7>#</a></h4><p>The engine knows English. The host gives it a job — like reading a book, or talking to a user.</p><hr><h3 id=--8>🌍 <strong>&ldquo;In order to interact with the outside world [&mldr;] we need additional environment-specific mechanisms provided by the host environment.&rdquo;</strong><a hidden class=anchor aria-hidden=true href=#--8>#</a></h3><h4 id=-literal-meaning-8>✅ Literal meaning:<a hidden class=anchor aria-hidden=true href=#-literal-meaning-8>#</a></h4><p>To talk to files, web APIs, timers, you need help from the host — JS alone can’t do it.</p><h4 id=-deeper-understanding-8>🔍 Deeper understanding:<a hidden class=anchor aria-hidden=true href=#-deeper-understanding-8>#</a></h4><p>This is where browsers give us <code>document</code>, and Node gives us <code>fs</code>, etc. It’s why JS looks different in each environment.</p><h4 id=-analogy-8>🧠 Analogy:<a hidden class=anchor aria-hidden=true href=#-analogy-8>#</a></h4><p>JavaScript is a brilliant chef, but it needs the host to supply groceries, an oven, or even the guests to cook for.</p><hr><h3 id=--9>🌐 <strong>&ldquo;For example, the HTML DOM is the host environment when JavaScript is executed in a web browser. Node.js is another host environment&mldr;&rdquo;</strong><a hidden class=anchor aria-hidden=true href=#--9>#</a></h3><h4 id=-literal-meaning-9>✅ Literal meaning:<a hidden class=anchor aria-hidden=true href=#-literal-meaning-9>#</a></h4><p>DOM and <code>window</code> exist only in the browser. <code>require</code> and <code>process</code> exist only in Node.</p><h4 id=-deeper-understanding-9>🔍 Deeper understanding:<a hidden class=anchor aria-hidden=true href=#-deeper-understanding-9>#</a></h4><p>Same language, different surroundings = different power/tools. JS is <em>host-agnostic</em>; host APIs change.</p><h4 id=-analogy-9>🧠 Analogy:<a hidden class=anchor aria-hidden=true href=#-analogy-9>#</a></h4><p>Same actor, different movie set. A sci-fi set vs. a historical drama set gives the actor different things to interact with.</p><hr><p>Awesome — let&rsquo;s dive into a <strong>line-by-line, recursive breakdown</strong> of the JavaScript Execution Model section. I&rsquo;ll break down each sentence, unpack the underlying concepts, and relate them to real-world analogies and code where helpful.</p><hr><h3 id=javascript-execution-model>🔹<strong>JavaScript execution model</strong><a hidden class=anchor aria-hidden=true href=#javascript-execution-model>#</a></h3><blockquote><p><strong>This page introduces the basic infrastructure of the JavaScript runtime environment.</strong></p></blockquote><ul><li><strong>Breakdown:</strong> We’re about to learn how JavaScript runs &ldquo;under the hood.&rdquo; That means looking beyond syntax into how your code gets executed, managed, and scheduled by the JS engine.</li></ul><blockquote><p><strong>The model is largely theoretical and abstract, without any platform-specific or implementation-specific details.</strong></p></blockquote><ul><li><strong>Breakdown:</strong> This is not about how Chrome, Node, or Deno <em>implement</em> JavaScript — it’s about the ECMAScript <strong>specification-level model</strong>. Think of this as the universal blueprint all JS engines follow.</li></ul><blockquote><p><strong>Modern JavaScript engines heavily optimize the described semantics.</strong></p></blockquote><ul><li><strong>Breakdown:</strong> V8 (Chrome), SpiderMonkey (Firefox), and others add many performance improvements — JIT compilation, inlining, hidden classes — but they <strong>preserve the behavior</strong> defined in this theoretical model.</li></ul><hr><h3 id=this-page-is-a-reference-it-assumes-you-are-already-familiar-with-the-execution-model-of-other-programming-languages-such-as-c-and-java>🔹<strong>This page is a reference. It assumes you are already familiar with the execution model of other programming languages, such as C and Java.</strong><a hidden class=anchor aria-hidden=true href=#this-page-is-a-reference-it-assumes-you-are-already-familiar-with-the-execution-model-of-other-programming-languages-such-as-c-and-java>#</a></h3><ul><li><strong>Breakdown:</strong> It expects you know what a <em>call stack</em>, <em>heap</em>, and <em>execution context</em> are from other languages — but don&rsquo;t worry, we’ll unpack everything from a JavaScript-first view.</li></ul><hr><h3 id=the-engine-and-the-host>🔹<strong>The engine and the host</strong><a hidden class=anchor aria-hidden=true href=#the-engine-and-the-host>#</a></h3><blockquote><p><strong>JavaScript execution requires the cooperation of two pieces of software: the JavaScript engine and the host environment.</strong></p></blockquote><ul><li><strong>Breakdown:</strong><ul><li><strong>Engine</strong> → Understands & runs JS (e.g. V8, SpiderMonkey).</li><li><strong>Host</strong> → Provides APIs <strong>outside</strong> of JS (e.g., the DOM, <code>setTimeout</code>, <code>fs</code> in Node).</li></ul></li></ul><p>📌 Analogy: The engine is the actor, but the host is the stage, props, and audience.</p><hr><blockquote><p><strong>The JavaScript engine implements the ECMAScript (JavaScript) language, providing the core functionality. It takes source code, parses it, and executes it.</strong></p></blockquote><ul><li><strong>Breakdown:</strong><ol><li><strong>Parses</strong> → Converts your code into an Abstract Syntax Tree (AST).</li><li><strong>Executes</strong> → Evaluates it via interpreters or compilers.</li></ol></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>let</span> <span class=nx>x</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span></code></pre></div><ul><li>Engine knows how to parse and execute this, but not how to access the DOM. That’s the host&rsquo;s job.</li></ul><hr><blockquote><p><strong>However, in order to interact with the outside world, such as to produce any meaningful output, to interface with external resources, or to implement security- or performance-related mechanisms, we need additional environment-specific mechanisms provided by the host environment.</strong></p></blockquote><ul><li><strong>Breakdown:</strong> Engine alone can’t do I/O, networking, file access. Host provides:<ul><li><code>console.log</code>, <code>fetch</code>, <code>setTimeout</code>, <code>document</code>, <code>process.env</code>, etc.</li></ul></li></ul><hr><blockquote><p><strong>For example, the HTML DOM is the host environment when JavaScript is executed in a web browser. Node.js is another host environment that allows JavaScript to be run on the server side.</strong></p></blockquote><ul><li><strong>Breakdown:</strong><ul><li>Browser = JS engine + DOM + <code>window</code> + events.</li><li>Node = JS engine + <code>fs</code>, <code>http</code>, <code>Buffer</code>, <code>process</code>, etc.</li></ul></li></ul><hr><blockquote><p><strong>While we focus primarily on the mechanisms defined in ECMAScript in this reference, we will occasionally talk about mechanisms defined in the HTML spec, which is often mimicked by other host environments like Node.js or Deno.</strong></p></blockquote><ul><li><strong>Breakdown:</strong><ul><li>Core focus = ECMAScript (language spec).</li><li>But we&rsquo;ll touch on HTML-defined behaviors (like the Event Loop, microtasks) — because Node/Deno borrow them too.</li></ul></li></ul><hr><h3 id=agent-execution-model>🔹<strong>Agent Execution Model</strong><a hidden class=anchor aria-hidden=true href=#agent-execution-model>#</a></h3><blockquote><p><strong>In the JavaScript specification, each autonomous executor of JavaScript is called an agent, which maintains its facilities for code execution:</strong></p></blockquote><ul><li><strong>Breakdown:</strong><ul><li>Think of an <strong>agent</strong> as an independent &ldquo;runner&rdquo; of JavaScript — like a tab, worker, or Node thread.</li><li>Each agent has its own <strong>heap</strong>, <strong>call stack</strong>, and <strong>job queue</strong>.</li></ul></li></ul><hr><p>Now, let’s recursively unpack the <strong>three components</strong> of an agent:</p><hr><h4 id=-heap-of-objects>🔸 <strong>Heap (of objects)</strong><a hidden class=anchor aria-hidden=true href=#-heap-of-objects>#</a></h4><blockquote><p><strong>This is just a name to denote a large (mostly unstructured) region of memory. It gets populated as objects get created in the program.</strong></p></blockquote><ul><li><strong>Breakdown:</strong><ul><li>Heap = where <strong>reference types</strong> live: objects, arrays, closures, functions.</li><li>Variables like <code>let obj = {}</code> create entries in the heap.</li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>let</span> <span class=nx>obj</span> <span class=o>=</span> <span class=p>{</span> <span class=nx>name</span><span class=o>:</span> <span class=s2>&#34;you&#34;</span> <span class=p>};</span>
</span></span></code></pre></div><p>The object lives in the heap; <code>obj</code> points to it.</p><hr><blockquote><p><strong>Note that in the case of shared memory, each agent has its own heap with its own version of a SharedArrayBuffer object, but the underlying memory represented by the buffer is shared.</strong></p></blockquote><ul><li><strong>Breakdown:</strong><ul><li>Each worker/tab has its own isolated heap — but <strong>shared memory</strong> (via <code>SharedArrayBuffer</code>) creates <strong>cross-agent bridges</strong>.</li><li>Shared memory enables atomic operations between agents.</li></ul></li></ul><p>📌 Think: <em>Multiple agents → own memory → but one shared space for coordination</em>.</p><hr><h4 id=-queue-of-jobs>🔸 <strong>Queue (of jobs)</strong><a hidden class=anchor aria-hidden=true href=#-queue-of-jobs>#</a></h4><blockquote><p><strong>This is known in HTML (and also commonly) as the event loop which enables asynchronous programming in JavaScript while being single-threaded.</strong></p></blockquote><ul><li><strong>Breakdown:</strong><ul><li>Queue = <strong>Job Queue / Task Queue</strong>.</li><li>Works with the <strong>event loop</strong> to schedule <strong>async tasks</strong> (like <code>setTimeout</code>, Promises).</li></ul></li></ul><hr><blockquote><p><strong>It&rsquo;s called a queue because it&rsquo;s generally first-in-first-out: earlier jobs are executed before later ones.</strong></p></blockquote><ul><li><strong>Breakdown:</strong><ul><li>Classic <strong>FIFO</strong> structure.</li><li>Tasks are queued and <strong>executed one by one</strong>, preserving order.</li></ul></li></ul><hr><h4 id=-stack-of-execution-contexts>🔸 <strong>Stack (of execution contexts)</strong><a hidden class=anchor aria-hidden=true href=#-stack-of-execution-contexts>#</a></h4><blockquote><p><strong>This is what&rsquo;s known as a call stack and allows transferring control flow by entering and exiting execution contexts like functions.</strong></p></blockquote><ul><li><strong>Breakdown:</strong><ul><li>Stack = execution history — functions being called and exited.</li><li>LIFO — last-in, first-out.</li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>a</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>b</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>b</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>c</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>a</span><span class=p>();</span> <span class=c1>// a → b → c → return → return → return
</span></span></span></code></pre></div><hr><blockquote><p><strong>It&rsquo;s called a stack because it&rsquo;s last-in-first-out. Every job enters by pushing a new frame onto the (empty) stack, and exits by emptying the stack.</strong></p></blockquote><ul><li><strong>Breakdown:</strong><ul><li>A function call pushes a <strong>frame</strong> onto the stack.</li><li>When it returns, the frame is popped off.</li></ul></li></ul><hr><blockquote><p><strong>These are three distinct data structures that keep track of different data.</strong></p></blockquote><ul><li><strong>Heap</strong> → Long-lived objects.</li><li><strong>Queue</strong> → Pending jobs (like <code>fetch().then()</code>).</li><li><strong>Stack</strong> → Current execution chain (call stack).</li></ul><hr><blockquote><p><strong>We will introduce the queue and the stack in more detail in the following sections. To read more about how heap memory is allocated and freed, see memory management.</strong></p></blockquote><ul><li><strong>Breakdown:</strong><ul><li>Stack and queue will be our main focus because they control <strong>how code runs</strong>.</li><li>Heap is for <strong>storage</strong>, not <strong>flow</strong>.</li></ul></li></ul><hr><h3 id=-up-next>🧠 Up Next:<a hidden class=anchor aria-hidden=true href=#-up-next>#</a></h3><p>We’ll dive into the next section — <strong>realms</strong>, agents on the web (workers, windows), and how these fit together using the diagram you shared.</p><p>Want to continue into that next?</p><p>Awesome — let’s go <em>line by line</em>, <em>step by step</em>, <em>recursively breaking down</em> every idea here. I&rsquo;ll unpack it intuitively, back it up with examples, and link it to real-world behavior.</p><hr><h2 id=-line-1>🔹 Line 1:<a hidden class=anchor aria-hidden=true href=#-line-1>#</a></h2><blockquote><p><strong>&ldquo;These are three distinct data structures that keep track of different data.&rdquo;</strong></p></blockquote><h3 id=-intuition>🧠 Intuition:<a hidden class=anchor aria-hidden=true href=#-intuition>#</a></h3><p>In the agent model, three “buckets” manage different responsibilities:</p><table><thead><tr><th>Structure</th><th>Purpose</th><th>Example</th></tr></thead><tbody><tr><td><strong>Heap</strong></td><td>Stores all dynamic data (objects, functions)</td><td><code>{name: "John"}</code> or an array <code>[1,2,3]</code> lives here</td></tr><tr><td><strong>Queue</strong></td><td>List of &ldquo;jobs&rdquo; waiting to run (asynchronous tasks)</td><td><code>setTimeout(() => {}, 1000)</code> gets added to queue</td></tr><tr><td><strong>Stack</strong></td><td>Keeps track of what function is running right now</td><td>When calling functions, stack tracks &ldquo;who called who&rdquo;</td></tr></tbody></table><h3 id=-real-world-analogy>🎯 Real-World Analogy:<a hidden class=anchor aria-hidden=true href=#-real-world-analogy>#</a></h3><ul><li><strong>Heap</strong> = Warehouse of data</li><li><strong>Stack</strong> = A to-do list that follows <em>last in, first out</em> — newest task gets done first</li><li><strong>Queue</strong> = A waiting room — <em>first in, first out</em> — oldest task gets picked up first</li></ul><hr><h2 id=-line-2>🔹 Line 2:<a hidden class=anchor aria-hidden=true href=#-line-2>#</a></h2><blockquote><p><strong>&ldquo;We will introduce the queue and the stack in more detail in the following sections.&rdquo;</strong></p></blockquote><h3 id=-intuition-1>🧠 Intuition:<a hidden class=anchor aria-hidden=true href=#-intuition-1>#</a></h3><ul><li>They’re setting you up: <em>heap</em> is mostly a memory detail (not directly manipulated much), but <em>queue</em> and <em>stack</em> are <strong>critical</strong> to how JavaScript behaves, especially:<ul><li>Why async code works</li><li>Why <code>console.log</code> runs before a <code>setTimeout</code></li><li>Why promises feel synchronous sometimes</li></ul></li></ul><p>You&rsquo;ll learn:</p><ul><li>Stack: Why recursion fails with “maximum call stack size exceeded”</li><li>Queue: Why this logs in order:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;A&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;B&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;C&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Output: A C B
</span></span></span></code></pre></div><hr><h2 id=-line-3>🔹 Line 3:<a hidden class=anchor aria-hidden=true href=#-line-3>#</a></h2><blockquote><p><strong>&ldquo;To read more about how heap memory is allocated and freed, see memory management.&rdquo;</strong></p></blockquote><h3 id=-intuition-2>🧠 Intuition:<a hidden class=anchor aria-hidden=true href=#-intuition-2>#</a></h3><p>The <strong>heap</strong> is where all your objects live — and they stick around as long as something <em>references</em> them.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>let</span> <span class=nx>x</span> <span class=o>=</span> <span class=p>{</span> <span class=nx>name</span><span class=o>:</span> <span class=s2>&#34;Alice&#34;</span> <span class=p>};</span> <span class=c1>// stored in the heap
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>x</span> <span class=o>=</span> <span class=kc>null</span><span class=p>;</span> <span class=c1>// garbage collected (freed from heap eventually)
</span></span></span></code></pre></div><p>No manual memory management in JS. The garbage collector watches references.</p><hr><h2 id=-line-4>🔹 Line 4:<a hidden class=anchor aria-hidden=true href=#-line-4>#</a></h2><blockquote><p><strong>&ldquo;Each agent is analogous to a thread (note that the underlying implementation may or may not be an actual operating system thread).&rdquo;</strong></p></blockquote><h3 id=-key-concept-agent--thread>🧠 Key Concept: <strong>Agent ≈ Thread</strong><a hidden class=anchor aria-hidden=true href=#-key-concept-agent--thread>#</a></h3><p>But not exactly.</p><ul><li><strong>JavaScript itself is single-threaded</strong> — only <em>one agent</em> running main code.</li><li>But environments (like browsers or Node.js) <em>spawn multiple agents</em> (like Web Workers).</li></ul><p>🔍 Important: <em>Just because JavaScript feels single-threaded doesn&rsquo;t mean there&rsquo;s only one thread underneath.</em></p><blockquote><p>Example: If you use a <strong>Web Worker</strong>, that code runs in its own agent, with its <strong>own heap, queue, and stack</strong>.</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// main.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>worker</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Worker</span><span class=p>(</span><span class=s2>&#34;worker.js&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// worker.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>onmessage</span> <span class=o>=</span> <span class=p>(</span><span class=nx>e</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// This is a separate agent!
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>postMessage</span><span class=p>(</span><span class=s2>&#34;Got it&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><hr><h2 id=-line-5>🔹 Line 5:<a hidden class=anchor aria-hidden=true href=#-line-5>#</a></h2><blockquote><p><strong>&ldquo;Each agent can own multiple realms (which 1-to-1 correlate with global objects) that can synchronously access each other, and thus needs to run in a single execution thread.&rdquo;</strong></p></blockquote><h3 id=-intuition-3>🧠 Intuition:<a hidden class=anchor aria-hidden=true href=#-intuition-3>#</a></h3><ul><li>A <strong>realm</strong> is like a <strong>sandboxed environment</strong>: it has its own <code>globalThis</code>, <code>Array</code>, <code>Function</code>, etc.</li><li>Inside one agent, multiple realms can talk to each other <strong>synchronously</strong> (because they share the same stack/queue).</li></ul><p>📦 Real-world example:</p><ul><li>In a browser, your main page and a <strong>same-origin iframe</strong> are in the same agent, but <strong>different realms</strong>.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>iframe</span> <span class=na>src</span><span class=o>=</span><span class=s>&#34;same-origin.html&#34;</span><span class=p>&gt;&lt;/</span><span class=nt>iframe</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Inside both:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nb>window</span><span class=p>.</span><span class=nb>Array</span> <span class=o>===</span> <span class=nx>iframe</span><span class=p>.</span><span class=nx>contentWindow</span><span class=p>.</span><span class=nb>Array</span><span class=p>);</span> <span class=c1>// ❌ false
</span></span></span></code></pre></div><p>Why? Different realms, different versions of built-in objects like <code>Array</code>.</p><hr><h2 id=-line-6>🔹 Line 6:<a hidden class=anchor aria-hidden=true href=#-line-6>#</a></h2><blockquote><p><strong>&ldquo;An agent also has a single memory model, indicating whether it&rsquo;s little-endian, whether it can be synchronously blocked, whether atomic operations are lock-free, etc.&rdquo;</strong></p></blockquote><h3 id=-what-this-means>🧠 What this means:<a hidden class=anchor aria-hidden=true href=#-what-this-means>#</a></h3><p>This dives into <strong>low-level behavior</strong>, useful when you’re dealing with <strong>shared memory</strong> (e.g., <code>SharedArrayBuffer</code>) and <strong>concurrency</strong>.</p><ul><li><strong>Little-endian</strong>: Byte ordering in memory (most systems are little-endian).</li><li><strong>Lock-free atomic operations</strong>: Allows agents to coordinate via memory safely.</li><li><strong>Synchronous blocking</strong>: Whether one agent can halt another (usually avoided in JS for responsiveness).</li></ul><p>🛠 You’ll care about this if you&rsquo;re:</p><ul><li>Using <code>Atomics.wait</code> / <code>Atomics.notify</code></li><li>Coordinating workers via shared memory</li><li>Doing real-time or performance-critical code</li></ul><hr><h2 id=-summary-table>✅ Summary Table<a hidden class=anchor aria-hidden=true href=#-summary-table>#</a></h2><table><thead><tr><th>Concept</th><th>What It Does</th><th>Practical Example</th></tr></thead><tbody><tr><td>Heap</td><td>Stores all objects</td><td><code>{ user: "A" }</code></td></tr><tr><td>Stack</td><td>Tracks function calls</td><td><code>foo()</code> calls <code>bar()</code></td></tr><tr><td>Queue</td><td>Holds async jobs</td><td><code>setTimeout()</code>, <code>Promise.then()</code></td></tr><tr><td>Agent</td><td>Self-contained executor (heap+stack+queue)</td><td>Main thread or Worker</td></tr><tr><td>Realm</td><td>Global environment inside an agent</td><td>Main page vs iframe</td></tr><tr><td>Memory Model</td><td>Rules for memory access</td><td><code>SharedArrayBuffer</code>, <code>Atomics</code></td></tr></tbody></table><hr><h3 id=-want-to-go-deeper-into-one-of-these-now>🔥 Want to go deeper into one of these now?<a hidden class=anchor aria-hidden=true href=#-want-to-go-deeper-into-one-of-these-now>#</a></h3><p>I can:</p><ul><li>Visualize how a realm compares to an agent</li><li>Show a step-by-step simulation of the stack and queue</li><li>Break down how two agents use shared memory safely</li></ul><p>Let me know your next target — I’m ready to go recursive on it.</p><p>Great! Let&rsquo;s continue the <strong>recursive breakdown</strong> from where we left off. We just finished:</p><blockquote><p>&ldquo;An agent also has a single memory model, indicating whether it&rsquo;s little-endian, whether it can be synchronously blocked, whether atomic operations are lock-free, etc.&rdquo;</p></blockquote><p>Now, the next part of the MDN doc says:</p><hr><h2 id=-next-block>📌 Next block:<a hidden class=anchor aria-hidden=true href=#-next-block>#</a></h2><blockquote><h3 id=an-agent-on-the-web-can-be-one-of-the-following>“An agent on the web can be one of the following:<a hidden class=anchor aria-hidden=true href=#an-agent-on-the-web-can-be-one-of-the-following>#</a></h3><ul><li>A Similar-origin window agent, which contains various Window objects which can potentially reach each other, either directly or by using <code>document.domain</code>. If the window is origin-keyed, then only same-origin windows can reach each other.</li><li>A Dedicated worker agent containing a single <code>DedicatedWorkerGlobalScope</code>.</li><li>A Shared worker agent containing a single <code>SharedWorkerGlobalScope</code>.</li><li>A Service worker agent containing a single <code>ServiceWorkerGlobalScope</code>.</li><li>A Worklet agent containing a single <code>WorkletGlobalScope</code>.”</li></ul></blockquote><hr><h3 id=-lets-go-line-by-line-and-recursively-break-this-down>✅ Let&rsquo;s go <strong>line-by-line and recursively break this down</strong>:<a hidden class=anchor aria-hidden=true href=#-lets-go-line-by-line-and-recursively-break-this-down>#</a></h3><hr><h3 id=-line-1-1>🔹 Line 1:<a hidden class=anchor aria-hidden=true href=#-line-1-1>#</a></h3><blockquote><p><strong>&ldquo;An agent on the web can be one of the following:&rdquo;</strong></p></blockquote><p>🧠 <strong>Big idea</strong>: On the web, <strong>each type of “execution environment”</strong> (like a browser tab, a worker, etc.) is backed by its own <strong>agent</strong> — meaning it has its own <strong>heap</strong>, <strong>stack</strong>, and <strong>queue</strong>.</p><blockquote><p>Think of each agent as its own little JS runtime.</p></blockquote><hr><h3 id=-line-2-1>🔹 Line 2:<a hidden class=anchor aria-hidden=true href=#-line-2-1>#</a></h3><blockquote><p><strong>&ldquo;A Similar-origin window agent, which contains various Window objects which can potentially reach each other, either directly or by using <code>document.domain</code>. If the window is origin-keyed, then only same-origin windows can reach each other.&rdquo;</strong></p></blockquote><h3 id=-whats-going-on-here>🧠 What&rsquo;s going on here?<a hidden class=anchor aria-hidden=true href=#-whats-going-on-here>#</a></h3><p>A <strong>window agent</strong> = Your main page + all <strong>same-origin iframes</strong> you embed in it.</p><h4 id=-shared-agent-example>🔄 Shared Agent Example:<a hidden class=anchor aria-hidden=true href=#-shared-agent-example>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl><span class=c>&lt;!-- index.html --&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>iframe</span> <span class=na>src</span><span class=o>=</span><span class=s>&#34;https://yourdomain.com/page.html&#34;</span><span class=p>&gt;&lt;/</span><span class=nt>iframe</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>These two can <strong>share memory and synchronously access each other</strong>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// From parent page
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nb>window</span><span class=p>.</span><span class=nx>frames</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=nb>document</span><span class=p>.</span><span class=nx>body</span><span class=p>);</span>
</span></span></code></pre></div><p>🧪 But if the iframe is cross-origin, access is blocked for security.</p><h4 id=-security-twist>⚠️ Security twist:<a hidden class=anchor aria-hidden=true href=#-security-twist>#</a></h4><p>If <code>document.domain</code> is set (deprecated but still used), two <strong>subdomains</strong> can loosen the restriction a bit.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// both pages set
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>document</span><span class=p>.</span><span class=nx>domain</span> <span class=o>=</span> <span class=s2>&#34;example.com&#34;</span><span class=p>;</span>
</span></span></code></pre></div><p>Then they can reach each other, even if one is <code>a.example.com</code> and one is <code>b.example.com</code>.</p><hr><h3 id=-line-3-1>🔹 Line 3:<a hidden class=anchor aria-hidden=true href=#-line-3-1>#</a></h3><blockquote><p><strong>&ldquo;A Dedicated worker agent containing a single <code>DedicatedWorkerGlobalScope</code>.&rdquo;</strong></p></blockquote><h3 id=-what-is-a-dedicated-worker-agent>🧠 What is a <strong>Dedicated Worker Agent</strong>?<a hidden class=anchor aria-hidden=true href=#-what-is-a-dedicated-worker-agent>#</a></h3><p>When you create a <strong>Web Worker</strong> in the browser:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>worker</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Worker</span><span class=p>(</span><span class=s2>&#34;worker.js&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>That script (<code>worker.js</code>) runs in its own <strong>dedicated worker agent</strong> — with its <strong>own heap, queue, and stack</strong> — completely separate from the main thread.</p><p>🔁 Communication is done <strong>asynchronously</strong> via <code>postMessage()</code> — like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// main.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>worker</span><span class=p>.</span><span class=nx>postMessage</span><span class=p>(</span><span class=s2>&#34;hi&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// worker.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>onmessage</span> <span class=o>=</span> <span class=p>(</span><span class=nx>e</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Got:&#34;</span><span class=p>,</span> <span class=nx>e</span><span class=p>.</span><span class=nx>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><blockquote><p>⚠️ You <strong>cannot</strong> synchronously access memory between main thread and a dedicated worker (unless using <code>SharedArrayBuffer</code>).</p></blockquote><hr><h3 id=-line-4-1>🔹 Line 4:<a hidden class=anchor aria-hidden=true href=#-line-4-1>#</a></h3><blockquote><p><strong>&ldquo;A Shared worker agent containing a single <code>SharedWorkerGlobalScope</code>.&rdquo;</strong></p></blockquote><h3 id=-difference-between-shared-worker-and-dedicated-worker>🧠 Difference between <strong>Shared Worker</strong> and <strong>Dedicated Worker</strong>?<a hidden class=anchor aria-hidden=true href=#-difference-between-shared-worker-and-dedicated-worker>#</a></h3><ul><li><strong>Dedicated Worker</strong>: Only 1 page can talk to it.</li><li><strong>Shared Worker</strong>: Multiple tabs (from the same origin) can talk to the same worker.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// In two tabs of the same site:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>sharedWorker</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>SharedWorker</span><span class=p>(</span><span class=s2>&#34;worker.js&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>Now both tabs talk to the same long-living agent!</p><p>Why use this?</p><ul><li>Share data between tabs</li><li>Maintain a centralized cache</li><li>Reduce memory usage</li></ul><p>📦 But again — it&rsquo;s <strong>a separate agent</strong> with <strong>its own stack/heap/queue</strong>.</p><hr><h3 id=-line-5-1>🔹 Line 5:<a hidden class=anchor aria-hidden=true href=#-line-5-1>#</a></h3><blockquote><p><strong>&ldquo;A Service worker agent containing a single <code>ServiceWorkerGlobalScope</code>.&rdquo;</strong></p></blockquote><h3 id=-whats-special-about-service-workers>🧠 What’s special about <strong>Service Workers</strong>?<a hidden class=anchor aria-hidden=true href=#-whats-special-about-service-workers>#</a></h3><ul><li>They’re <strong>background scripts</strong> that sit between your site and the network.</li><li>Intercept requests (<code>fetch</code>), cache stuff, serve offline pages.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// Registering a service worker
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>navigator</span><span class=p>.</span><span class=nx>serviceWorker</span><span class=p>.</span><span class=nx>register</span><span class=p>(</span><span class=s2>&#34;sw.js&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>🧠 They:</p><ul><li>Outlive pages</li><li>Don’t have access to DOM</li><li>Run in <strong>their own agent</strong></li></ul><p>💡 Use case:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>self</span><span class=p>.</span><span class=nx>addEventListener</span><span class=p>(</span><span class=s2>&#34;fetch&#34;</span><span class=p>,</span> <span class=p>(</span><span class=nx>event</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>event</span><span class=p>.</span><span class=nx>respondWith</span><span class=p>(</span><span class=nx>caches</span><span class=p>.</span><span class=nx>match</span><span class=p>(</span><span class=nx>event</span><span class=p>.</span><span class=nx>request</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></div><p>Service workers have a <strong>completely isolated memory space</strong> and no direct access to the DOM.</p><hr><h3 id=-line-6-1>🔹 Line 6:<a hidden class=anchor aria-hidden=true href=#-line-6-1>#</a></h3><blockquote><p><strong>&ldquo;A Worklet agent containing a single <code>WorkletGlobalScope</code>.&rdquo;</strong></p></blockquote><h3 id=-whats-a-worklet>🧠 What’s a <strong>Worklet</strong>?<a hidden class=anchor aria-hidden=true href=#-whats-a-worklet>#</a></h3><p>Advanced topic — used for things like:</p><ul><li><strong>CSS Paint API</strong></li><li><strong>Web Audio API (AudioWorklet)</strong></li><li><strong>Animations</strong></li></ul><p>🔊 Example: An <code>AudioWorklet</code> lets you do <strong>low-latency audio processing</strong> on a separate thread (agent).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// In main thread
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>audioContext</span><span class=p>.</span><span class=nx>audioWorklet</span><span class=p>.</span><span class=nx>addModule</span><span class=p>(</span><span class=s2>&#34;processor.js&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// processor.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>class</span> <span class=nx>MyProcessor</span> <span class=kr>extends</span> <span class=nx>AudioWorkletProcessor</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>process</span><span class=p>(</span><span class=nx>inputs</span><span class=p>,</span> <span class=nx>outputs</span><span class=p>,</span> <span class=nx>parameters</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// run audio processing
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>registerProcessor</span><span class=p>(</span><span class=s2>&#34;my-processor&#34;</span><span class=p>,</span> <span class=nx>MyProcessor</span><span class=p>);</span>
</span></span></code></pre></div><p>These agents are <strong>super-lightweight</strong>, meant for <strong>tiny, focused jobs</strong> like drawing or audio frames.</p><hr><h2 id=-summary>🧠 Summary:<a hidden class=anchor aria-hidden=true href=#-summary>#</a></h2><table><thead><tr><th>Agent Type</th><th>Runs in</th><th>Has Own Stack/Heap/Queue?</th><th>Use Case</th></tr></thead><tbody><tr><td>Similar-origin Window Agent</td><td>Main page + iframes (same origin)</td><td>✅ Yes</td><td>Regular DOM pages</td></tr><tr><td>Dedicated Worker Agent</td><td>Worker created via <code>new Worker()</code></td><td>✅ Yes</td><td>Offload CPU-intensive tasks</td></tr><tr><td>Shared Worker Agent</td><td>Shared among multiple tabs</td><td>✅ Yes</td><td>Tab-to-tab communication</td></tr><tr><td>Service Worker Agent</td><td>Background fetch/caching logic</td><td>✅ Yes</td><td>Offline apps, PWA</td></tr><tr><td>Worklet Agent</td><td>Lightweight visual/audio tasks</td><td>✅ Yes</td><td>Audio, CSS, animations</td></tr></tbody></table><hr><p>You want to continue to the <strong>next part</strong> after this? It’s:</p><blockquote><p><strong>“In other words, each worker creates its own agent, while one or more windows may be within the same agent—usually a main document and its similar-origin iframes…”</strong></p></blockquote><p>Just say the word and we’ll keep recursively breaking it down with visuals and mental models.</p><p>Perfect! Let’s do a <strong>recursive breakdown</strong> of this next section, <strong>line by line</strong>, with <strong>intuitive mental models, visuals-in-your-head, and real-world JavaScript usage</strong>.</p><hr><h2 id=-big-context>🧠 Big Context:<a hidden class=anchor aria-hidden=true href=#-big-context>#</a></h2><p>You just learned that <strong>each agent is like an isolated JavaScript runtime</strong>: it has its own heap, call stack, and job queue.</p><p>Now you&rsquo;re learning:</p><blockquote><p>🔍 <strong>&ldquo;What are the different types of agents on the web?&rdquo;</strong></p></blockquote><p>Let’s go <strong>line by line</strong>:</p><hr><h3 id=-1-an-agent-on-the-web-can-be-one-of-the-following>🔹 1. “An agent on the web can be one of the following:”<a hidden class=anchor aria-hidden=true href=#-1-an-agent-on-the-web-can-be-one-of-the-following>#</a></h3><p>✅ <strong>Translation</strong>:<br>On the web, there are several &ldquo;execution environments&rdquo; where JavaScript can run.<br>Each is backed by a <strong>separate agent</strong>, i.e., its own isolated execution infrastructure.</p><hr><h2 id=-now-we-explore-each-type>🧩 Now we explore each type:<a hidden class=anchor aria-hidden=true href=#-now-we-explore-each-type>#</a></h2><hr><h3 id=-2-a-similar-origin-window-agent-which-contains-various-window-objects-which-can-potentially-reach-each-other-either-directly-or-by-using-documentdomain-if-the-window-is-origin-keyed-then-only-same-origin-windows-can-reach-each-other>🔹 2. “A Similar-origin window agent, which contains various Window objects which can potentially reach each other, either directly or by using <code>document.domain</code>. If the window is origin-keyed, then only same-origin windows can reach each other.”<a hidden class=anchor aria-hidden=true href=#-2-a-similar-origin-window-agent-which-contains-various-window-objects-which-can-potentially-reach-each-other-either-directly-or-by-using-documentdomain-if-the-window-is-origin-keyed-then-only-same-origin-windows-can-reach-each-other>#</a></h3><h3 id=-what-this-means-1>🧠 What this means:<a hidden class=anchor aria-hidden=true href=#-what-this-means-1>#</a></h3><ul><li>This is your <strong>main webpage</strong>, plus any <strong>iframes</strong> inside it that share the same origin (protocol + host + port).</li><li>These &ldquo;windows&rdquo; share the same <strong>agent</strong>, and can <strong>talk to each other synchronously</strong>.</li></ul><h4 id=-real-world-example>🧪 Real-World Example:<a hidden class=anchor aria-hidden=true href=#-real-world-example>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl><span class=c>&lt;!-- index.html --&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>iframe</span> <span class=na>src</span><span class=o>=</span><span class=s>&#34;https://yourdomain.com/page.html&#34;</span><span class=p>&gt;&lt;/</span><span class=nt>iframe</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>You can do this from the parent:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>iframeDoc</span> <span class=o>=</span> <span class=nb>window</span><span class=p>.</span><span class=nx>frames</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=nb>document</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>iframeDoc</span><span class=p>.</span><span class=nx>title</span><span class=p>);</span> <span class=c1>// works if same origin
</span></span></span></code></pre></div><blockquote><p>⚠️ If they&rsquo;re <strong>cross-origin</strong>, that line throws a security error (unless both set <code>document.domain</code>).</p></blockquote><h4 id=-what-is-documentdomain>📌 What is <code>document.domain</code>?<a hidden class=anchor aria-hidden=true href=#-what-is-documentdomain>#</a></h4><p>A deprecated way to let subdomains trust each other:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// a.example.com and b.example.com both set:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>document</span><span class=p>.</span><span class=nx>domain</span> <span class=o>=</span> <span class=s2>&#34;example.com&#34;</span><span class=p>;</span> 
</span></span></code></pre></div><p>→ Now they can talk synchronously.</p><hr><h3 id=-3-a-dedicated-worker-agent-containing-a-single-dedicatedworkerglobalscope>🔹 3. “A Dedicated worker agent containing a single <code>DedicatedWorkerGlobalScope</code>.”<a hidden class=anchor aria-hidden=true href=#-3-a-dedicated-worker-agent-containing-a-single-dedicatedworkerglobalscope>#</a></h3><h3 id=-what-this-means-2>🧠 What this means:<a hidden class=anchor aria-hidden=true href=#-what-this-means-2>#</a></h3><p>When you use a <strong>Web Worker</strong>, like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>worker</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Worker</span><span class=p>(</span><span class=s2>&#34;worker.js&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>You’re spinning up a <strong>new agent</strong> behind the scenes.<br>That agent has:</p><ul><li>Its own <strong>heap</strong></li><li>Its own <strong>stack</strong></li><li>Its own <strong>event queue</strong></li></ul><p>It runs <code>worker.js</code> in isolation.</p><h4 id=-real-world-use-case>💡 Real-World Use Case:<a hidden class=anchor aria-hidden=true href=#-real-world-use-case>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// main.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>worker</span><span class=p>.</span><span class=nx>postMessage</span><span class=p>({</span> <span class=nx>task</span><span class=o>:</span> <span class=s2>&#34;fibonacci&#34;</span><span class=p>,</span> <span class=nx>n</span><span class=o>:</span> <span class=mi>40</span> <span class=p>});</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// worker.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>onmessage</span> <span class=o>=</span> <span class=p>(</span><span class=nx>e</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>result</span> <span class=o>=</span> <span class=nx>doHeavyFibonacci</span><span class=p>(</span><span class=nx>e</span><span class=p>.</span><span class=nx>data</span><span class=p>.</span><span class=nx>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nx>postMessage</span><span class=p>(</span><span class=nx>result</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>→ This keeps your UI thread <strong>smooth and responsive</strong> while the heavy calculation runs in another <strong>agent</strong> (aka thread-like sandbox).</p><hr><h3 id=-4-a-shared-worker-agent-containing-a-single-sharedworkerglobalscope>🔹 4. “A Shared worker agent containing a single <code>SharedWorkerGlobalScope</code>.”<a hidden class=anchor aria-hidden=true href=#-4-a-shared-worker-agent-containing-a-single-sharedworkerglobalscope>#</a></h3><h3 id=-meaning>🧠 Meaning:<a hidden class=anchor aria-hidden=true href=#-meaning>#</a></h3><p>Unlike a dedicated worker, a <strong>SharedWorker</strong> is <strong>shared across multiple tabs</strong>.</p><p>You create it like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>sharedWorker</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>SharedWorker</span><span class=p>(</span><span class=s2>&#34;worker.js&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>This launches an <strong>agent that lives beyond a single page</strong>, shared between tabs of the same origin.</p><h4 id=-use-case>📌 Use case:<a hidden class=anchor aria-hidden=true href=#-use-case>#</a></h4><p>You&rsquo;re building a <strong>real-time dashboard</strong> with multiple tabs.<br>You want all tabs to share a single:</p><ul><li>WebSocket connection</li><li>Cache</li><li>State</li></ul><p>The <strong>shared worker agent</strong> holds that logic, and all tabs send messages to it.</p><hr><h3 id=-5-a-service-worker-agent-containing-a-single-serviceworkerglobalscope>🔹 5. “A Service worker agent containing a single <code>ServiceWorkerGlobalScope</code>.”<a hidden class=anchor aria-hidden=true href=#-5-a-service-worker-agent-containing-a-single-serviceworkerglobalscope>#</a></h3><h3 id=-meaning-1>🧠 Meaning:<a hidden class=anchor aria-hidden=true href=#-meaning-1>#</a></h3><p>Service workers are special. They&rsquo;re not tied to a tab.<br>They sit in the background and intercept network requests.</p><p>You register one like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>navigator</span><span class=p>.</span><span class=nx>serviceWorker</span><span class=p>.</span><span class=nx>register</span><span class=p>(</span><span class=s2>&#34;/sw.js&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>The <code>sw.js</code> file runs in its own <strong>agent</strong> with:</p><ul><li>No DOM access</li><li>Its own global scope (<code>ServiceWorkerGlobalScope</code>)</li><li>A lifetime independent from your pages</li></ul><h4 id=-use-case-1>📌 Use case:<a hidden class=anchor aria-hidden=true href=#-use-case-1>#</a></h4><ul><li>Offline support</li><li>Background sync</li><li>Push notifications</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// sw.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>self</span><span class=p>.</span><span class=nx>addEventListener</span><span class=p>(</span><span class=s2>&#34;fetch&#34;</span><span class=p>,</span> <span class=p>(</span><span class=nx>event</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>event</span><span class=p>.</span><span class=nx>respondWith</span><span class=p>(</span><span class=nx>caches</span><span class=p>.</span><span class=nx>match</span><span class=p>(</span><span class=nx>event</span><span class=p>.</span><span class=nx>request</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></div><p>This runs in a <strong>background agent</strong> even when no tabs are open.</p><hr><h3 id=-6-a-worklet-agent-containing-a-single-workletglobalscope>🔹 6. “A Worklet agent containing a single <code>WorkletGlobalScope</code>.”<a hidden class=anchor aria-hidden=true href=#-6-a-worklet-agent-containing-a-single-workletglobalscope>#</a></h3><h3 id=-what-is-a-worklet>🧠 What is a <strong>Worklet</strong>?<a hidden class=anchor aria-hidden=true href=#-what-is-a-worklet>#</a></h3><p>Worklets are tiny, low-latency JS programs.<br>They&rsquo;re used for <strong>audio processing</strong>, <strong>custom painting</strong>, etc.</p><p>They are <strong>isolated agents</strong> that are super-performant, meant for <strong>frame-by-frame rendering</strong> or <strong>DSP (digital signal processing)</strong>.</p><h4 id=-use-case-2>🧪 Use Case:<a hidden class=anchor aria-hidden=true href=#-use-case-2>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// AudioWorklet
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>audioContext</span><span class=p>.</span><span class=nx>audioWorklet</span><span class=p>.</span><span class=nx>addModule</span><span class=p>(</span><span class=s2>&#34;processor.js&#34;</span><span class=p>);</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// processor.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>registerProcessor</span><span class=p>(</span><span class=s2>&#34;my-processor&#34;</span><span class=p>,</span> <span class=kr>class</span> <span class=kr>extends</span> <span class=nx>AudioWorkletProcessor</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>process</span><span class=p>(</span><span class=nx>inputs</span><span class=p>,</span> <span class=nx>outputs</span><span class=p>,</span> <span class=nx>params</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// handle audio here
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></div><p>Each worklet runs in a <strong>micro-agent</strong> with hard real-time constraints.</p><hr><h3 id=-7-in-other-words-each-worker-creates-its-own-agent-while-one-or-more-windows-may-be-within-the-same-agentusually-a-main-document-and-its-similar-origin-iframes>🔹 7. “In other words, each worker creates its own agent, while one or more windows may be within the same agent—usually a main document and its similar-origin iframes.”<a hidden class=anchor aria-hidden=true href=#-7-in-other-words-each-worker-creates-its-own-agent-while-one-or-more-windows-may-be-within-the-same-agentusually-a-main-document-and-its-similar-origin-iframes>#</a></h3><h3 id=-recap>🔁 Recap:<a hidden class=anchor aria-hidden=true href=#-recap>#</a></h3><ul><li>Workers (dedicated, shared, service, worklet) → <strong>always create new agents</strong></li><li>Windows (tabs, iframes) → may share <strong>one agent</strong> if they are <strong>same origin</strong></li></ul><p>📦 So:</p><ul><li>If you <code>new Worker()</code>, you get a new agent.</li><li>If you create a same-origin iframe, it&rsquo;s part of your agent.</li><li>If it&rsquo;s a cross-origin iframe, it likely gets its <strong>own agent</strong>.</li></ul><hr><h3 id=-8-in-nodejs-a-similar-concept-called-worker-threads-is-available>🔹 8. “In Node.js, a similar concept called worker threads is available.”<a hidden class=anchor aria-hidden=true href=#-8-in-nodejs-a-similar-concept-called-worker-threads-is-available>#</a></h3><h3 id=-in-nodejs>🧠 In Node.js:<a hidden class=anchor aria-hidden=true href=#-in-nodejs>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=p>{</span> <span class=nx>Worker</span> <span class=p>}</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s2>&#34;worker_threads&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>new</span> <span class=nx>Worker</span><span class=p>(</span><span class=s2>&#34;./worker.js&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>That is <strong>exactly equivalent</strong> to a <strong>dedicated worker agent</strong> on the web.</p><ul><li>It has its own stack, heap, queue</li><li>Communicates via <code>postMessage</code></li><li>Can use <code>SharedArrayBuffer</code> for shared memory</li></ul><p>🔧 This is Node’s way of mimicking browser agents in the backend.</p><hr><h2 id=-summary-mental-model>✅ Summary Mental Model:<a hidden class=anchor aria-hidden=true href=#-summary-mental-model>#</a></h2><p>Imagine each <strong>agent</strong> as a little isolated <strong>mini JavaScript world</strong> with:</p><ul><li>📦 its own memory (<code>heap</code>)</li><li>🧠 its own thinking (<code>call stack</code>)</li><li>🕓 its own scheduler (<code>job queue</code>)</li></ul><p>Then:</p><ul><li><code>new Worker()</code> → new agent</li><li><code>SharedWorker</code> → shared agent across tabs</li><li><code>ServiceWorker</code> → background agent</li><li><code>Worklet</code> → real-time micro-agent</li><li><code>Same-origin iframe</code> → stays in same agent as parent</li></ul><hr><p>Want to move to the <strong>next block</strong> (i.e., Realms)?<br>It starts with:</p><blockquote><p>&ldquo;Each agent owns one or more realms&mldr;&rdquo;</p></blockquote><p>Just say <strong>&ldquo;next&rdquo;</strong>, and I’ll recursively break that one down too.</p><p>Perfect. Let’s do a <strong>deep recursive breakdown</strong> of this <strong>“Realms”</strong> section—<strong>line by line</strong>, with intuition, real examples, and mental models.</p><hr><h3 id=-topic-what-is-a-realm>🔰 Topic: <strong>What is a Realm?</strong><a hidden class=anchor aria-hidden=true href=#-topic-what-is-a-realm>#</a></h3><p>A <strong>Realm</strong> is like a <strong>self-contained JS universe</strong> inside an agent.<br>Think of it as a <strong>&ldquo;VM inside a thread&rdquo;</strong>.</p><hr><h2 id=-line-1-2>🔹 Line 1:<a hidden class=anchor aria-hidden=true href=#-line-1-2>#</a></h2><blockquote><p><strong>&ldquo;Each agent owns one or more realms.&rdquo;</strong></p></blockquote><p>🧠 <strong>Intuition</strong>:<br>We already learned that an <strong>agent</strong> is like a JS thread — with its own stack, heap, and event queue.</p><p>A <strong>realm</strong> lives <em>inside</em> an agent.<br>So one agent can have <strong>many realms</strong>.</p><hr><h3 id=-real-world-analogy-1>💡 Real-world Analogy:<a hidden class=anchor aria-hidden=true href=#-real-world-analogy-1>#</a></h3><ul><li><strong>Agent = one CPU core</strong> running JavaScript</li><li><strong>Realm = one JavaScript sandbox</strong> running a specific program (like a tab or an iframe)</li></ul><p>🧪 On the web:</p><ul><li>A <strong>main tab</strong> is one realm.</li><li>A <strong>same-origin iframe</strong> is a different realm.</li><li>But both can live inside the <strong>same agent</strong> (thread).</li></ul><hr><h2 id=-line-2-2>🔹 Line 2:<a hidden class=anchor aria-hidden=true href=#-line-2-2>#</a></h2><blockquote><p><strong>&ldquo;Each piece of JavaScript code is associated with a realm when it&rsquo;s loaded, which remains the same even when called from another realm.&rdquo;</strong></p></blockquote><h3 id=-whats-happening>🧠 What&rsquo;s happening?<a hidden class=anchor aria-hidden=true href=#-whats-happening>#</a></h3><p>When a JS file loads in a context (tab, iframe, worker), it’s <strong>bound to the realm of that context</strong>.</p><p>Even if it&rsquo;s later called <strong>from another realm</strong>, it still uses the <strong>original realm</strong> it was loaded in.</p><h4 id=-example>📦 Example:<a hidden class=anchor aria-hidden=true href=#-example>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl><span class=c>&lt;!-- index.html --&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>iframe</span> <span class=na>id</span><span class=o>=</span><span class=s>&#34;frame&#34;</span> <span class=na>src</span><span class=o>=</span><span class=s>&#34;iframe.html&#34;</span><span class=p>&gt;&lt;/</span><span class=nt>iframe</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>script</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>fn</span> <span class=o>=</span> <span class=nb>window</span><span class=p>.</span><span class=nx>frames</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=nx>someFunction</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nx>fn</span><span class=p>();</span> <span class=c1>// This still executes in iframe.html’s realm!
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>&lt;/</span><span class=nt>script</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Even though you called the function from the main page, it still executes with the context of the iframe realm. Why? Because that’s where it was <strong>created</strong>.</p><p>🧠 Functions are <strong>sticky</strong> to the realm they were born in.</p><hr><h2 id=-line-35>🔹 Line 3–5:<a hidden class=anchor aria-hidden=true href=#-line-35>#</a></h2><blockquote><p><strong>&ldquo;A realm consists of the following information:</strong></p><ul><li>A list of intrinsic objects like <code>Array</code>, <code>Array.prototype</code>, etc.</li><li>Globally declared variables, the value of <code>globalThis</code>, and the global object</li><li>A cache of template literal arrays, because evaluation of the same tagged template literal expression always causes the tag to receive the same array object&rdquo;</li></ul></blockquote><hr><h3 id=-1-intrinsic-objects-eg-array-object-function-etc>🔸 1. <strong>Intrinsic objects</strong> (e.g. <code>Array</code>, <code>Object</code>, <code>Function</code>, etc.)<a hidden class=anchor aria-hidden=true href=#-1-intrinsic-objects-eg-array-object-function-etc>#</a></h3><p>Every realm gets <strong>its own versions</strong> of core JS constructors:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// iframe.html
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>Array</span> <span class=o>!==</span> <span class=nx>parent</span><span class=p>.</span><span class=nb>Array</span><span class=p>;</span> <span class=c1>// true
</span></span></span></code></pre></div><p>Each realm gets its own <code>Array</code>, <code>Object</code>, <code>Function</code>, etc.<br>They might behave the same — but they are <strong>different objects in memory</strong>.</p><hr><h3 id=-2-global-variables-and>🔸 2. <strong>Global variables and <code>globalThis</code></strong><a hidden class=anchor aria-hidden=true href=#-2-global-variables-and>#</a></h3><p>Every realm has its <strong>own global scope</strong> — this includes:</p><ul><li><code>window</code> in main thread</li><li><code>self</code> in workers</li><li><code>globalThis</code> (unified access)</li></ul><p>So in two realms:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// Realm A
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>globalThis</span> <span class=o>===</span> <span class=nb>window</span><span class=p>;</span> <span class=c1>// true
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// Realm B (worker)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>globalThis</span> <span class=o>===</span> <span class=nx>self</span><span class=p>;</span> <span class=c1>// true
</span></span></span></code></pre></div><p>But:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>realmA</span><span class=p>.</span><span class=nx>globalThis</span> <span class=o>!==</span> <span class=nx>realmB</span><span class=p>.</span><span class=nx>globalThis</span><span class=p>;</span> <span class=c1>// true
</span></span></span></code></pre></div><p>Each has its own <strong>isolated namespace</strong>.</p><hr><h3 id=-3-template-literal-cache>🔸 3. <strong>Template literal cache</strong><a hidden class=anchor aria-hidden=true href=#-3-template-literal-cache>#</a></h3><p>This is a performance optimization:</p><p>When you use <strong>tagged template literals</strong>, the same <strong>template array object</strong> is reused:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>tag</span><span class=p>(</span><span class=nx>strings</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>strings</span><span class=p>);</span> <span class=c1>// same array on repeated calls
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>tag</span><span class=sb>`Hello </span><span class=si>${</span><span class=nx>name</span><span class=si>}</span><span class=sb>`</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>tag</span><span class=sb>`Hello </span><span class=si>${</span><span class=nx>name</span><span class=si>}</span><span class=sb>`</span><span class=p>;</span>
</span></span></code></pre></div><p>This cache is <strong>per-realm</strong>, not global.</p><hr><h2 id=-line-6-2>🔹 Line 6:<a hidden class=anchor aria-hidden=true href=#-line-6-2>#</a></h2><blockquote><p><strong>&ldquo;On the web, the realm and the global object are 1-to-1 corresponded. The global object is either a <code>Window</code>, a <code>WorkerGlobalScope</code>, or a <code>WorkletGlobalScope</code>.&rdquo;</strong></p></blockquote><p>🧠 Translation:</p><p>Each realm has exactly <strong>one global object</strong>, and vice versa.</p><p>On the web:</p><table><thead><tr><th>Realm</th><th>Global Object</th></tr></thead><tbody><tr><td>Tab / iframe</td><td><code>Window</code></td></tr><tr><td>Worker</td><td><code>WorkerGlobalScope</code></td></tr><tr><td>Worklet</td><td><code>WorkletGlobalScope</code></td></tr></tbody></table><blockquote><p>That’s why if you get the <code>window</code> in the main page and compare it to an iframe’s, they’re not equal.</p></blockquote><hr><h2 id=-line-7>🔹 Line 7:<a hidden class=anchor aria-hidden=true href=#-line-7>#</a></h2><blockquote><p><strong>&ldquo;So for example, every iframe executes in a different realm, though it may be in the same agent as the parent window.&rdquo;</strong></p></blockquote><p>✅ Recap of layers:</p><ul><li><code>iframe.html</code> = different realm</li><li><code>index.html</code> = different realm</li><li>But both can share the same <strong>agent</strong> (thread), and thus talk <strong>synchronously</strong></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>iframe</span> <span class=o>=</span> <span class=nb>window</span><span class=p>.</span><span class=nx>frames</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>iframe</span><span class=p>.</span><span class=nb>document</span> <span class=o>!==</span> <span class=nb>document</span> <span class=c1>// ✅ different realm
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typeof</span> <span class=nx>iframe</span><span class=p>.</span><span class=nb>Array</span> <span class=o>===</span> <span class=s2>&#34;function&#34;</span> <span class=c1>// ✅ iframe has its own Array constructor
</span></span></span></code></pre></div><hr><h2 id=-line-8>🔹 Line 8:<a hidden class=anchor aria-hidden=true href=#-line-8>#</a></h2><blockquote><p><strong>&ldquo;Realms are usually mentioned when talking about the identities of global objects.&rdquo;</strong></p></blockquote><p>🧠 This sets up the next gotcha:</p><ul><li>Objects might &ldquo;look&rdquo; the same (e.g. arrays from two realms)</li><li>But under the hood, their <strong>identity</strong> is different</li></ul><hr><h2 id=-final-line>🔹 Final Line:<a hidden class=anchor aria-hidden=true href=#-final-line>#</a></h2><blockquote><p><strong>&ldquo;For example, we need methods such as <code>Array.isArray()</code> or <code>Error.isError()</code>, because an array constructed in another realm will have a different prototype object than the <code>Array.prototype</code> object in the current realm, so <code>instanceof Array</code> will wrongly return false.&rdquo;</strong></p></blockquote><hr><h3 id=-mind-blowing-real-world-bug>🧪 Mind-blowing Real World Bug:<a hidden class=anchor aria-hidden=true href=#-mind-blowing-real-world-bug>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// index.html
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>arr</span> <span class=o>=</span> <span class=nb>window</span><span class=p>.</span><span class=nx>frames</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=nx>contentWindow</span><span class=p>.</span><span class=nb>eval</span><span class=p>(</span><span class=s2>&#34;[]&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>arr</span> <span class=k>instanceof</span> <span class=nb>Array</span><span class=p>);</span> <span class=c1>// ❌ false
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>Array</span><span class=p>.</span><span class=nx>isArray</span><span class=p>(</span><span class=nx>arr</span><span class=p>);</span>                <span class=c1>// ✅ true
</span></span></span></code></pre></div><h4 id=why>Why?<a hidden class=anchor aria-hidden=true href=#why>#</a></h4><p>Because:</p><ul><li><code>instanceof</code> uses <strong>current realm’s Array.prototype</strong></li><li>But <code>arr</code> was created in <strong>another realm</strong>, so it&rsquo;s linked to <strong>iframe’s Array.prototype</strong></li></ul><p>→ So they’re <strong>not the same prototype</strong> — <code>instanceof</code> fails.</p><p>✅ <code>Array.isArray()</code> uses <strong>internal tags</strong> and works across realms.</p><hr><h2 id=-summary-mental-model-1>🔄 Summary (Mental Model)<a hidden class=anchor aria-hidden=true href=#-summary-mental-model-1>#</a></h2><table><thead><tr><th>Concept</th><th>Meaning</th></tr></thead><tbody><tr><td><strong>Realm</strong></td><td>A self-contained JS &ldquo;universe&rdquo; with its own global scope and built-in objects</td></tr><tr><td><strong>Agent</strong></td><td>A thread-like runner that can host one or more realms</td></tr><tr><td><strong>Function&rsquo;s Realm</strong></td><td>Determined by where it was created, not called</td></tr><tr><td><strong>Cross-realm instanceof fails</strong></td><td>Because <code>prototype</code> objects are realm-specific</td></tr><tr><td><strong>Global object</strong></td><td>The realm’s anchor: <code>Window</code>, <code>WorkerGlobalScope</code>, etc.</td></tr><tr><td><strong>Tag template cache</strong></td><td>Cached per-realm to avoid array recreation</td></tr></tbody></table><hr><p>Would you like to move on to the next section:</p><blockquote><p><strong>&ldquo;Stack and execution contexts&rdquo;</strong></p></blockquote><p>Just say <strong>“next”</strong> and I’ll break that down in the same step-by-step, deeply intuitive style.
Absolutely. Let’s run your recursive breakdown prompt on this snippet from the JavaScript execution model.</p><hr><p>🔁 <strong>Break this down recursively, step by step.</strong><br>For each line or idea in the text:</p><ul><li>Explain it in simple words like I’m 5.</li><li>Add practical understanding and intuition.</li><li>Give real-world metaphors or analogies.</li><li>Show code examples if possible.</li><li>Call out connections to other concepts (heap, call stack, event loop, etc).</li><li>If there are any edge cases or gotchas, point them out.</li></ul><hr><h3 id=-heres-the-snippet>🧠 Here&rsquo;s the snippet:<a hidden class=anchor aria-hidden=true href=#-heres-the-snippet>#</a></h3><blockquote><p><strong>Each agent owns one or more realms.</strong></p></blockquote><h4 id=-tldr>🧵 TL;DR:<a hidden class=anchor aria-hidden=true href=#-tldr>#</a></h4><p>An <em>agent</em> (think: thread of JS execution) contains one or more <em>realms</em>, which are like complete JS “universes.”</p><h4 id=-like-im-5>👶 Like I’m 5:<a hidden class=anchor aria-hidden=true href=#-like-im-5>#</a></h4><p>Imagine a school (agent) with multiple classrooms (realms). Each classroom has its own set of blackboards, students, and books. They don’t share these things directly, even though they’re all in the same school.</p><h4 id=-intuition-4>💡 Intuition:<a hidden class=anchor aria-hidden=true href=#-intuition-4>#</a></h4><p>A <em>realm</em> is an isolated set of JavaScript built-ins and global variables. Even if two pieces of code are running on the same thread (agent), if they are in different realms, their core object identities are different.</p><h4 id=-technical-precision>🧑‍💻 Technical Precision:<a hidden class=anchor aria-hidden=true href=#-technical-precision>#</a></h4><ul><li>Each <em>realm</em> has its own:<ul><li>Global object (<code>window</code>, <code>self</code>, etc.)</li><li>Built-in constructors (<code>Object</code>, <code>Array</code>, <code>Map</code>, etc.)</li><li>Internal references (prototypes, etc.)</li></ul></li></ul><blockquote><p><strong>Each piece of JavaScript code is associated with a realm when it&rsquo;s loaded, which remains the same even when called from another realm.</strong></p></blockquote><h4 id=-key-insight>🔍 Key Insight:<a hidden class=anchor aria-hidden=true href=#-key-insight>#</a></h4><ul><li>Once JS code is “born” in a realm, it stays “tagged” with that realm forever.</li><li>Even if it&rsquo;s called from a different realm, its identity doesn&rsquo;t shift.</li></ul><h4 id=-code-example>🧪 Code Example:<a hidden class=anchor aria-hidden=true href=#-code-example>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// Frame A (iframe1.html)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>window</span><span class=p>.</span><span class=nx>foo</span> <span class=o>=</span> <span class=p>[];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Frame B (iframe2.html)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>foo</span> <span class=k>instanceof</span> <span class=nb>Array</span><span class=p>);</span> <span class=c1>// false
</span></span></span></code></pre></div><p><code>foo</code> was created in iframe1&rsquo;s realm. The <code>Array</code> constructor in iframe2 is from a <strong>different realm</strong>, so the <code>instanceof</code> fails!</p><h4 id=-mental-model>🧠 Mental Model:<a hidden class=anchor aria-hidden=true href=#-mental-model>#</a></h4><p>Think of realms like sandboxes. Once a toy (object/function) is built in sandbox A, it keeps using A’s rules and tools, even if someone in sandbox B tries to use it.</p><hr><blockquote><p><strong>A realm consists of the following information:</strong></p></blockquote><p>We&rsquo;ll now decompose each of these bullet points.</p><hr><blockquote><p>✅ <strong>A list of intrinsic objects like <code>Array</code>, <code>Array.prototype</code>, etc.</strong></p></blockquote><h4 id=-technical-insight>🤓 Technical Insight:<a hidden class=anchor aria-hidden=true href=#-technical-insight>#</a></h4><ul><li>Intrinsics are ECMAScript-provided, built-in constructors and objects.</li><li>Every realm has its own fresh copies of these:<ul><li><code>Object</code></li><li><code>Function</code></li><li><code>Error</code></li><li><code>Array</code></li><li>…and their prototypes</li></ul></li></ul><p>These are all baked into the realm and created at initialization.</p><h4 id=-gotcha>🪤 Gotcha:<a hidden class=anchor aria-hidden=true href=#-gotcha>#</a></h4><p>Even if two <code>Array</code> constructors look identical (<code>toString()</code>), they are different in identity across realms:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>iframe1</span><span class=p>.</span><span class=nb>Array</span> <span class=o>===</span> <span class=nx>iframe2</span><span class=p>.</span><span class=nb>Array</span> <span class=c1>// false
</span></span></span></code></pre></div><hr><blockquote><p>✅ <strong>Globally declared variables, the value of <code>globalThis</code>, and the global object</strong></p></blockquote><h4 id=-translation>🧠 Translation:<a hidden class=anchor aria-hidden=true href=#-translation>#</a></h4><ul><li><code>globalThis</code> is realm-specific.</li><li>Each realm has its own:<ul><li>Top-level variables (<code>var x = ...</code>)</li><li><code>window</code> or <code>self</code></li><li><code>globalThis</code></li></ul></li></ul><h4 id=-real-world-example-1>🧪 Real World Example:<a hidden class=anchor aria-hidden=true href=#-real-world-example-1>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// iframe.html
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>var</span> <span class=nx>foo</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nb>window</span><span class=p>.</span><span class=nx>foo</span><span class=p>);</span> <span class=c1>// 42
</span></span></span></code></pre></div><p>This <code>foo</code> only exists in that iframe’s global object (its realm).</p><hr><blockquote><p>✅ <strong>A cache of template literal arrays, because evaluation of the same tagged template literal expression always causes the tag to receive the same array object</strong></p></blockquote><h4 id=-why-does-this-matter>🧠 Why does this matter?<a hidden class=anchor aria-hidden=true href=#-why-does-this-matter>#</a></h4><p>In tagged templates like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>tag</span><span class=p>(</span><span class=nx>strings</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>strings</span><span class=p>);</span> <span class=c1>// same array every time
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>tag</span><span class=sb>`Hello </span><span class=si>${</span><span class=nx>user</span><span class=si>}</span><span class=sb>`</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>tag</span><span class=sb>`Hello </span><span class=si>${</span><span class=nx>user</span><span class=si>}</span><span class=sb>`</span><span class=p>;</span>
</span></span></code></pre></div><p>JavaScript ensures that the <strong>template string array</strong> passed into <code>tag()</code> is cached <em>per realm</em>.</p><p>Different realms? Different caches.</p><h4 id=-performance>💥 Performance:<a hidden class=anchor aria-hidden=true href=#-performance>#</a></h4><p>This caching helps speed up repeated template evaluation and ensures referential equality:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>tag</span><span class=sb>`hello`</span> <span class=o>===</span> <span class=nx>tag</span><span class=sb>`hello`</span><span class=p>;</span> <span class=c1>// true — same object
</span></span></span></code></pre></div><p>Only within the same realm!</p><hr><blockquote><p><strong>On the web, the realm and the global object are 1-to-1 corresponded. The global object is either a <code>Window</code>, a <code>WorkerGlobalScope</code>, or a <code>WorkletGlobalScope</code>.</strong></p></blockquote><h4 id=-important-connection>🧠 Important Connection:<a hidden class=anchor aria-hidden=true href=#-important-connection>#</a></h4><p>This means: <strong>Each realm = one global scope = one top-level execution environment</strong></p><ul><li>Main page → <code>Window</code></li><li>Web worker → <code>WorkerGlobalScope</code></li><li>Audio/paint worklet → <code>WorkletGlobalScope</code></li></ul><hr><blockquote><p><strong>So for example, every iframe executes in a different realm, though it may be in the same agent as the parent window.</strong></p></blockquote><h4 id=-key-example>🧪 Key Example:<a hidden class=anchor aria-hidden=true href=#-key-example>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl><span class=c>&lt;!-- parent.html --&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>iframe</span> <span class=na>src</span><span class=o>=</span><span class=s>&#34;child.html&#34;</span><span class=p>&gt;&lt;/</span><span class=nt>iframe</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Both windows may run in the <strong>same thread</strong> (same agent), but they have separate <strong>realms</strong>:</p><ul><li>Separate <code>window</code></li><li>Separate built-ins</li><li>Separate <code>Array.prototype</code></li></ul><hr><blockquote><p><strong>Realms are usually mentioned when talking about the identities of global objects.</strong></p></blockquote><h4 id=-this-is-important-for-comparing-object-types>🧠 This is important for comparing object types:<a hidden class=anchor aria-hidden=true href=#-this-is-important-for-comparing-object-types>#</a></h4><ul><li><code>instanceof</code>, <code>typeof</code>, and even object shape can mislead across realms.</li><li>That’s why we use <code>Array.isArray()</code> and <code>Object.prototype.toString.call(x)</code> for better checks.</li></ul><hr><blockquote><p><strong>For example, we need methods such as <code>Array.isArray()</code> or <code>Error.isError()</code>, because an array constructed in another realm will have a different prototype object than the <code>Array.prototype</code> object in the current realm, so <code>instanceof Array</code> will wrongly return false.</strong></p></blockquote><h4 id=--this-is-the-key-gotcha>💥 🔥 This is <strong>the key gotcha</strong>:<a hidden class=anchor aria-hidden=true href=#--this-is-the-key-gotcha>#</a></h4><p><code>instanceof</code> checks the <strong>prototype chain</strong>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>obj</span> <span class=k>instanceof</span> <span class=nb>Array</span><span class=p>;</span> <span class=c1>// internally: obj.[[Prototype]] === Array.prototype
</span></span></span></code></pre></div><p>If <code>obj</code> came from another realm, its <code>[[Prototype]]</code> points to <em>that</em> realm’s <code>Array.prototype</code>.</p><p>So your current realm&rsquo;s <code>Array.prototype !== obj.[[Prototype]]</code>.</p><p>✅ Fix: Use <code>Array.isArray(obj)</code> — it works across realms.</p><hr><h3 id=-summary-realm-mental-model>🔄 Summary: Realm Mental Model<a hidden class=anchor aria-hidden=true href=#-summary-realm-mental-model>#</a></h3><table><thead><tr><th>Thing</th><th>Scoped to Realm?</th><th>Notes</th></tr></thead><tbody><tr><td><code>globalThis</code></td><td>✅ Yes</td><td>Same as <code>window</code> in browsers</td></tr><tr><td><code>Array</code>, <code>Error</code>, <code>Map</code></td><td>✅ Yes</td><td>Intrinsics are realm-bound</td></tr><tr><td>Template literals cache</td><td>✅ Yes</td><td>Same tag + literal = same object only <em>within</em> realm</td></tr><tr><td><code>instanceof</code></td><td>❌ Unsafe across realms</td><td>Use <code>.isArray()</code> instead</td></tr></tbody></table><hr><p>🧠 You now understand realms:</p><ul><li>What they contain (globals, intrinsics, caches)</li><li>How they interact (or don’t)</li><li>Why cross-realm identity breaks matter</li></ul><p>Let me know when you&rsquo;re ready for the next snippet 🔥</p><p>Absolutely — let&rsquo;s break this down recursively and deeply, exactly as you instructed.<br>We&rsquo;ll go concept by concept, technically and intuitively, and build up mental models for each.</p><hr><h2 id=-breakdown-stack-and-execution-contexts>🔁 Breakdown: Stack and Execution Contexts<a hidden class=anchor aria-hidden=true href=#-breakdown-stack-and-execution-contexts>#</a></h2><hr><h3 id=-we-first-consider-synchronous-code-execution>📌 <strong>“We first consider synchronous code execution.”</strong><a hidden class=anchor aria-hidden=true href=#-we-first-consider-synchronous-code-execution>#</a></h3><p>🧠 <strong>Simple</strong>: Let&rsquo;s start by looking at <em>normal</em> code that runs step-by-step (not async like <code>setTimeout</code> or <code>fetch</code>).</p><p>🧬 <strong>Intuition</strong>: Imagine reading a recipe. You follow instructions one by one: get pan, heat it, crack eggs. That’s synchronous — no skipping, no pausing.</p><p>💡 <strong>Connection</strong>: This section is setting the stage for how JS handles function calls in a single thread.</p><hr><h3 id=-each-job-enters-by-calling-its-associated-callback>📌 <strong>“Each job enters by calling its associated callback.”</strong><a hidden class=anchor aria-hidden=true href=#-each-job-enters-by-calling-its-associated-callback>#</a></h3><p>🧠 <strong>Simple</strong>: A &ldquo;job&rdquo; is a unit of work. That work begins by running a function (called a callback).</p><p>🧬 <strong>Metaphor</strong>: Think of a “job” as a task on your to-do list. You can’t start the job until you “open the task” — i.e., call the function.</p><p>💻 <strong>Example</strong>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Hi&#34;</span><span class=p>),</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// The callback here is () =&gt; console.log(&#34;Hi&#34;)
</span></span></span><span class=line><span class=cl><span class=c1>// This becomes a &#39;job&#39; when placed into the job queue
</span></span></span></code></pre></div><p>🔗 <strong>Links</strong>: Ties into the Job Queue / Event Loop model. This is the beginning of “run-to-completion.”</p><hr><h3 id=-code-inside-this-callback-may-create-variables-call-functions-or-exit>📌 <strong>“Code inside this callback may create variables, call functions, or exit.”</strong><a hidden class=anchor aria-hidden=true href=#-code-inside-this-callback-may-create-variables-call-functions-or-exit>#</a></h3><p>🧠 <strong>Simple</strong>: Once the function starts running, it can do things — define variables, call other functions, or finish and return.</p><p>🔁 <strong>Recursive</strong>: Calling another function pushes a new execution context (stack frame) on the stack.</p><hr><h3 id=-each-function-needs-to-keep-track-of-its-own-variable-environments-and-where-to-return-to>📌 <strong>“Each function needs to keep track of its own variable environments and where to return to.”</strong><a hidden class=anchor aria-hidden=true href=#-each-function-needs-to-keep-track-of-its-own-variable-environments-and-where-to-return-to>#</a></h3><p>🧠 <strong>Simple</strong>: Every function has <em>its own scope</em> — a separate box for its variables — and knows where to go back when it finishes.</p><p>🧬 <strong>Analogy</strong>: Like Russian dolls. Open one, go into the next. But you have to close the inner ones before returning to outer.</p><p>💻 <strong>Code</strong>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>greet</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>name</span> <span class=o>=</span> <span class=s2>&#34;Alice&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=sb>`Hi </span><span class=si>${</span><span class=nx>name</span><span class=si>}</span><span class=sb>`</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li>JS must remember:<ul><li><code>name = "Alice"</code></li><li>Where to go after <code>greet()</code> is done.</li></ul></li></ul><hr><h3 id=-to-handle-this-the-agent-needs-a-stack-to-keep-track-of-the-execution-contexts>📌 <strong>“To handle this, the agent needs a stack to keep track of the execution contexts.”</strong><a hidden class=anchor aria-hidden=true href=#-to-handle-this-the-agent-needs-a-stack-to-keep-track-of-the-execution-contexts>#</a></h3><p>🧠 <strong>Simple</strong>: JavaScript uses a <em>stack</em> to remember what function it’s currently in — and where to return.</p><p>🧩 <strong>Engine Insight</strong>: This is the <strong>call stack</strong> — last-in, first-out (LIFO).</p><p>🔗 Related:</p><ul><li>Stack Overflow = when too many nested calls fill up memory.</li><li>Execution Context = everything needed to run a chunk of code.</li></ul><hr><h3 id=-an-execution-context-also-known-generally-as-a-stack-frame-is-the-smallest-unit-of-execution>📌 <strong>“An execution context, also known generally as a stack frame, is the smallest unit of execution.”</strong><a hidden class=anchor aria-hidden=true href=#-an-execution-context-also-known-generally-as-a-stack-frame-is-the-smallest-unit-of-execution>#</a></h3><p>🧠 <strong>Simple</strong>: Each stack frame = one function&rsquo;s “sandbox.” JS creates one per function call.</p><p>💻 <strong>Contains</strong>:</p><ul><li>The function arguments and variables.</li><li>The value of <code>this</code>.</li><li>Which <code>realm</code> we’re in.</li><li>Internal stuff like <code>await</code>, <code>yield</code>, <code>return address</code>.</li></ul><hr><h3 id=-it-tracks-the-following-information>📌 <strong>“It tracks the following information…”</strong><a hidden class=anchor aria-hidden=true href=#-it-tracks-the-following-information>#</a></h3><h4 id=-code-evaluation-state>🔹 <strong>Code evaluation state</strong><a hidden class=anchor aria-hidden=true href=#-code-evaluation-state>#</a></h4><p>🧠 What line are we on? Are we paused (e.g., generator)? Are we done?</p><h4 id=-the-module-or-script-the-function-if-applicable-and-the-currently-executing-generator>🔹 <strong>The module or script, the function (if applicable), and the currently executing generator</strong><a hidden class=anchor aria-hidden=true href=#-the-module-or-script-the-function-if-applicable-and-the-currently-executing-generator>#</a></h4><p>🧠 JS knows: Are we inside a module or a classic script?</p><ul><li>Which function is running.</li><li>Are we inside a paused generator?</li></ul><h4 id=-the-current-realm>🔹 <strong>The current realm</strong><a hidden class=anchor aria-hidden=true href=#-the-current-realm>#</a></h4><p>🧠 Which global environment are we in? (e.g., iframe vs parent)</p><p>🔗 Ties into realms. Important for prototype identity (<code>instanceof</code>, etc.)</p><h4 id=-bindings>🔹 <strong>Bindings</strong><a hidden class=anchor aria-hidden=true href=#-bindings>#</a></h4><p>🧠 All the stuff declared inside the function:</p><ul><li><code>let</code>, <code>const</code>, <code>var</code></li><li><code>function foo() {}</code></li><li><code>class A {}</code></li><li><code>#privateField</code></li><li><code>this</code></li></ul><p>💻 These are stored in a <strong>Lexical Environment</strong>.</p><hr><h2 id=-trace-the-example>🧠 Trace: The Example<a hidden class=anchor aria-hidden=true href=#-trace-the-example>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>foo</span><span class=p>(</span><span class=nx>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>a</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span> <span class=o>+</span> <span class=mi>11</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>bar</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>y</span> <span class=o>=</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>foo</span><span class=p>(</span><span class=nx>x</span> <span class=o>*</span> <span class=nx>y</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>baz</span> <span class=o>=</span> <span class=nx>bar</span><span class=p>(</span><span class=mi>7</span><span class=p>);</span> <span class=c1>// assigns 42 to baz
</span></span></span></code></pre></div><p>📍 <strong>Step-by-step Stack Trace</strong>:</p><ol><li><code>bar(7)</code> is called<ul><li>Stack: [global, bar]</li><li><code>x = 7</code>, <code>y = 3</code></li></ul></li><li><code>foo(21)</code> is called inside <code>bar</code><ul><li>Stack: [global, bar, foo]</li><li><code>b = 21</code>, <code>a = 10</code></li></ul></li><li><code>foo</code> returns <code>42</code>, stack pops back to <code>bar</code></li><li><code>bar</code> returns <code>42</code>, stack pops back to global</li><li><code>baz = 42</code></li></ol><p>🧬 Intuition: JS stacks frames like Jenga blocks. When one returns, it pops off and reveals the one underneath.</p><hr><h2 id=-generators-and-reentry>🔁 Generators and Reentry<a hidden class=anchor aria-hidden=true href=#-generators-and-reentry>#</a></h2><h3 id=-when-a-frame-is-popped-its-not-necessarily-gone-forever>📌 <strong>“When a frame is popped, it’s not necessarily gone forever&mldr;”</strong><a hidden class=anchor aria-hidden=true href=#-when-a-frame-is-popped-its-not-necessarily-gone-forever>#</a></h3><p>🧠 Generators let you pause function execution <em>in the middle</em>, and resume later.</p><p>💻 Code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span><span class=o>*</span> <span class=nx>gen</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>yield</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=mi>2</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>📍 <code>gen()</code> creates a paused execution context.
📍 <code>g.next()</code> resumes it.
📍 <code>yield</code> <em>suspends</em> it again — it lives!</p><p>🧬 <strong>Metaphor</strong>: Like pausing a game and saving your state. You can resume from where you left.</p><hr><h2 id=-tail-calls>🧬 Tail Calls<a hidden class=anchor aria-hidden=true href=#-tail-calls>#</a></h2><h3 id=-if-a-function-call-is-in-tail-position>📌 <strong>“If a function call is in tail position…”</strong><a hidden class=anchor aria-hidden=true href=#-if-a-function-call-is-in-tail-position>#</a></h3><p>🧠 When a function ends with <code>return anotherFunction()</code>, you don’t need a new frame — just reuse the current one.</p><p>💻 Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>f</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>g</span><span class=p>();</span> <span class=c1>// Tail call!
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>🔥 <strong>PTC (Proper Tail Call)</strong> optimization:</p><ul><li>Don’t grow the stack.</li><li>Especially useful in <strong>tail-recursive</strong> functions.</li></ul><p>🧩 ⚠️ Only Safari (JavaScriptCore) supports it. Most engines <strong>do not</strong> implement this due to debugging stack traces.</p><hr><h2 id=-closures>🔁 Closures<a hidden class=anchor aria-hidden=true href=#-closures>#</a></h2><h3 id=-whenever-a-function-is-created-it-also-memorizes>📌 <strong>“Whenever a function is created, it also memorizes…”</strong><a hidden class=anchor aria-hidden=true href=#-whenever-a-function-is-created-it-also-memorizes>#</a></h3><p>🧠 A closure is a function bundled with the variables from the scope in which it was created.</p><p>💻</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>outer</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nx>x</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=p>()</span> <span class=p>=&gt;</span> <span class=nx>x</span><span class=p>;</span>  <span class=c1>// &lt;- closure
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>f</span> <span class=o>=</span> <span class=nx>outer</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>f</span><span class=p>());</span> <span class=c1>// 10
</span></span></span></code></pre></div><p>🧬 <strong>Mental model</strong>: Think of the returned function as carrying a backpack filled with variables it saw when it was created.</p><p>🔗 Related:</p><ul><li>Lexical Environment</li><li><code>var</code>, <code>let</code>, <code>const</code> scoping</li></ul><hr><p>Let me know when you&rsquo;re ready for the next section — or if you&rsquo;d like me to turn this into an Anki-style Q&amp;A deck for reinforcement.
Absolutely — let’s do a <strong>line-by-line recursive breakdown</strong> of this <code>Job Queue and Event Loop</code> section with full senior-engineer depth, intuition, code traces, runtime metaphors, and links to memory model concepts.</p><hr><h2 id=-section-job-queue-and-event-loop>🔁 Section: <strong>Job Queue and Event Loop</strong><a hidden class=anchor aria-hidden=true href=#-section-job-queue-and-event-loop>#</a></h2><hr><h3 id=-an-agent-is-a-thread-which-means-the-interpreter-can-only-process-one-statement-at-a-time>📌 <strong>“An agent is a thread, which means the interpreter can only process one statement at a time.”</strong><a hidden class=anchor aria-hidden=true href=#-an-agent-is-a-thread-which-means-the-interpreter-can-only-process-one-statement-at-a-time>#</a></h3><p>🧠 Simple: JavaScript is <em>single-threaded</em> — only one thing runs at a time per agent.</p><p>🧩 Engine Insight:</p><ul><li>In the browser, an <em>agent</em> could be your main window (the tab), or a worker.</li><li>Think of the JS engine as a tiny CPU that processes one instruction at a time — no matter how many cores your real CPU has.</li></ul><p>🧬 Analogy: Like a chef who can only cook one dish at a time. Others must wait their turn.</p><hr><h3 id=-when-the-code-is-all-synchronous-this-is-fine-because-we-can-always-make-progress>📌 <strong>“When the code is all synchronous, this is fine because we can always make progress.”</strong><a hidden class=anchor aria-hidden=true href=#-when-the-code-is-all-synchronous-this-is-fine-because-we-can-always-make-progress>#</a></h3><p>🧠 This means: As long as the code doesn&rsquo;t pause for anything (like network or timers), it just runs straight to the end.</p><p>🔗 Related: Synchronous code uses the <strong>call stack</strong>, not the <strong>job queue</strong>.</p><p>💻</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>add</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>add</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>);</span> <span class=c1>// runs synchronously
</span></span></span></code></pre></div><hr><h3 id=-but-if-the-code-needs-to-perform-asynchronous-action-then-we-cannot-progress-unless-that-action-is-completed>📌 <strong>“But if the code needs to perform asynchronous action, then we cannot progress unless that action is completed.”</strong><a hidden class=anchor aria-hidden=true href=#-but-if-the-code-needs-to-perform-asynchronous-action-then-we-cannot-progress-unless-that-action-is-completed>#</a></h3><p>🧠 Async actions (e.g. fetch, setTimeout) <em>pause</em> until external conditions are ready (data returned, timer elapsed).</p><p>⚠️ If JS waited synchronously for async things → the browser would freeze.</p><hr><h3 id=-however-it-would-be-detrimental-to-user-experience-if-that-halts-the-whole-program>📌 <strong>“However, it would be detrimental to user experience if that halts the whole program&mldr;”</strong><a hidden class=anchor aria-hidden=true href=#-however-it-would-be-detrimental-to-user-experience-if-that-halts-the-whole-program>#</a></h3><p>🧬 Metaphor: Imagine a barista who freezes every time a customer orders a coffee — until it&rsquo;s brewed. The line would stall.</p><p>🔥 <strong>Why JS must be async</strong>: It&rsquo;s embedded in browsers. You <strong>must</strong> be able to scroll, type, click even if some JS is waiting.</p><hr><h3 id=-therefore-the-code-that-handles-the-completion-of-that-asynchronous-action-is-defined-as-a-callback>📌 <strong>“Therefore, the code that handles the completion of that asynchronous action is defined as a callback.”</strong><a hidden class=anchor aria-hidden=true href=#-therefore-the-code-that-handles-the-completion-of-that-asynchronous-action-is-defined-as-a-callback>#</a></h3><p>🧠 The logic to run after a wait is defined <em>ahead of time</em> as a <strong>callback function</strong>.</p><p>💻</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s1>&#39;Done waiting!&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>},</span> <span class=mi>1000</span><span class=p>);</span>
</span></span></code></pre></div><ul><li><code>() => console.log(...)</code> is the callback</li><li>It is <strong>queued</strong>, not run immediately.</li></ul><hr><h3 id=-this-callback-defines-a-job-which-gets-placed-into-a-job-queueor-in-html-terminology-an-event-looponce-the-action-is-completed>📌 <strong>“This callback defines a job, which gets placed into a job queue—or, in HTML terminology, an event loop—once the action is completed.”</strong><a hidden class=anchor aria-hidden=true href=#-this-callback-defines-a-job-which-gets-placed-into-a-job-queueor-in-html-terminology-an-event-looponce-the-action-is-completed>#</a></h3><p>🧩 The callback becomes a <strong>job</strong> → a mini &ldquo;task&rdquo; to execute later.</p><p>🧠 The <strong>event loop</strong> is the orchestrator: it picks the next job from the queue when the call stack is empty.</p><hr><h2 id=-summary-mental-model-so-far>🔄 Summary Mental Model So Far:<a hidden class=anchor aria-hidden=true href=#-summary-mental-model-so-far>#</a></h2><pre tabindex=0><code>[ Main Thread ] --&gt; Executes sync code until stack is empty
                  | When async completes:
[ Event Loop ] ---+&gt; Pulls next job from Job Queue
[ Job Queue ] ----&gt; Contains callbacks from timers, promises, events
</code></pre><hr><h3 id=-every-time-the-agent-pulls-a-job-from-the-queue-and-executes-it>📌 <strong>“Every time, the agent pulls a job from the queue and executes it.”</strong><a hidden class=anchor aria-hidden=true href=#-every-time-the-agent-pulls-a-job-from-the-queue-and-executes-it>#</a></h3><p>🧠 The engine continuously pulls and runs jobs in a loop (hence: “event loop”).</p><p>🔁 The cycle:</p><ul><li>Job queue: filled by browser or platform APIs</li><li>Event loop: pulls job → creates execution context → pushes on stack → runs → pops</li></ul><hr><h3 id=-when-the-job-is-executed-it-may-create-more-jobs>📌 <strong>“When the job is executed, it may create more jobs…”</strong><a hidden class=anchor aria-hidden=true href=#-when-the-job-is-executed-it-may-create-more-jobs>#</a></h3><p>🧠 Example: You can queue new async work <em>from inside</em> another job.</p><p>💻</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;first&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;second&#34;</span><span class=p>),</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>},</span> <span class=mi>0</span><span class=p>);</span>
</span></span></code></pre></div><hr><h3 id=-jobs-might-not-be-pulled-with-uniform-priority>📌 <strong>“Jobs might not be pulled with uniform priority&mldr;”</strong><a hidden class=anchor aria-hidden=true href=#-jobs-might-not-be-pulled-with-uniform-priority>#</a></h3><p>🧠 Some jobs are <strong>more urgent</strong> than others!</p><p>🔗 <strong>Microtasks vs Tasks</strong></p><ul><li><strong>Microtasks</strong>: promise callbacks, <code>queueMicrotask</code></li><li><strong>Tasks</strong>: setTimeout, setInterval, UI events</li></ul><p>🧩 Microtasks are <strong>always drained first</strong>, after each job.</p><p>💻</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nb>Promise</span><span class=p>.</span><span class=nx>resolve</span><span class=p>().</span><span class=nx>then</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;microtask&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;task&#34;</span><span class=p>),</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Output: microtask, then task
</span></span></span></code></pre></div><hr><h3 id=-if-the-job-queue-is-empty-the-agent-waits-for-more-jobs-to-be-added>📌 <strong>“If the job queue is empty, the agent waits for more jobs to be added.”</strong><a hidden class=anchor aria-hidden=true href=#-if-the-job-queue-is-empty-the-agent-waits-for-more-jobs-to-be-added>#</a></h3><p>🧠 Idle state. The event loop sleeps until the browser or platform API triggers new work.</p><p>🧬 Like a delivery robot that naps until someone rings the bell.</p><hr><h2 id=-run-to-completion>⚡ &ldquo;Run-to-completion&rdquo;<a hidden class=anchor aria-hidden=true href=#-run-to-completion>#</a></h2><h3 id=-each-job-is-processed-completely-before-any-other-job-is-processed>📌 <strong>“Each job is processed completely before any other job is processed.”</strong><a hidden class=anchor aria-hidden=true href=#-each-job-is-processed-completely-before-any-other-job-is-processed>#</a></h3><p>🧠 JS never interrupts mid-function.</p><p>🧬 Analogy: Once a doctor starts surgery, no one can stop them to ask a question — they must finish.</p><p>🔗 Contrast: In C/Java, threads can preempt each other. In JS, once a job starts, it <em>owns the CPU</em> until it finishes.</p><hr><h3 id=-whenever-a-function-runs-it-cannot-be-preempted>📌 <strong>“whenever a function runs, it cannot be preempted…”</strong><a hidden class=anchor aria-hidden=true href=#-whenever-a-function-runs-it-cannot-be-preempted>#</a></h3><p>🧠 This is why JS avoids <strong>race conditions</strong> inside jobs.</p><p>💻 Code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>let</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nb>Promise</span><span class=p>.</span><span class=nx>resolve</span><span class=p>().</span><span class=nx>then</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span> <span class=nx>i</span><span class=o>++</span><span class=p>;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>i</span><span class=p>);</span> <span class=p>});</span>
</span></span><span class=line><span class=cl><span class=nb>Promise</span><span class=p>.</span><span class=nx>resolve</span><span class=p>().</span><span class=nx>then</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span> <span class=nx>i</span><span class=o>++</span><span class=p>;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>i</span><span class=p>);</span> <span class=p>});</span>
</span></span></code></pre></div><p>🧬 Each <code>.then()</code> is a microtask → runs separately → but <strong>not simultaneously</strong></p><p>📤 Output: 1 then 2 — always predictable.</p><hr><h2 id=-downside-long-jobs-freeze-the-app>🚨 Downside: Long jobs freeze the app<a hidden class=anchor aria-hidden=true href=#-downside-long-jobs-freeze-the-app>#</a></h2><h3 id=-if-a-job-takes-too-long-to-complete-the-web-application-is-unable-to-process-user-interactions>📌 <strong>“if a job takes too long to complete, the web application is unable to process user interactions&mldr;”</strong><a hidden class=anchor aria-hidden=true href=#-if-a-job-takes-too-long-to-complete-the-web-application-is-unable-to-process-user-interactions>#</a></h3><p>🧠 While a job is running, the browser can’t repaint, handle scroll, or click events.</p><p>🧩 This is why infinite loops freeze tabs.</p><p>🔥 Modern browsers will warn: <strong>“Script is taking too long”</strong></p><p>✅ Best Practice:</p><ul><li>Break up big tasks using <code>setTimeout</code> or <code>requestIdleCallback</code></li></ul><p>💻 Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>heavyWork</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=kd>let</span> <span class=nx>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=o>&lt;</span> <span class=mf>1e9</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span> <span class=cm>/*...*/</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>// bad – blocks UI
</span></span></span></code></pre></div><hr><h2 id=-never-blocking>✅ Never Blocking<a hidden class=anchor aria-hidden=true href=#-never-blocking>#</a></h2><h3 id=-handling-io-is-typically-performed-via-events-and-callbacks>📌 <strong>“Handling I/O is typically performed via events and callbacks…”</strong><a hidden class=anchor aria-hidden=true href=#-handling-io-is-typically-performed-via-events-and-callbacks>#</a></h3><p>🧠 This is the heart of JS&rsquo;s async model. It uses <em>non-blocking</em> I/O.</p><p>💻 When you call <code>fetch()</code>, JS:</p><ol><li>Starts network request in background</li><li>Finishes current script</li><li>Runs your callback when data is ready</li></ol><hr><h3 id=--10>📌 <strong>“&mldr;which defines a job to be added to the job queue once the action completes.”</strong><a hidden class=anchor aria-hidden=true href=#--10>#</a></h3><p>🔁 Consistent pattern:</p><ul><li>You give JS a function → it adds it as a <strong>job</strong> when the async work completes</li></ul><p>💻</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>fetch</span><span class=p>(</span><span class=nx>url</span><span class=p>).</span><span class=nx>then</span><span class=p>(</span><span class=nx>data</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// this is a job
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>});</span>
</span></span></code></pre></div><hr><h3 id=-some-legacy-exceptions-exist-like-alert-or-synchronous-xhr>📌 <strong>“Some legacy exceptions exist like alert() or synchronous XHR.”</strong><a hidden class=anchor aria-hidden=true href=#-some-legacy-exceptions-exist-like-alert-or-synchronous-xhr>#</a></h3><p>🧠 These are <strong>blocking APIs</strong> — they freeze the event loop.</p><p>🚫 Avoid:</p><ul><li><code>alert()</code></li><li><code>confirm()</code></li><li>synchronous <code>XMLHttpRequest</code></li></ul><p>They break the &ldquo;never blocking&rdquo; contract.</p><hr><h2 id=-final-takeaway-mental-model>✅ Final Takeaway Mental Model<a hidden class=anchor aria-hidden=true href=#-final-takeaway-mental-model>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>[ Call Stack ]
</span></span><span class=line><span class=cl>  |     runs sync code
</span></span><span class=line><span class=cl>  |     while stack is empty, pull jobs...
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[ Event Loop ]
</span></span><span class=line><span class=cl>  ↳ prioritizes Microtask Queue (Promises)
</span></span><span class=line><span class=cl>  ↳ then Task Queue (Timers, Events)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[ Microtask Queue ]
</span></span><span class=line><span class=cl>  ↳ .then(), catch(), queueMicrotask()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[ Task Queue ]
</span></span><span class=line><span class=cl>  ↳ setTimeout, DOM events, fetch completion
</span></span></code></pre></div><hr><p>Let me know when you&rsquo;re ready for the <strong>next section</strong>, or if you want a code visualization to simulate this step-by-step.</p><p>Awesome — you&rsquo;re diving into the <strong>deepest part</strong> of the JavaScript execution model: 🧠 <strong>agent clusters, memory sharing, and concurrency guarantees</strong>.</p><p>Let’s now break it down <strong>recursively, step-by-step</strong> with:</p><ul><li>🧠 <em>ELI5</em> (but senior engineer depth)</li><li>🧬 Metaphors + system-level mental models</li><li>💻 Code examples</li><li>🔁 Runtime traces if needed</li><li>⚠️ Gotchas + edge cases</li><li>🔗 Connections to internals (e.g., call stack, Web Workers, SharedArrayBuffer, Atomics)</li></ul><hr><h2 id=-section-1--agent-clusters-and-memory-sharing>📦 [SECTION 1] — <strong>Agent clusters and memory sharing</strong><a hidden class=anchor aria-hidden=true href=#-section-1--agent-clusters-and-memory-sharing>#</a></h2><hr><h3 id=-multiple-agents-can-communicate-via-memory-sharing-forming-an-agent-cluster>🔹 &ldquo;<strong>Multiple agents can communicate via memory sharing, forming an agent cluster.</strong>&rdquo;<a hidden class=anchor aria-hidden=true href=#-multiple-agents-can-communicate-via-memory-sharing-forming-an-agent-cluster>#</a></h3><p>🧠 <strong>What&rsquo;s an agent?</strong><br>Think of an <strong>agent</strong> as an <strong>independent JavaScript execution thread</strong>.</p><ul><li>On the web, this includes <strong>Window</strong>, <strong>Dedicated Worker</strong>, <strong>Shared Worker</strong>, <strong>Service Worker</strong>, <strong>Worklet</strong>, etc.</li></ul><p>🧬 <strong>Metaphor:</strong> Each agent is a chef in their own kitchen. Normally, they can&rsquo;t see or touch each other’s tools or food, but if we allow shared ingredients (memory), they become part of the same restaurant (agent cluster).</p><p>💡 <strong>Agent cluster</strong> = a group of agents that can <strong>share memory</strong>, especially <strong>SharedArrayBuffer</strong>.</p><hr><h3 id=-agents-are-within-the-same-cluster-if-and-only-if-they-can-share-memory>🔹 &ldquo;<strong>Agents are within the same cluster if and only if they can share memory.</strong>&rdquo;<a hidden class=anchor aria-hidden=true href=#-agents-are-within-the-same-cluster-if-and-only-if-they-can-share-memory>#</a></h3><p>🔒 Memory sharing is the <strong>defining rule</strong> for clustering.<br>No memory sharing = not in the same cluster.</p><p>🧠 Think: A dedicated worker <strong>created by</strong> a window can share memory with it — they live in the same memory &ldquo;neighborhood.&rdquo;</p><hr><h3 id=-there-is-no-built-in-mechanism-for-two-agent-clusters-to-exchange-any-information>🔹 &ldquo;<strong>There is no built-in mechanism for two agent clusters to exchange any information&mldr; regarded as completely isolated execution models.</strong>&rdquo;<a hidden class=anchor aria-hidden=true href=#-there-is-no-built-in-mechanism-for-two-agent-clusters-to-exchange-any-information>#</a></h3><p>⚠️ Once memory isn&rsquo;t shared, you&rsquo;re in a different universe.</p><p>💬 Agents <strong>in different clusters</strong> can’t <strong>see</strong> or <strong>affect</strong> each other. No messaging, no memory sync.<br>This protects <strong>data integrity</strong>, prevents <strong>deadlocks</strong>, and improves <strong>security/sandboxing</strong>.</p><hr><h2 id=-section-2--when-are-agents-in-the-same-cluster>🧱 [SECTION 2] — <strong>When are agents in the same cluster?</strong><a hidden class=anchor aria-hidden=true href=#-section-2--when-are-agents-in-the-same-cluster>#</a></h2><p>Let’s go line-by-line on the examples.</p><hr><h3 id=-can-share-memory-same-agent-cluster>✅ <strong>CAN share memory (same agent cluster)</strong><a hidden class=anchor aria-hidden=true href=#-can-share-memory-same-agent-cluster>#</a></h3><ol><li><p><strong>A <code>Window</code> and a <code>DedicatedWorker</code> it created</strong><br>→ This is the classic case:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>worker</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Worker</span><span class=p>(</span><span class=s2>&#34;worker.js&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>They’re “parent-child” and can share <code>SharedArrayBuffer</code>.</p></li><li><p><strong>Any worker and a dedicated worker it created</strong><br>→ Nested workers:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// In worker A
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>nested</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Worker</span><span class=p>(</span><span class=s2>&#34;nested.js&#34;</span><span class=p>);</span>
</span></span></code></pre></div></li><li><p><strong>A <code>Window</code> and a same-origin <code>iframe</code> it created</strong><br>→ Same-origin iframe = same memory model.</p></li><li><p><strong>A <code>Window</code> and a same-origin window that opened it</strong><br>→ If <code>window.open()</code> is used and both have same origin → shared memory is possible.</p></li><li><p><strong>A <code>Window</code> and a worklet it created</strong><br>→ Worklets (e.g., AudioWorklet) run in a specialized context, but under the hood they&rsquo;re still in the cluster.</p></li></ol><hr><h3 id=-cannot-share-memory-different-agent-clusters>❌ <strong>CANNOT share memory (different agent clusters)</strong><a hidden class=anchor aria-hidden=true href=#-cannot-share-memory-different-agent-clusters>#</a></h3><ol><li><p><strong>A <code>Window</code> and a shared worker it created</strong></p><ul><li>Shared workers have global scope across tabs — memory isolation enforced.</li></ul></li><li><p><strong>Any worker and a shared worker it created</strong></p><ul><li>Again: shared workers are multi-tenant → no memory sharing.</li></ul></li><li><p><strong>A <code>Window</code> and a service worker it created</strong></p><ul><li>Service workers are meant to be persistent proxies — not memory-bound to their creators.</li></ul></li><li><p><strong><code>Window</code> and an iframe with a different origin</strong></p><ul><li>Same document origin = OK. Otherwise → <strong>cross-origin sandboxing</strong>.</li></ul></li><li><p><strong>Two unrelated <code>Window</code> objects</strong> (even if same-origin!)</p><ul><li>If there’s no opener/ancestor relationship → isolation.</li></ul></li></ol><hr><h2 id=-section-3--cross-agent-communication-and-memory-model>📤 [SECTION 3] — <strong>Cross-agent communication and memory model</strong><a hidden class=anchor aria-hidden=true href=#-section-3--cross-agent-communication-and-memory-model>#</a></h2><hr><h3 id=-agents-communicate-via-memory-sharing>🔹 &ldquo;<strong>Agents communicate via memory sharing</strong>&rdquo;<a hidden class=anchor aria-hidden=true href=#-agents-communicate-via-memory-sharing>#</a></h3><p>💡 On the web, you can use:</p><ul><li><code>postMessage()</code> → sends data by <strong>copying</strong> (structured clone).</li><li><code>SharedArrayBuffer</code> → sends a <strong>reference</strong> to the same memory.</li></ul><hr><h3 id=-typically-data-is-passed-by-value-only-via-structured-cloning>🔹 &ldquo;<strong>Typically, data is passed by value only (via structured cloning)</strong>&rdquo;<a hidden class=anchor aria-hidden=true href=#-typically-data-is-passed-by-value-only-via-structured-cloning>#</a></h3><p>🧠 This means that <code>postMessage()</code> <strong>copies</strong> the data:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>worker</span><span class=p>.</span><span class=nx>postMessage</span><span class=p>({</span> <span class=nx>name</span><span class=o>:</span> <span class=s2>&#34;foo&#34;</span> <span class=p>});</span> <span class=c1>// copied, not shared
</span></span></span></code></pre></div><p>💡 No concurrency issues — each agent has its <strong>own version</strong>.</p><hr><h3 id=-to-share-memory-one-must-post-a->🔹 &ldquo;<strong>To share memory, one must post a <code>SharedArrayBuffer</code>&mldr;</strong>&rdquo;<a hidden class=anchor aria-hidden=true href=#-to-share-memory-one-must-post-a->#</a></h3><p>💻 Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>shared</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>SharedArrayBuffer</span><span class=p>(</span><span class=mi>1024</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>worker</span><span class=p>.</span><span class=nx>postMessage</span><span class=p>(</span><span class=nx>shared</span><span class=p>);</span> <span class=c1>// shared, not cloned
</span></span></span></code></pre></div><p>🧠 Now both sides have <strong>shared view</strong> of the same memory. Enter: ⚠️ <strong>concurrency risk</strong>.</p><hr><h3 id=-once-agents-share-memory>🔹 &ldquo;<strong>Once agents share memory&mldr; they can synchronize via <code>Atomics</code></strong>&rdquo;<a hidden class=anchor aria-hidden=true href=#-once-agents-share-memory>#</a></h3><p>💡 <code>Atomics</code> = low-level tools like locks or barriers:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>arr</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Int32Array</span><span class=p>(</span><span class=nx>sharedBuffer</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>Atomics</span><span class=p>.</span><span class=nx>store</span><span class=p>(</span><span class=nx>arr</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>123</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>Atomics</span><span class=p>.</span><span class=nx>notify</span><span class=p>(</span><span class=nx>arr</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span></code></pre></div><ul><li><code>Atomics.wait</code>, <code>notify</code>, <code>add</code>, <code>compareExchange</code> — ensure safe coordination.</li></ul><hr><h3 id=-normal-memory-access-is-not-atomic>🔹 &ldquo;<strong>Normal memory access is not atomic</strong>&rdquo;<a hidden class=anchor aria-hidden=true href=#-normal-memory-access-is-not-atomic>#</a></h3><p>⚠️ You risk <strong>data races</strong> without <code>Atomics</code>. For example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=nx>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span> <span class=c1>// NOT safe in concurrent context
</span></span></span></code></pre></div><hr><h3 id=-atomic-access-is-sequentially-consistent>🔹 &ldquo;<strong>Atomic access is sequentially consistent</strong>&rdquo;<a hidden class=anchor aria-hidden=true href=#-atomic-access-is-sequentially-consistent>#</a></h3><p>🧠 Means all agents see memory changes in the <strong>same order</strong>.</p><p>🧬 Metaphor: Everyone reads from the same official whiteboard, in strict timestamp order.</p><hr><h3 id=-non-atomic-access-is-unordered>🔹 &ldquo;<strong>Non-atomic access is unordered</strong>&rdquo;<a hidden class=anchor aria-hidden=true href=#-non-atomic-access-is-unordered>#</a></h3><p>💣 You can’t assume what value an agent will see. Could read half-updated memory!</p><hr><h2 id=-section-4--guidelines-for-shared-memory-programs>🔒 [SECTION 4] — <strong>Guidelines for shared memory programs</strong><a hidden class=anchor aria-hidden=true href=#-section-4--guidelines-for-shared-memory-programs>#</a></h2><hr><h3 id=-rule-1-make-it-data-race-free>🧠 Rule #1: <strong>Make it data-race free</strong><a hidden class=anchor aria-hidden=true href=#-rule-1-make-it-data-race-free>#</a></h3><p>That means:<br>✅ Only one agent accesses a memory location at a time<br>✅ If concurrent access happens, <strong>must use <code>Atomics</code></strong></p><p>💡 If race-free, you don’t need to memorize weird memory model details.</p><hr><h3 id=-rule-2-use-strongly-typed-memory-access>🧠 Rule #2: <strong>Use strongly typed memory access</strong><a hidden class=anchor aria-hidden=true href=#-rule-2-use-strongly-typed-memory-access>#</a></h3><p>→ Don’t mix atomic and non-atomic access on same cell<br>→ Don’t access memory with different sizes (e.g., <code>Int8</code> and <code>Int32</code>) at once</p><p>⚠️ Otherwise: <strong>value tearing</strong> = corrupted memory values</p><hr><h2 id=-section-5--concurrency-and-forward-progress>🚧 [SECTION 5] — <strong>Concurrency and forward progress</strong><a hidden class=anchor aria-hidden=true href=#-section-5--concurrency-and-forward-progress>#</a></h2><hr><h3 id=-an-agent-can-become-blocked>🔹 &ldquo;<strong>An agent can become blocked&mldr; waiting on another agent</strong>&rdquo;<a hidden class=anchor aria-hidden=true href=#-an-agent-can-become-blocked>#</a></h3><p>💡 Unlike promises (which <strong>yield control</strong> back), <code>Atomics.wait()</code> can <strong>halt</strong> the whole thread:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>Atomics</span><span class=p>.</span><span class=nx>wait</span><span class=p>(</span><span class=nx>sharedArray</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span> <span class=c1>// blocking call
</span></span></span></code></pre></div><p>🧠 This blocks until someone else wakes it up with <code>Atomics.notify</code>.</p><hr><h3 id=-forward-progress-guarantees>🔹 <strong>Forward progress guarantees</strong>:<a hidden class=anchor aria-hidden=true href=#-forward-progress-guarantees>#</a></h3><p>These prevent deadlocks:</p><ul><li>✅ If agent has its own thread → it will eventually run</li><li>✅ If many agents share a thread → one will eventually run</li><li>✅ Agents only block each other <strong>via explicit APIs</strong> (<code>Atomics.wait</code>, <code>sync XHR</code>, etc.)</li></ul><hr><h3 id=-only-certain-agents-can-be-blocked>🔹 <strong>Only certain agents can be blocked</strong><a hidden class=anchor aria-hidden=true href=#-only-certain-agents-can-be-blocked>#</a></h3><p>📌 On web:</p><ul><li>✅ Dedicated workers and shared workers → can block</li><li>❌ Service workers, same-origin windows → cannot block (must stay responsive)</li></ul><hr><h3 id=-agent-clusters-cannot-be-partially-deactivated>🔹 <strong>Agent clusters cannot be partially deactivated</strong><a hidden class=anchor aria-hidden=true href=#-agent-clusters-cannot-be-partially-deactivated>#</a></h3><p>💡 Ensures <strong>one agent doesn’t starve others</strong>:</p><blockquote><p>E.g., if a window goes inactive, it can’t suspend its worker if that worker is holding a lock needed by others.</p></blockquote><hr><h2 id=-section-6--cluster-termination>💥 [SECTION 6] — <strong>Cluster termination</strong><a hidden class=anchor aria-hidden=true href=#-section-6--cluster-termination>#</a></h2><hr><h3 id=-an-agent-may-be-pausedresumedterminated-without-its-knowledge>🔹 &ldquo;<strong>An agent may be paused/resumed/terminated without its knowledge</strong>&rdquo;<a hidden class=anchor aria-hidden=true href=#-an-agent-may-be-pausedresumedterminated-without-its-knowledge>#</a></h3><p>🧬 Real-world analogy: The OS may freeze your app if tab is in the background.</p><hr><h3 id=-if-one-agent-in-a-cluster-is-terminated-all-are-terminated>🔹 &ldquo;<strong>If one agent in a cluster is terminated, all are terminated</strong>&rdquo;<a hidden class=anchor aria-hidden=true href=#-if-one-agent-in-a-cluster-is-terminated-all-are-terminated>#</a></h3><p>📌 To avoid weird bugs:</p><ul><li>Prevent lock holder (e.g. a dedicated worker) from holding up others</li><li>Clean, deterministic teardown</li></ul><hr><h2 id=-summary-1>🧠 Summary<a hidden class=anchor aria-hidden=true href=#-summary-1>#</a></h2><table><thead><tr><th>Concept</th><th>What it means</th></tr></thead><tbody><tr><td>Agent</td><td>A JS execution context (Window, Worker)</td></tr><tr><td>Agent cluster</td><td>A group of agents that <strong>can share memory</strong></td></tr><tr><td>Shared memory</td><td>Via <code>SharedArrayBuffer</code></td></tr><tr><td>Synchronization</td><td>Via <code>Atomics</code></td></tr><tr><td>Race-free design</td><td>Avoids memory corruption</td></tr><tr><td>Blocked agent</td><td>Can halt progress if not designed carefully</td></tr><tr><td>Cluster termination</td><td>Whole cluster dies if one dies</td></tr></tbody></table><hr><p>Want to go deeper into:</p><ul><li>Code examples using <code>SharedArrayBuffer</code> and <code>Atomics</code>?</li><li>Agent cluster detection or visualization?</li><li>Simulation of race conditions?</li></ul><p>Let’s pick a direction!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://archit15singh.github.io/tags/javascript/>JavaScript</a></li><li><a href=https://archit15singh.github.io/tags/javascript-execution-model/>JavaScript Execution Model</a></li></ul><nav class=paginav><a class=prev href=https://archit15singh.github.io/posts/minimal-test-post/><span class=title>« Prev Page</span><br><span>Minimal Test Post</span>
</a><a class=next href=https://archit15singh.github.io/posts/2022-07-29-test-post/><span class=title>Next Page »</span><br><span>Test Post</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share JS execution model in depth on twitter" href="https://twitter.com/intent/tweet/?text=JS%20execution%20model%20in%20depth&amp;url=https%3a%2f%2farchit15singh.github.io%2fposts%2f2022-07-29-js-execution-model-in-depth%2f&amp;hashtags=JavaScript%2cJavaScriptExecutionModel"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share JS execution model in depth on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2farchit15singh.github.io%2fposts%2f2022-07-29-js-execution-model-in-depth%2f&amp;title=JS%20execution%20model%20in%20depth&amp;summary=JS%20execution%20model%20in%20depth&amp;source=https%3a%2f%2farchit15singh.github.io%2fposts%2f2022-07-29-js-execution-model-in-depth%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share JS execution model in depth on reddit" href="https://reddit.com/submit?url=https%3a%2f%2farchit15singh.github.io%2fposts%2f2022-07-29-js-execution-model-in-depth%2f&title=JS%20execution%20model%20in%20depth"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share JS execution model in depth on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2farchit15singh.github.io%2fposts%2f2022-07-29-js-execution-model-in-depth%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share JS execution model in depth on whatsapp" href="https://api.whatsapp.com/send?text=JS%20execution%20model%20in%20depth%20-%20https%3a%2f%2farchit15singh.github.io%2fposts%2f2022-07-29-js-execution-model-in-depth%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share JS execution model in depth on telegram" href="https://telegram.me/share/url?text=JS%20execution%20model%20in%20depth&amp;url=https%3a%2f%2farchit15singh.github.io%2fposts%2f2022-07-29-js-execution-model-in-depth%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><div class=container><div class="content has-text-centered"><p><strong>Archit's Space</strong> - Sharing knowledge one post at a time.<br>Crafted with ❤️ by Archit Singh</a>.<br>Connect with me on
<a href=https://github.com/archit15singh target=_blank>GitHub</a>,
<a href=https://www.linkedin.com/in/archit15singh target=_blank>LinkedIn</a>,
and <a href=https://twitter.com/archit15singh target=_blank>Twitter</a>.</p></div></div></footer><script data-goatcounter=https://architsingh.goatcounter.com/count async src=//gc.zgo.at/count.js></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>