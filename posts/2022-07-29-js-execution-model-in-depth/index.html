<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>JS execution model in depth | Archit's Space</title>
<meta name=keywords content="JavaScript,JavaScript Execution Model"><meta name=description content="An in-depth breakdown of the JS execution model"><meta name=author content="Archit Singh"><link rel=canonical href=https://archit15singh.github.io/posts/2022-07-29-js-execution-model-in-depth/><link crossorigin=anonymous href=/assets/css/stylesheet.min.1c5241cc5c31e8a1af5a56caa332bfa60cee35277d8fb31c7063ca9ed7258093.css integrity="sha256-HFJBzFwx6KGvWlbKozK/pgzuNSd9j7MccGPKntclgJM=" rel="preload stylesheet" as=style><link rel=icon href=https://archit15singh.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://archit15singh.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://archit15singh.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://archit15singh.github.io/apple-touch-icon.png><link rel=mask-icon href=https://archit15singh.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.145.0"><link rel=alternate hreflang=en href=https://archit15singh.github.io/posts/2022-07-29-js-execution-model-in-depth/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="JS execution model in depth"><meta property="og:description" content="An in-depth breakdown of the JS execution model"><meta property="og:type" content="article"><meta property="og:url" content="https://archit15singh.github.io/posts/2022-07-29-js-execution-model-in-depth/"><meta property="og:image" content="https://archit15singh.github.io/images/uploads/cosmic-timetraveler.webp"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-29T12:00:00+00:00"><meta property="article:modified_time" content="2022-07-29T12:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://archit15singh.github.io/images/uploads/cosmic-timetraveler.webp"><meta name=twitter:title content="JS execution model in depth"><meta name=twitter:description content="An in-depth breakdown of the JS execution model"><meta name=twitter:site content="@https://twitter.com/archit_singh15"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://archit15singh.github.io/posts/"},{"@type":"ListItem","position":2,"name":"JS execution model in depth","item":"https://archit15singh.github.io/posts/2022-07-29-js-execution-model-in-depth/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"JS execution model in depth","name":"JS execution model in depth","description":"An in-depth breakdown of the JS execution model","keywords":["JavaScript","JavaScript Execution Model"],"articleBody":"JS execution model Alright, let’s break this down recursively and deeply, line by line, starting with the JavaScript execution model intro and progressing through the first sections. I’ll give you:\nLiteral meaning (What it says) Deeper understanding (Why it matters) Mental model / real-world analogy (To cement intuition) 📘 “JavaScript execution model” ✅ Literal meaning: This document explains how JavaScript runs behind the scenes — how it processes code, manages memory, handles functions, etc.\n🔍 Deeper understanding: Think of this as the operating system of JavaScript — what actually happens when you write let a = 5 or setTimeout(...).\n🧠 Analogy: If your code is like a script in a play, the execution model is the stage manager deciding when and how each line of the script gets read and acted upon.\n📝 “This page introduces the basic infrastructure of the JavaScript runtime environment.” ✅ Literal meaning: We’re talking about the runtime — where JS code is executed (not compiled). This includes things like memory, stacks, event loops, etc.\n🔍 Deeper understanding: JavaScript isn’t just interpreted randomly. There’s a whole structure that controls how code gets parsed, run, paused, resumed.\n🧠 Analogy: Imagine a kitchen: the runtime is the kitchen itself (countertop = stack, fridge = heap, bell = job queue). Chefs = JavaScript agents.\n🛠 “The model is largely theoretical and abstract, without any platform-specific or implementation-specific details.” ✅ Literal meaning: This isn’t about Chrome’s V8 engine or Node’s internals — it’s the universal, spec-level blueprint.\n🔍 Deeper understanding: You’re learning how things should behave according to ECMAScript — the spec all JS engines follow (more or less).\n🧠 Analogy: Like learning the rules of chess, not how Magnus Carlsen plays.\n🧠 “Modern JavaScript engines heavily optimize the described semantics.” ✅ Literal meaning: Real engines like V8 or SpiderMonkey tweak things under the hood for speed, but they follow the same rules.\n🔍 Deeper understanding: JS engines may compile JS to bytecode, inline functions, optimize away allocations — but logically, they obey this model.\n🧠 Analogy: Like a Formula 1 pit crew following safety rules — they do things super fast, but not incorrectly.\n📖 “This page is a reference. It assumes you are already familiar with the execution model of other programming languages, such as C and Java.” ✅ Literal meaning: If you’ve worked with languages that have stacks, heaps, and memory — this will feel familiar.\n🔍 Deeper understanding: JS is dynamic and event-driven, but under the hood, it’s not that different from C/Java — it just hides more from you.\n🧠 Analogy: It’s like someone who’s driven automatic cars learning how a manual transmission works under the hood.\n🔧 “It makes heavy references to existing concepts in operating systems and programming languages.” ✅ Literal meaning: Terms like stack, heap, queue, thread — all come from OS/PL theory.\n🔍 Deeper understanding: This section connects JS to how all programming languages manage code execution and memory.\n🧠 Analogy: It’s like learning JavaScript’s “internals” by understanding its plumbing — threads, memory, job queues.\nNext section…\n🔥 The engine and the host 🧩 “JavaScript execution requires the cooperation of two pieces of software: the JavaScript engine and the host environment.” ✅ Literal meaning: JS doesn’t run on its own. It needs:\nA JS engine (like V8, SpiderMonkey) A host (like the browser or Node) 🔍 Deeper understanding: The engine knows how to parse and run JavaScript. The host (browser/Node) knows how to give JS things to do — like making network requests or rendering HTML.\n🧠 Analogy: The JS engine is the actor. The host is the stage, props, lighting, and audience.\n🧠 “The JavaScript engine implements the ECMAScript (JavaScript) language, providing the core functionality.” ✅ Literal meaning: The engine knows what let, function, Promise, etc., mean. That’s ECMAScript.\n🔍 Deeper understanding: Things like setTimeout or document.querySelector? Those are host-provided, not part of the language spec.\n🧠 Analogy: The engine knows English. The host gives it a job — like reading a book, or talking to a user.\n🌍 “In order to interact with the outside world […] we need additional environment-specific mechanisms provided by the host environment.” ✅ Literal meaning: To talk to files, web APIs, timers, you need help from the host — JS alone can’t do it.\n🔍 Deeper understanding: This is where browsers give us document, and Node gives us fs, etc. It’s why JS looks different in each environment.\n🧠 Analogy: JavaScript is a brilliant chef, but it needs the host to supply groceries, an oven, or even the guests to cook for.\n🌐 “For example, the HTML DOM is the host environment when JavaScript is executed in a web browser. Node.js is another host environment…” ✅ Literal meaning: DOM and window exist only in the browser. require and process exist only in Node.\n🔍 Deeper understanding: Same language, different surroundings = different power/tools. JS is host-agnostic; host APIs change.\n🧠 Analogy: Same actor, different movie set. A sci-fi set vs. a historical drama set gives the actor different things to interact with.\nAwesome — let’s dive into a line-by-line, recursive breakdown of the JavaScript Execution Model section. I’ll break down each sentence, unpack the underlying concepts, and relate them to real-world analogies and code where helpful.\n🔹JavaScript execution model This page introduces the basic infrastructure of the JavaScript runtime environment.\nBreakdown: We’re about to learn how JavaScript runs “under the hood.” That means looking beyond syntax into how your code gets executed, managed, and scheduled by the JS engine. The model is largely theoretical and abstract, without any platform-specific or implementation-specific details.\nBreakdown: This is not about how Chrome, Node, or Deno implement JavaScript — it’s about the ECMAScript specification-level model. Think of this as the universal blueprint all JS engines follow. Modern JavaScript engines heavily optimize the described semantics.\nBreakdown: V8 (Chrome), SpiderMonkey (Firefox), and others add many performance improvements — JIT compilation, inlining, hidden classes — but they preserve the behavior defined in this theoretical model. 🔹This page is a reference. It assumes you are already familiar with the execution model of other programming languages, such as C and Java. Breakdown: It expects you know what a call stack, heap, and execution context are from other languages — but don’t worry, we’ll unpack everything from a JavaScript-first view. 🔹The engine and the host JavaScript execution requires the cooperation of two pieces of software: the JavaScript engine and the host environment.\nBreakdown: Engine → Understands \u0026 runs JS (e.g. V8, SpiderMonkey). Host → Provides APIs outside of JS (e.g., the DOM, setTimeout, fs in Node). 📌 Analogy: The engine is the actor, but the host is the stage, props, and audience.\nThe JavaScript engine implements the ECMAScript (JavaScript) language, providing the core functionality. It takes source code, parses it, and executes it.\nBreakdown: Parses → Converts your code into an Abstract Syntax Tree (AST). Executes → Evaluates it via interpreters or compilers. let x = 5; Engine knows how to parse and execute this, but not how to access the DOM. That’s the host’s job. However, in order to interact with the outside world, such as to produce any meaningful output, to interface with external resources, or to implement security- or performance-related mechanisms, we need additional environment-specific mechanisms provided by the host environment.\nBreakdown: Engine alone can’t do I/O, networking, file access. Host provides: console.log, fetch, setTimeout, document, process.env, etc. For example, the HTML DOM is the host environment when JavaScript is executed in a web browser. Node.js is another host environment that allows JavaScript to be run on the server side.\nBreakdown: Browser = JS engine + DOM + window + events. Node = JS engine + fs, http, Buffer, process, etc. While we focus primarily on the mechanisms defined in ECMAScript in this reference, we will occasionally talk about mechanisms defined in the HTML spec, which is often mimicked by other host environments like Node.js or Deno.\nBreakdown: Core focus = ECMAScript (language spec). But we’ll touch on HTML-defined behaviors (like the Event Loop, microtasks) — because Node/Deno borrow them too. 🔹Agent Execution Model In the JavaScript specification, each autonomous executor of JavaScript is called an agent, which maintains its facilities for code execution:\nBreakdown: Think of an agent as an independent “runner” of JavaScript — like a tab, worker, or Node thread. Each agent has its own heap, call stack, and job queue. Now, let’s recursively unpack the three components of an agent:\n🔸 Heap (of objects) This is just a name to denote a large (mostly unstructured) region of memory. It gets populated as objects get created in the program.\nBreakdown: Heap = where reference types live: objects, arrays, closures, functions. Variables like let obj = {} create entries in the heap. let obj = { name: \"you\" }; The object lives in the heap; obj points to it.\nNote that in the case of shared memory, each agent has its own heap with its own version of a SharedArrayBuffer object, but the underlying memory represented by the buffer is shared.\nBreakdown: Each worker/tab has its own isolated heap — but shared memory (via SharedArrayBuffer) creates cross-agent bridges. Shared memory enables atomic operations between agents. 📌 Think: Multiple agents → own memory → but one shared space for coordination.\n🔸 Queue (of jobs) This is known in HTML (and also commonly) as the event loop which enables asynchronous programming in JavaScript while being single-threaded.\nBreakdown: Queue = Job Queue / Task Queue. Works with the event loop to schedule async tasks (like setTimeout, Promises). It’s called a queue because it’s generally first-in-first-out: earlier jobs are executed before later ones.\nBreakdown: Classic FIFO structure. Tasks are queued and executed one by one, preserving order. 🔸 Stack (of execution contexts) This is what’s known as a call stack and allows transferring control flow by entering and exiting execution contexts like functions.\nBreakdown: Stack = execution history — functions being called and exited. LIFO — last-in, first-out. function a() { b(); } function b() { c(); } a(); // a → b → c → return → return → return It’s called a stack because it’s last-in-first-out. Every job enters by pushing a new frame onto the (empty) stack, and exits by emptying the stack.\nBreakdown: A function call pushes a frame onto the stack. When it returns, the frame is popped off. These are three distinct data structures that keep track of different data.\nHeap → Long-lived objects. Queue → Pending jobs (like fetch().then()). Stack → Current execution chain (call stack). We will introduce the queue and the stack in more detail in the following sections. To read more about how heap memory is allocated and freed, see memory management.\nBreakdown: Stack and queue will be our main focus because they control how code runs. Heap is for storage, not flow. 🧠 Up Next: We’ll dive into the next section — realms, agents on the web (workers, windows), and how these fit together using the diagram you shared.\nWant to continue into that next?\nAwesome — let’s go line by line, step by step, recursively breaking down every idea here. I’ll unpack it intuitively, back it up with examples, and link it to real-world behavior.\n🔹 Line 1: “These are three distinct data structures that keep track of different data.”\n🧠 Intuition: In the agent model, three “buckets” manage different responsibilities:\nStructure Purpose Example Heap Stores all dynamic data (objects, functions) {name: \"John\"} or an array [1,2,3] lives here Queue List of “jobs” waiting to run (asynchronous tasks) setTimeout(() =\u003e {}, 1000) gets added to queue Stack Keeps track of what function is running right now When calling functions, stack tracks “who called who” 🎯 Real-World Analogy: Heap = Warehouse of data Stack = A to-do list that follows last in, first out — newest task gets done first Queue = A waiting room — first in, first out — oldest task gets picked up first 🔹 Line 2: “We will introduce the queue and the stack in more detail in the following sections.”\n🧠 Intuition: They’re setting you up: heap is mostly a memory detail (not directly manipulated much), but queue and stack are critical to how JavaScript behaves, especially: Why async code works Why console.log runs before a setTimeout Why promises feel synchronous sometimes You’ll learn:\nStack: Why recursion fails with “maximum call stack size exceeded” Queue: Why this logs in order: console.log(\"A\"); setTimeout(() =\u003e console.log(\"B\")); console.log(\"C\"); // Output: A C B 🔹 Line 3: “To read more about how heap memory is allocated and freed, see memory management.”\n🧠 Intuition: The heap is where all your objects live — and they stick around as long as something references them.\nlet x = { name: \"Alice\" }; // stored in the heap x = null; // garbage collected (freed from heap eventually) No manual memory management in JS. The garbage collector watches references.\n🔹 Line 4: “Each agent is analogous to a thread (note that the underlying implementation may or may not be an actual operating system thread).”\n🧠 Key Concept: Agent ≈ Thread But not exactly.\nJavaScript itself is single-threaded — only one agent running main code. But environments (like browsers or Node.js) spawn multiple agents (like Web Workers). 🔍 Important: Just because JavaScript feels single-threaded doesn’t mean there’s only one thread underneath.\nExample: If you use a Web Worker, that code runs in its own agent, with its own heap, queue, and stack.\n// main.js const worker = new Worker(\"worker.js\"); // worker.js onmessage = (e) =\u003e { // This is a separate agent! postMessage(\"Got it\"); }; 🔹 Line 5: “Each agent can own multiple realms (which 1-to-1 correlate with global objects) that can synchronously access each other, and thus needs to run in a single execution thread.”\n🧠 Intuition: A realm is like a sandboxed environment: it has its own globalThis, Array, Function, etc. Inside one agent, multiple realms can talk to each other synchronously (because they share the same stack/queue). 📦 Real-world example:\nIn a browser, your main page and a same-origin iframe are in the same agent, but different realms. \u003ciframe src=\"same-origin.html\"\u003e\u003c/iframe\u003e Inside both:\nconsole.log(window.Array === iframe.contentWindow.Array); // ❌ false Why? Different realms, different versions of built-in objects like Array.\n🔹 Line 6: “An agent also has a single memory model, indicating whether it’s little-endian, whether it can be synchronously blocked, whether atomic operations are lock-free, etc.”\n🧠 What this means: This dives into low-level behavior, useful when you’re dealing with shared memory (e.g., SharedArrayBuffer) and concurrency.\nLittle-endian: Byte ordering in memory (most systems are little-endian). Lock-free atomic operations: Allows agents to coordinate via memory safely. Synchronous blocking: Whether one agent can halt another (usually avoided in JS for responsiveness). 🛠 You’ll care about this if you’re:\nUsing Atomics.wait / Atomics.notify Coordinating workers via shared memory Doing real-time or performance-critical code ✅ Summary Table Concept What It Does Practical Example Heap Stores all objects { user: \"A\" } Stack Tracks function calls foo() calls bar() Queue Holds async jobs setTimeout(), Promise.then() Agent Self-contained executor (heap+stack+queue) Main thread or Worker Realm Global environment inside an agent Main page vs iframe Memory Model Rules for memory access SharedArrayBuffer, Atomics 🔥 Want to go deeper into one of these now? I can:\nVisualize how a realm compares to an agent Show a step-by-step simulation of the stack and queue Break down how two agents use shared memory safely Let me know your next target — I’m ready to go recursive on it.\nGreat! Let’s continue the recursive breakdown from where we left off. We just finished:\n“An agent also has a single memory model, indicating whether it’s little-endian, whether it can be synchronously blocked, whether atomic operations are lock-free, etc.”\nNow, the next part of the MDN doc says:\n📌 Next block: “An agent on the web can be one of the following: A Similar-origin window agent, which contains various Window objects which can potentially reach each other, either directly or by using document.domain. If the window is origin-keyed, then only same-origin windows can reach each other. A Dedicated worker agent containing a single DedicatedWorkerGlobalScope. A Shared worker agent containing a single SharedWorkerGlobalScope. A Service worker agent containing a single ServiceWorkerGlobalScope. A Worklet agent containing a single WorkletGlobalScope.” ✅ Let’s go line-by-line and recursively break this down: 🔹 Line 1: “An agent on the web can be one of the following:”\n🧠 Big idea: On the web, each type of “execution environment” (like a browser tab, a worker, etc.) is backed by its own agent — meaning it has its own heap, stack, and queue.\nThink of each agent as its own little JS runtime.\n🔹 Line 2: “A Similar-origin window agent, which contains various Window objects which can potentially reach each other, either directly or by using document.domain. If the window is origin-keyed, then only same-origin windows can reach each other.”\n🧠 What’s going on here? A window agent = Your main page + all same-origin iframes you embed in it.\n🔄 Shared Agent Example: \u003ciframe src=\"https://yourdomain.com/page.html\"\u003e\u003c/iframe\u003e These two can share memory and synchronously access each other:\n// From parent page console.log(window.frames[0].document.body); 🧪 But if the iframe is cross-origin, access is blocked for security.\n⚠️ Security twist: If document.domain is set (deprecated but still used), two subdomains can loosen the restriction a bit.\n// both pages set document.domain = \"example.com\"; Then they can reach each other, even if one is a.example.com and one is b.example.com.\n🔹 Line 3: “A Dedicated worker agent containing a single DedicatedWorkerGlobalScope.”\n🧠 What is a Dedicated Worker Agent? When you create a Web Worker in the browser:\nconst worker = new Worker(\"worker.js\"); That script (worker.js) runs in its own dedicated worker agent — with its own heap, queue, and stack — completely separate from the main thread.\n🔁 Communication is done asynchronously via postMessage() — like this:\n// main.js worker.postMessage(\"hi\"); // worker.js onmessage = (e) =\u003e { console.log(\"Got:\", e.data); }; ⚠️ You cannot synchronously access memory between main thread and a dedicated worker (unless using SharedArrayBuffer).\n🔹 Line 4: “A Shared worker agent containing a single SharedWorkerGlobalScope.”\n🧠 Difference between Shared Worker and Dedicated Worker? Dedicated Worker: Only 1 page can talk to it. Shared Worker: Multiple tabs (from the same origin) can talk to the same worker. // In two tabs of the same site: const sharedWorker = new SharedWorker(\"worker.js\"); Now both tabs talk to the same long-living agent!\nWhy use this?\nShare data between tabs Maintain a centralized cache Reduce memory usage 📦 But again — it’s a separate agent with its own stack/heap/queue.\n🔹 Line 5: “A Service worker agent containing a single ServiceWorkerGlobalScope.”\n🧠 What’s special about Service Workers? They’re background scripts that sit between your site and the network. Intercept requests (fetch), cache stuff, serve offline pages. // Registering a service worker navigator.serviceWorker.register(\"sw.js\"); 🧠 They:\nOutlive pages Don’t have access to DOM Run in their own agent 💡 Use case:\nself.addEventListener(\"fetch\", (event) =\u003e { event.respondWith(caches.match(event.request)); }); Service workers have a completely isolated memory space and no direct access to the DOM.\n🔹 Line 6: “A Worklet agent containing a single WorkletGlobalScope.”\n🧠 What’s a Worklet? Advanced topic — used for things like:\nCSS Paint API Web Audio API (AudioWorklet) Animations 🔊 Example: An AudioWorklet lets you do low-latency audio processing on a separate thread (agent).\n// In main thread audioContext.audioWorklet.addModule(\"processor.js\"); // processor.js class MyProcessor extends AudioWorkletProcessor { process(inputs, outputs, parameters) { // run audio processing return true; } } registerProcessor(\"my-processor\", MyProcessor); These agents are super-lightweight, meant for tiny, focused jobs like drawing or audio frames.\n🧠 Summary: Agent Type Runs in Has Own Stack/Heap/Queue? Use Case Similar-origin Window Agent Main page + iframes (same origin) ✅ Yes Regular DOM pages Dedicated Worker Agent Worker created via new Worker() ✅ Yes Offload CPU-intensive tasks Shared Worker Agent Shared among multiple tabs ✅ Yes Tab-to-tab communication Service Worker Agent Background fetch/caching logic ✅ Yes Offline apps, PWA Worklet Agent Lightweight visual/audio tasks ✅ Yes Audio, CSS, animations You want to continue to the next part after this? It’s:\n“In other words, each worker creates its own agent, while one or more windows may be within the same agent—usually a main document and its similar-origin iframes…”\nJust say the word and we’ll keep recursively breaking it down with visuals and mental models.\nPerfect! Let’s do a recursive breakdown of this next section, line by line, with intuitive mental models, visuals-in-your-head, and real-world JavaScript usage.\n🧠 Big Context: You just learned that each agent is like an isolated JavaScript runtime: it has its own heap, call stack, and job queue.\nNow you’re learning:\n🔍 “What are the different types of agents on the web?”\nLet’s go line by line:\n🔹 1. “An agent on the web can be one of the following:” ✅ Translation:\nOn the web, there are several “execution environments” where JavaScript can run.\nEach is backed by a separate agent, i.e., its own isolated execution infrastructure.\n🧩 Now we explore each type: 🔹 2. “A Similar-origin window agent, which contains various Window objects which can potentially reach each other, either directly or by using document.domain. If the window is origin-keyed, then only same-origin windows can reach each other.” 🧠 What this means: This is your main webpage, plus any iframes inside it that share the same origin (protocol + host + port). These “windows” share the same agent, and can talk to each other synchronously. 🧪 Real-World Example: \u003ciframe src=\"https://yourdomain.com/page.html\"\u003e\u003c/iframe\u003e You can do this from the parent:\nconst iframeDoc = window.frames[0].document; console.log(iframeDoc.title); // works if same origin ⚠️ If they’re cross-origin, that line throws a security error (unless both set document.domain).\n📌 What is document.domain? A deprecated way to let subdomains trust each other:\n// a.example.com and b.example.com both set: document.domain = \"example.com\"; → Now they can talk synchronously.\n🔹 3. “A Dedicated worker agent containing a single DedicatedWorkerGlobalScope.” 🧠 What this means: When you use a Web Worker, like this:\nconst worker = new Worker(\"worker.js\"); You’re spinning up a new agent behind the scenes.\nThat agent has:\nIts own heap Its own stack Its own event queue It runs worker.js in isolation.\n💡 Real-World Use Case: // main.js worker.postMessage({ task: \"fibonacci\", n: 40 }); // worker.js onmessage = (e) =\u003e { const result = doHeavyFibonacci(e.data.n); postMessage(result); }; → This keeps your UI thread smooth and responsive while the heavy calculation runs in another agent (aka thread-like sandbox).\n🔹 4. “A Shared worker agent containing a single SharedWorkerGlobalScope.” 🧠 Meaning: Unlike a dedicated worker, a SharedWorker is shared across multiple tabs.\nYou create it like:\nconst sharedWorker = new SharedWorker(\"worker.js\"); This launches an agent that lives beyond a single page, shared between tabs of the same origin.\n📌 Use case: You’re building a real-time dashboard with multiple tabs.\nYou want all tabs to share a single:\nWebSocket connection Cache State The shared worker agent holds that logic, and all tabs send messages to it.\n🔹 5. “A Service worker agent containing a single ServiceWorkerGlobalScope.” 🧠 Meaning: Service workers are special. They’re not tied to a tab.\nThey sit in the background and intercept network requests.\nYou register one like:\nnavigator.serviceWorker.register(\"/sw.js\"); The sw.js file runs in its own agent with:\nNo DOM access Its own global scope (ServiceWorkerGlobalScope) A lifetime independent from your pages 📌 Use case: Offline support Background sync Push notifications // sw.js self.addEventListener(\"fetch\", (event) =\u003e { event.respondWith(caches.match(event.request)); }); This runs in a background agent even when no tabs are open.\n🔹 6. “A Worklet agent containing a single WorkletGlobalScope.” 🧠 What is a Worklet? Worklets are tiny, low-latency JS programs.\nThey’re used for audio processing, custom painting, etc.\nThey are isolated agents that are super-performant, meant for frame-by-frame rendering or DSP (digital signal processing).\n🧪 Use Case: // AudioWorklet audioContext.audioWorklet.addModule(\"processor.js\"); // processor.js registerProcessor(\"my-processor\", class extends AudioWorkletProcessor { process(inputs, outputs, params) { // handle audio here return true; } }); Each worklet runs in a micro-agent with hard real-time constraints.\n🔹 7. “In other words, each worker creates its own agent, while one or more windows may be within the same agent—usually a main document and its similar-origin iframes.” 🔁 Recap: Workers (dedicated, shared, service, worklet) → always create new agents Windows (tabs, iframes) → may share one agent if they are same origin 📦 So:\nIf you new Worker(), you get a new agent. If you create a same-origin iframe, it’s part of your agent. If it’s a cross-origin iframe, it likely gets its own agent. 🔹 8. “In Node.js, a similar concept called worker threads is available.” 🧠 In Node.js: const { Worker } = require(\"worker_threads\"); new Worker(\"./worker.js\"); That is exactly equivalent to a dedicated worker agent on the web.\nIt has its own stack, heap, queue Communicates via postMessage Can use SharedArrayBuffer for shared memory 🔧 This is Node’s way of mimicking browser agents in the backend.\n✅ Summary Mental Model: Imagine each agent as a little isolated mini JavaScript world with:\n📦 its own memory (heap) 🧠 its own thinking (call stack) 🕓 its own scheduler (job queue) Then:\nnew Worker() → new agent SharedWorker → shared agent across tabs ServiceWorker → background agent Worklet → real-time micro-agent Same-origin iframe → stays in same agent as parent Want to move to the next block (i.e., Realms)?\nIt starts with:\n“Each agent owns one or more realms…”\nJust say “next”, and I’ll recursively break that one down too.\nPerfect. Let’s do a deep recursive breakdown of this “Realms” section—line by line, with intuition, real examples, and mental models.\n🔰 Topic: What is a Realm? A Realm is like a self-contained JS universe inside an agent.\nThink of it as a “VM inside a thread”.\n🔹 Line 1: “Each agent owns one or more realms.”\n🧠 Intuition:\nWe already learned that an agent is like a JS thread — with its own stack, heap, and event queue.\nA realm lives inside an agent.\nSo one agent can have many realms.\n💡 Real-world Analogy: Agent = one CPU core running JavaScript Realm = one JavaScript sandbox running a specific program (like a tab or an iframe) 🧪 On the web:\nA main tab is one realm. A same-origin iframe is a different realm. But both can live inside the same agent (thread). 🔹 Line 2: “Each piece of JavaScript code is associated with a realm when it’s loaded, which remains the same even when called from another realm.”\n🧠 What’s happening? When a JS file loads in a context (tab, iframe, worker), it’s bound to the realm of that context.\nEven if it’s later called from another realm, it still uses the original realm it was loaded in.\n📦 Example: \u003ciframe id=\"frame\" src=\"iframe.html\"\u003e\u003c/iframe\u003e \u003cscript\u003e const fn = window.frames[0].someFunction; fn(); // This still executes in iframe.html’s realm! \u003c/script\u003e Even though you called the function from the main page, it still executes with the context of the iframe realm. Why? Because that’s where it was created.\n🧠 Functions are sticky to the realm they were born in.\n🔹 Line 3–5: “A realm consists of the following information:\nA list of intrinsic objects like Array, Array.prototype, etc. Globally declared variables, the value of globalThis, and the global object A cache of template literal arrays, because evaluation of the same tagged template literal expression always causes the tag to receive the same array object” 🔸 1. Intrinsic objects (e.g. Array, Object, Function, etc.) Every realm gets its own versions of core JS constructors:\n// iframe.html Array !== parent.Array; // true Each realm gets its own Array, Object, Function, etc.\nThey might behave the same — but they are different objects in memory.\n🔸 2. Global variables and globalThis Every realm has its own global scope — this includes:\nwindow in main thread self in workers globalThis (unified access) So in two realms:\n// Realm A globalThis === window; // true // Realm B (worker) globalThis === self; // true But:\nrealmA.globalThis !== realmB.globalThis; // true Each has its own isolated namespace.\n🔸 3. Template literal cache This is a performance optimization:\nWhen you use tagged template literals, the same template array object is reused:\nfunction tag(strings) { console.log(strings); // same array on repeated calls } tag`Hello ${name}`; tag`Hello ${name}`; This cache is per-realm, not global.\n🔹 Line 6: “On the web, the realm and the global object are 1-to-1 corresponded. The global object is either a Window, a WorkerGlobalScope, or a WorkletGlobalScope.”\n🧠 Translation:\nEach realm has exactly one global object, and vice versa.\nOn the web:\nRealm Global Object Tab / iframe Window Worker WorkerGlobalScope Worklet WorkletGlobalScope That’s why if you get the window in the main page and compare it to an iframe’s, they’re not equal.\n🔹 Line 7: “So for example, every iframe executes in a different realm, though it may be in the same agent as the parent window.”\n✅ Recap of layers:\niframe.html = different realm index.html = different realm But both can share the same agent (thread), and thus talk synchronously const iframe = window.frames[0]; iframe.document !== document // ✅ different realm typeof iframe.Array === \"function\" // ✅ iframe has its own Array constructor 🔹 Line 8: “Realms are usually mentioned when talking about the identities of global objects.”\n🧠 This sets up the next gotcha:\nObjects might “look” the same (e.g. arrays from two realms) But under the hood, their identity is different 🔹 Final Line: “For example, we need methods such as Array.isArray() or Error.isError(), because an array constructed in another realm will have a different prototype object than the Array.prototype object in the current realm, so instanceof Array will wrongly return false.”\n🧪 Mind-blowing Real World Bug: // index.html const arr = window.frames[0].contentWindow.eval(\"[]\"); console.log(arr instanceof Array); // ❌ false Array.isArray(arr); // ✅ true Why? Because:\ninstanceof uses current realm’s Array.prototype But arr was created in another realm, so it’s linked to iframe’s Array.prototype → So they’re not the same prototype — instanceof fails.\n✅ Array.isArray() uses internal tags and works across realms.\n🔄 Summary (Mental Model) Concept Meaning Realm A self-contained JS “universe” with its own global scope and built-in objects Agent A thread-like runner that can host one or more realms Function’s Realm Determined by where it was created, not called Cross-realm instanceof fails Because prototype objects are realm-specific Global object The realm’s anchor: Window, WorkerGlobalScope, etc. Tag template cache Cached per-realm to avoid array recreation Would you like to move on to the next section:\n“Stack and execution contexts”\nJust say “next” and I’ll break that down in the same step-by-step, deeply intuitive style.\n","wordCount":"5074","inLanguage":"en","image":"https://archit15singh.github.io/images/uploads/cosmic-timetraveler.webp","datePublished":"2022-07-29T12:00:00Z","dateModified":"2022-07-29T12:00:00Z","author":{"@type":"Person","name":"Archit Singh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://archit15singh.github.io/posts/2022-07-29-js-execution-model-in-depth/"},"publisher":{"@type":"Organization","name":"Archit's Space","logo":{"@type":"ImageObject","url":"https://archit15singh.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://archit15singh.github.io/ accesskey=h title="Archit's Space (Alt + H)">Archit's Space</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://archit15singh.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://archit15singh.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://archit15singh.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://archit15singh.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://archit15singh.github.io/posts/>Posts</a></div><h1 class=post-title>JS execution model in depth</h1><div class=post-description>An in-depth breakdown of the JS execution model</div><div class=post-meta><span title="2022-07-29 12:00:00 +0000 UTC">July 29, 2022</span>&nbsp;·&nbsp;24 min</div></header><figure class=entry-cover><img loading=lazy src=https://archit15singh.github.io/images/uploads/cosmic-timetraveler.webp alt="JS execution model"><p>JS execution model</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#js-execution-model aria-label="JS execution model">JS execution model</a><ul><ul><li><a href=#- aria-label="📘 &ldquo;JavaScript execution model&rdquo;">📘 <strong>&ldquo;JavaScript execution model&rdquo;</strong></a><ul><li><a href=#-literal-meaning aria-label="✅ Literal meaning:">✅ Literal meaning:</a></li><li><a href=#-deeper-understanding aria-label="🔍 Deeper understanding:">🔍 Deeper understanding:</a></li><li><a href=#-analogy aria-label="🧠 Analogy:">🧠 Analogy:</a></li></ul></li><li><a href=#--1 aria-label="📝 &ldquo;This page introduces the basic infrastructure of the JavaScript runtime environment.&rdquo;">📝 <strong>&ldquo;This page introduces the basic infrastructure of the JavaScript runtime environment.&rdquo;</strong></a><ul><li><a href=#-literal-meaning-1 aria-label="✅ Literal meaning:">✅ Literal meaning:</a></li><li><a href=#-deeper-understanding-1 aria-label="🔍 Deeper understanding:">🔍 Deeper understanding:</a></li><li><a href=#-analogy-1 aria-label="🧠 Analogy:">🧠 Analogy:</a></li></ul></li><li><a href=#--2 aria-label="🛠 &ldquo;The model is largely theoretical and abstract, without any platform-specific or implementation-specific details.&rdquo;">🛠 <strong>&ldquo;The model is largely theoretical and abstract, without any platform-specific or implementation-specific details.&rdquo;</strong></a><ul><li><a href=#-literal-meaning-2 aria-label="✅ Literal meaning:">✅ Literal meaning:</a></li><li><a href=#-deeper-understanding-2 aria-label="🔍 Deeper understanding:">🔍 Deeper understanding:</a></li><li><a href=#-analogy-2 aria-label="🧠 Analogy:">🧠 Analogy:</a></li></ul></li><li><a href=#--3 aria-label="🧠 &ldquo;Modern JavaScript engines heavily optimize the described semantics.&rdquo;">🧠 <strong>&ldquo;Modern JavaScript engines heavily optimize the described semantics.&rdquo;</strong></a><ul><li><a href=#-literal-meaning-3 aria-label="✅ Literal meaning:">✅ Literal meaning:</a></li><li><a href=#-deeper-understanding-3 aria-label="🔍 Deeper understanding:">🔍 Deeper understanding:</a></li><li><a href=#-analogy-3 aria-label="🧠 Analogy:">🧠 Analogy:</a></li></ul></li><li><a href=#--4 aria-label="📖 &ldquo;This page is a reference. It assumes you are already familiar with the execution model of other programming languages, such as C and Java.&rdquo;">📖 <strong>&ldquo;This page is a reference. It assumes you are already familiar with the execution model of other programming languages, such as C and Java.&rdquo;</strong></a><ul><li><a href=#-literal-meaning-4 aria-label="✅ Literal meaning:">✅ Literal meaning:</a></li><li><a href=#-deeper-understanding-4 aria-label="🔍 Deeper understanding:">🔍 Deeper understanding:</a></li><li><a href=#-analogy-4 aria-label="🧠 Analogy:">🧠 Analogy:</a></li></ul></li><li><a href=#--5 aria-label="🔧 &ldquo;It makes heavy references to existing concepts in operating systems and programming languages.&rdquo;">🔧 <strong>&ldquo;It makes heavy references to existing concepts in operating systems and programming languages.&rdquo;</strong></a><ul><li><a href=#-literal-meaning-5 aria-label="✅ Literal meaning:">✅ Literal meaning:</a></li><li><a href=#-deeper-understanding-5 aria-label="🔍 Deeper understanding:">🔍 Deeper understanding:</a></li><li><a href=#-analogy-5 aria-label="🧠 Analogy:">🧠 Analogy:</a></li></ul></li></ul><li><a href=#-the-engine-and-the-host aria-label="🔥 The engine and the host">🔥 <strong>The engine and the host</strong></a><ul><li><a href=#--6 aria-label="🧩 &ldquo;JavaScript execution requires the cooperation of two pieces of software: the JavaScript engine and the host environment.&rdquo;">🧩 <strong>&ldquo;JavaScript execution requires the cooperation of two pieces of software: the JavaScript engine and the host environment.&rdquo;</strong></a><ul><li><a href=#-literal-meaning-6 aria-label="✅ Literal meaning:">✅ Literal meaning:</a></li><li><a href=#-deeper-understanding-6 aria-label="🔍 Deeper understanding:">🔍 Deeper understanding:</a></li><li><a href=#-analogy-6 aria-label="🧠 Analogy:">🧠 Analogy:</a></li></ul></li><li><a href=#--7 aria-label="🧠 &ldquo;The JavaScript engine implements the ECMAScript (JavaScript) language, providing the core functionality.&rdquo;">🧠 <strong>&ldquo;The JavaScript engine implements the ECMAScript (JavaScript) language, providing the core functionality.&rdquo;</strong></a><ul><li><a href=#-literal-meaning-7 aria-label="✅ Literal meaning:">✅ Literal meaning:</a></li><li><a href=#-deeper-understanding-7 aria-label="🔍 Deeper understanding:">🔍 Deeper understanding:</a></li><li><a href=#-analogy-7 aria-label="🧠 Analogy:">🧠 Analogy:</a></li></ul></li><li><a href=#--8 aria-label="🌍 &ldquo;In order to interact with the outside world [&mldr;] we need additional environment-specific mechanisms provided by the host environment.&rdquo;">🌍 <strong>&ldquo;In order to interact with the outside world [&mldr;] we need additional environment-specific mechanisms provided by the host environment.&rdquo;</strong></a><ul><li><a href=#-literal-meaning-8 aria-label="✅ Literal meaning:">✅ Literal meaning:</a></li><li><a href=#-deeper-understanding-8 aria-label="🔍 Deeper understanding:">🔍 Deeper understanding:</a></li><li><a href=#-analogy-8 aria-label="🧠 Analogy:">🧠 Analogy:</a></li></ul></li><li><a href=#--9 aria-label="🌐 &ldquo;For example, the HTML DOM is the host environment when JavaScript is executed in a web browser. Node.js is another host environment&mldr;&rdquo;">🌐 <strong>&ldquo;For example, the HTML DOM is the host environment when JavaScript is executed in a web browser. Node.js is another host environment&mldr;&rdquo;</strong></a><ul><li><a href=#-literal-meaning-9 aria-label="✅ Literal meaning:">✅ Literal meaning:</a></li><li><a href=#-deeper-understanding-9 aria-label="🔍 Deeper understanding:">🔍 Deeper understanding:</a></li><li><a href=#-analogy-9 aria-label="🧠 Analogy:">🧠 Analogy:</a></li></ul></li><li><a href=#javascript-execution-model aria-label="🔹JavaScript execution model">🔹<strong>JavaScript execution model</strong></a></li><li><a href=#this-page-is-a-reference-it-assumes-you-are-already-familiar-with-the-execution-model-of-other-programming-languages-such-as-c-and-java aria-label="🔹This page is a reference. It assumes you are already familiar with the execution model of other programming languages, such as C and Java.">🔹<strong>This page is a reference. It assumes you are already familiar with the execution model of other programming languages, such as C and Java.</strong></a></li><li><a href=#the-engine-and-the-host aria-label="🔹The engine and the host">🔹<strong>The engine and the host</strong></a></li><li><a href=#agent-execution-model aria-label="🔹Agent Execution Model">🔹<strong>Agent Execution Model</strong></a><ul><li><a href=#-heap-of-objects aria-label="🔸 Heap (of objects)">🔸 <strong>Heap (of objects)</strong></a></li><li><a href=#-queue-of-jobs aria-label="🔸 Queue (of jobs)">🔸 <strong>Queue (of jobs)</strong></a></li><li><a href=#-stack-of-execution-contexts aria-label="🔸 Stack (of execution contexts)">🔸 <strong>Stack (of execution contexts)</strong></a></li></ul></li><li><a href=#-up-next aria-label="🧠 Up Next:">🧠 Up Next:</a></li></ul></li><li><a href=#-line-1 aria-label="🔹 Line 1:">🔹 Line 1:</a><ul><li><a href=#-intuition aria-label="🧠 Intuition:">🧠 Intuition:</a></li><li><a href=#-real-world-analogy aria-label="🎯 Real-World Analogy:">🎯 Real-World Analogy:</a></li></ul></li><li><a href=#-line-2 aria-label="🔹 Line 2:">🔹 Line 2:</a><ul><li><a href=#-intuition-1 aria-label="🧠 Intuition:">🧠 Intuition:</a></li></ul></li><li><a href=#-line-3 aria-label="🔹 Line 3:">🔹 Line 3:</a><ul><li><a href=#-intuition-2 aria-label="🧠 Intuition:">🧠 Intuition:</a></li></ul></li><li><a href=#-line-4 aria-label="🔹 Line 4:">🔹 Line 4:</a><ul><li><a href=#-key-concept-agent--thread aria-label="🧠 Key Concept: Agent ≈ Thread">🧠 Key Concept: <strong>Agent ≈ Thread</strong></a></li></ul></li><li><a href=#-line-5 aria-label="🔹 Line 5:">🔹 Line 5:</a><ul><li><a href=#-intuition-3 aria-label="🧠 Intuition:">🧠 Intuition:</a></li></ul></li><li><a href=#-line-6 aria-label="🔹 Line 6:">🔹 Line 6:</a><ul><li><a href=#-what-this-means aria-label="🧠 What this means:">🧠 What this means:</a></li></ul></li><li><a href=#-summary-table aria-label="✅ Summary Table">✅ Summary Table</a><ul><li><a href=#-want-to-go-deeper-into-one-of-these-now aria-label="🔥 Want to go deeper into one of these now?">🔥 Want to go deeper into one of these now?</a></li></ul></li><li><a href=#-next-block aria-label="📌 Next block:">📌 Next block:</a><ul><li><a href=#an-agent-on-the-web-can-be-one-of-the-following aria-label="“An agent on the web can be one of the following:">“An agent on the web can be one of the following:</a></li><li><a href=#-lets-go-line-by-line-and-recursively-break-this-down aria-label="✅ Let&rsquo;s go line-by-line and recursively break this down:">✅ Let&rsquo;s go <strong>line-by-line and recursively break this down</strong>:</a></li><li><a href=#-line-1-1 aria-label="🔹 Line 1:">🔹 Line 1:</a></li><li><a href=#-line-2-1 aria-label="🔹 Line 2:">🔹 Line 2:</a></li><li><a href=#-whats-going-on-here aria-label="🧠 What&rsquo;s going on here?">🧠 What&rsquo;s going on here?</a><ul><li><a href=#-shared-agent-example aria-label="🔄 Shared Agent Example:">🔄 Shared Agent Example:</a></li><li><a href=#-security-twist aria-label="⚠️ Security twist:">⚠️ Security twist:</a></li></ul></li><li><a href=#-line-3-1 aria-label="🔹 Line 3:">🔹 Line 3:</a></li><li><a href=#-what-is-a-dedicated-worker-agent aria-label="🧠 What is a Dedicated Worker Agent?">🧠 What is a <strong>Dedicated Worker Agent</strong>?</a></li><li><a href=#-line-4-1 aria-label="🔹 Line 4:">🔹 Line 4:</a></li><li><a href=#-difference-between-shared-worker-and-dedicated-worker aria-label="🧠 Difference between Shared Worker and Dedicated Worker?">🧠 Difference between <strong>Shared Worker</strong> and <strong>Dedicated Worker</strong>?</a></li><li><a href=#-line-5-1 aria-label="🔹 Line 5:">🔹 Line 5:</a></li><li><a href=#-whats-special-about-service-workers aria-label="🧠 What’s special about Service Workers?">🧠 What’s special about <strong>Service Workers</strong>?</a></li><li><a href=#-line-6-1 aria-label="🔹 Line 6:">🔹 Line 6:</a></li><li><a href=#-whats-a-worklet aria-label="🧠 What’s a Worklet?">🧠 What’s a <strong>Worklet</strong>?</a></li></ul></li><li><a href=#-summary aria-label="🧠 Summary:">🧠 Summary:</a></li><li><a href=#-big-context aria-label="🧠 Big Context:">🧠 Big Context:</a><ul><li><a href=#-1-an-agent-on-the-web-can-be-one-of-the-following aria-label="🔹 1. “An agent on the web can be one of the following:”">🔹 1. “An agent on the web can be one of the following:”</a></li></ul></li><li><a href=#-now-we-explore-each-type aria-label="🧩 Now we explore each type:">🧩 Now we explore each type:</a><ul><li><a href=#-2-a-similar-origin-window-agent-which-contains-various-window-objects-which-can-potentially-reach-each-other-either-directly-or-by-using-documentdomain-if-the-window-is-origin-keyed-then-only-same-origin-windows-can-reach-each-other aria-label="🔹 2. “A Similar-origin window agent, which contains various Window objects which can potentially reach each other, either directly or by using document.domain. If the window is origin-keyed, then only same-origin windows can reach each other.”">🔹 2. “A Similar-origin window agent, which contains various Window objects which can potentially reach each other, either directly or by using <code>document.domain</code>. If the window is origin-keyed, then only same-origin windows can reach each other.”</a></li><li><a href=#-what-this-means-1 aria-label="🧠 What this means:">🧠 What this means:</a><ul><li><a href=#-real-world-example aria-label="🧪 Real-World Example:">🧪 Real-World Example:</a></li><li><a href=#-what-is-documentdomain aria-label="📌 What is document.domain?">📌 What is <code>document.domain</code>?</a></li></ul></li><li><a href=#-3-a-dedicated-worker-agent-containing-a-single-dedicatedworkerglobalscope aria-label="🔹 3. “A Dedicated worker agent containing a single DedicatedWorkerGlobalScope.”">🔹 3. “A Dedicated worker agent containing a single <code>DedicatedWorkerGlobalScope</code>.”</a></li><li><a href=#-what-this-means-2 aria-label="🧠 What this means:">🧠 What this means:</a><ul><li><a href=#-real-world-use-case aria-label="💡 Real-World Use Case:">💡 Real-World Use Case:</a></li></ul></li><li><a href=#-4-a-shared-worker-agent-containing-a-single-sharedworkerglobalscope aria-label="🔹 4. “A Shared worker agent containing a single SharedWorkerGlobalScope.”">🔹 4. “A Shared worker agent containing a single <code>SharedWorkerGlobalScope</code>.”</a></li><li><a href=#-meaning aria-label="🧠 Meaning:">🧠 Meaning:</a><ul><li><a href=#-use-case aria-label="📌 Use case:">📌 Use case:</a></li></ul></li><li><a href=#-5-a-service-worker-agent-containing-a-single-serviceworkerglobalscope aria-label="🔹 5. “A Service worker agent containing a single ServiceWorkerGlobalScope.”">🔹 5. “A Service worker agent containing a single <code>ServiceWorkerGlobalScope</code>.”</a></li><li><a href=#-meaning-1 aria-label="🧠 Meaning:">🧠 Meaning:</a><ul><li><a href=#-use-case-1 aria-label="📌 Use case:">📌 Use case:</a></li></ul></li><li><a href=#-6-a-worklet-agent-containing-a-single-workletglobalscope aria-label="🔹 6. “A Worklet agent containing a single WorkletGlobalScope.”">🔹 6. “A Worklet agent containing a single <code>WorkletGlobalScope</code>.”</a></li><li><a href=#-what-is-a-worklet aria-label="🧠 What is a Worklet?">🧠 What is a <strong>Worklet</strong>?</a><ul><li><a href=#-use-case-2 aria-label="🧪 Use Case:">🧪 Use Case:</a></li></ul></li><li><a href=#-7-in-other-words-each-worker-creates-its-own-agent-while-one-or-more-windows-may-be-within-the-same-agentusually-a-main-document-and-its-similar-origin-iframes aria-label="🔹 7. “In other words, each worker creates its own agent, while one or more windows may be within the same agent—usually a main document and its similar-origin iframes.”">🔹 7. “In other words, each worker creates its own agent, while one or more windows may be within the same agent—usually a main document and its similar-origin iframes.”</a></li><li><a href=#-recap aria-label="🔁 Recap:">🔁 Recap:</a></li><li><a href=#-8-in-nodejs-a-similar-concept-called-worker-threads-is-available aria-label="🔹 8. “In Node.js, a similar concept called worker threads is available.”">🔹 8. “In Node.js, a similar concept called worker threads is available.”</a></li><li><a href=#-in-nodejs aria-label="🧠 In Node.js:">🧠 In Node.js:</a></li></ul></li><li><a href=#-summary-mental-model aria-label="✅ Summary Mental Model:">✅ Summary Mental Model:</a><ul><li><a href=#-topic-what-is-a-realm aria-label="🔰 Topic: What is a Realm?">🔰 Topic: <strong>What is a Realm?</strong></a></li></ul></li><li><a href=#-line-1-2 aria-label="🔹 Line 1:">🔹 Line 1:</a><ul><li><a href=#-real-world-analogy-1 aria-label="💡 Real-world Analogy:">💡 Real-world Analogy:</a></li></ul></li><li><a href=#-line-2-2 aria-label="🔹 Line 2:">🔹 Line 2:</a><ul><li><a href=#-whats-happening aria-label="🧠 What&rsquo;s happening?">🧠 What&rsquo;s happening?</a><ul><li><a href=#-example aria-label="📦 Example:">📦 Example:</a></li></ul></li></ul></li><li><a href=#-line-35 aria-label="🔹 Line 3–5:">🔹 Line 3–5:</a><ul><li><a href=#-1-intrinsic-objects-eg-array-object-function-etc aria-label="🔸 1. Intrinsic objects (e.g. Array, Object, Function, etc.)">🔸 1. <strong>Intrinsic objects</strong> (e.g. <code>Array</code>, <code>Object</code>, <code>Function</code>, etc.)</a></li><li><a href=#-2-global-variables-and aria-label="🔸 2. Global variables and globalThis">🔸 2. <strong>Global variables and <code>globalThis</code></strong></a></li><li><a href=#-3-template-literal-cache aria-label="🔸 3. Template literal cache">🔸 3. <strong>Template literal cache</strong></a></li></ul></li><li><a href=#-line-6-2 aria-label="🔹 Line 6:">🔹 Line 6:</a></li><li><a href=#-line-7 aria-label="🔹 Line 7:">🔹 Line 7:</a></li><li><a href=#-line-8 aria-label="🔹 Line 8:">🔹 Line 8:</a></li><li><a href=#-final-line aria-label="🔹 Final Line:">🔹 Final Line:</a><ul><li><a href=#-mind-blowing-real-world-bug aria-label="🧪 Mind-blowing Real World Bug:">🧪 Mind-blowing Real World Bug:</a><ul><li><a href=#why aria-label=Why?>Why?</a></li></ul></li></ul></li><li><a href=#-summary-mental-model-1 aria-label="🔄 Summary (Mental Model)">🔄 Summary (Mental Model)</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=js-execution-model>JS execution model<a hidden class=anchor aria-hidden=true href=#js-execution-model>#</a></h1><p>Alright, let’s break this down recursively and deeply, line by line, starting with the <strong>JavaScript execution model</strong> intro and progressing through the first sections. I’ll give you:</p><ol><li><strong>Literal meaning</strong> (What it says)</li><li><strong>Deeper understanding</strong> (Why it matters)</li><li><strong>Mental model / real-world analogy</strong> (To cement intuition)</li></ol><hr><h3 id=->📘 <strong>&ldquo;JavaScript execution model&rdquo;</strong><a hidden class=anchor aria-hidden=true href=#->#</a></h3><h4 id=-literal-meaning>✅ Literal meaning:<a hidden class=anchor aria-hidden=true href=#-literal-meaning>#</a></h4><p>This document explains how JavaScript runs behind the scenes — how it processes code, manages memory, handles functions, etc.</p><h4 id=-deeper-understanding>🔍 Deeper understanding:<a hidden class=anchor aria-hidden=true href=#-deeper-understanding>#</a></h4><p>Think of this as the operating system of JavaScript — what <em>actually happens</em> when you write <code>let a = 5</code> or <code>setTimeout(...)</code>.</p><h4 id=-analogy>🧠 Analogy:<a hidden class=anchor aria-hidden=true href=#-analogy>#</a></h4><p>If your code is like a script in a play, the execution model is the stage manager deciding when and how each line of the script gets read and acted upon.</p><hr><h3 id=--1>📝 <strong>&ldquo;This page introduces the basic infrastructure of the JavaScript runtime environment.&rdquo;</strong><a hidden class=anchor aria-hidden=true href=#--1>#</a></h3><h4 id=-literal-meaning-1>✅ Literal meaning:<a hidden class=anchor aria-hidden=true href=#-literal-meaning-1>#</a></h4><p>We’re talking about the <em>runtime</em> — where JS code is executed (not compiled). This includes things like memory, stacks, event loops, etc.</p><h4 id=-deeper-understanding-1>🔍 Deeper understanding:<a hidden class=anchor aria-hidden=true href=#-deeper-understanding-1>#</a></h4><p>JavaScript isn’t just interpreted randomly. There’s a whole structure that controls how code gets parsed, run, paused, resumed.</p><h4 id=-analogy-1>🧠 Analogy:<a hidden class=anchor aria-hidden=true href=#-analogy-1>#</a></h4><p>Imagine a kitchen: the runtime is the kitchen itself (countertop = stack, fridge = heap, bell = job queue). Chefs = JavaScript agents.</p><hr><h3 id=--2>🛠 <strong>&ldquo;The model is largely theoretical and abstract, without any platform-specific or implementation-specific details.&rdquo;</strong><a hidden class=anchor aria-hidden=true href=#--2>#</a></h3><h4 id=-literal-meaning-2>✅ Literal meaning:<a hidden class=anchor aria-hidden=true href=#-literal-meaning-2>#</a></h4><p>This isn’t about Chrome’s V8 engine or Node’s internals — it’s the universal, spec-level blueprint.</p><h4 id=-deeper-understanding-2>🔍 Deeper understanding:<a hidden class=anchor aria-hidden=true href=#-deeper-understanding-2>#</a></h4><p>You’re learning how things <em>should</em> behave according to ECMAScript — the spec all JS engines follow (more or less).</p><h4 id=-analogy-2>🧠 Analogy:<a hidden class=anchor aria-hidden=true href=#-analogy-2>#</a></h4><p>Like learning the <em>rules</em> of chess, not how Magnus Carlsen plays.</p><hr><h3 id=--3>🧠 <strong>&ldquo;Modern JavaScript engines heavily optimize the described semantics.&rdquo;</strong><a hidden class=anchor aria-hidden=true href=#--3>#</a></h3><h4 id=-literal-meaning-3>✅ Literal meaning:<a hidden class=anchor aria-hidden=true href=#-literal-meaning-3>#</a></h4><p>Real engines like V8 or SpiderMonkey tweak things under the hood for speed, but they follow the same rules.</p><h4 id=-deeper-understanding-3>🔍 Deeper understanding:<a hidden class=anchor aria-hidden=true href=#-deeper-understanding-3>#</a></h4><p>JS engines may compile JS to bytecode, inline functions, optimize away allocations — but logically, they obey this model.</p><h4 id=-analogy-3>🧠 Analogy:<a hidden class=anchor aria-hidden=true href=#-analogy-3>#</a></h4><p>Like a Formula 1 pit crew following safety rules — they do things super fast, but not incorrectly.</p><hr><h3 id=--4>📖 <strong>&ldquo;This page is a reference. It assumes you are already familiar with the execution model of other programming languages, such as C and Java.&rdquo;</strong><a hidden class=anchor aria-hidden=true href=#--4>#</a></h3><h4 id=-literal-meaning-4>✅ Literal meaning:<a hidden class=anchor aria-hidden=true href=#-literal-meaning-4>#</a></h4><p>If you’ve worked with languages that have stacks, heaps, and memory — this will feel familiar.</p><h4 id=-deeper-understanding-4>🔍 Deeper understanding:<a hidden class=anchor aria-hidden=true href=#-deeper-understanding-4>#</a></h4><p>JS is dynamic and event-driven, but under the hood, it&rsquo;s not that different from C/Java — it just hides more from you.</p><h4 id=-analogy-4>🧠 Analogy:<a hidden class=anchor aria-hidden=true href=#-analogy-4>#</a></h4><p>It’s like someone who’s driven automatic cars learning how a manual transmission works under the hood.</p><hr><h3 id=--5>🔧 <strong>&ldquo;It makes heavy references to existing concepts in operating systems and programming languages.&rdquo;</strong><a hidden class=anchor aria-hidden=true href=#--5>#</a></h3><h4 id=-literal-meaning-5>✅ Literal meaning:<a hidden class=anchor aria-hidden=true href=#-literal-meaning-5>#</a></h4><p>Terms like stack, heap, queue, thread — all come from OS/PL theory.</p><h4 id=-deeper-understanding-5>🔍 Deeper understanding:<a hidden class=anchor aria-hidden=true href=#-deeper-understanding-5>#</a></h4><p>This section connects JS to how <em>all</em> programming languages manage code execution and memory.</p><h4 id=-analogy-5>🧠 Analogy:<a hidden class=anchor aria-hidden=true href=#-analogy-5>#</a></h4><p>It’s like learning JavaScript’s &ldquo;internals&rdquo; by understanding its plumbing — threads, memory, job queues.</p><hr><p>Next section&mldr;</p><hr><h2 id=-the-engine-and-the-host>🔥 <strong>The engine and the host</strong><a hidden class=anchor aria-hidden=true href=#-the-engine-and-the-host>#</a></h2><h3 id=--6>🧩 <strong>&ldquo;JavaScript execution requires the cooperation of two pieces of software: the JavaScript engine and the host environment.&rdquo;</strong><a hidden class=anchor aria-hidden=true href=#--6>#</a></h3><h4 id=-literal-meaning-6>✅ Literal meaning:<a hidden class=anchor aria-hidden=true href=#-literal-meaning-6>#</a></h4><p>JS doesn’t run on its own. It needs:</p><ul><li>A <strong>JS engine</strong> (like V8, SpiderMonkey)</li><li>A <strong>host</strong> (like the browser or Node)</li></ul><h4 id=-deeper-understanding-6>🔍 Deeper understanding:<a hidden class=anchor aria-hidden=true href=#-deeper-understanding-6>#</a></h4><p>The engine knows how to <em>parse</em> and <em>run</em> JavaScript.
The host (browser/Node) knows how to <em>give JS things to do</em> — like making network requests or rendering HTML.</p><h4 id=-analogy-6>🧠 Analogy:<a hidden class=anchor aria-hidden=true href=#-analogy-6>#</a></h4><p>The JS engine is the actor. The host is the stage, props, lighting, and audience.</p><hr><h3 id=--7>🧠 <strong>&ldquo;The JavaScript engine implements the ECMAScript (JavaScript) language, providing the core functionality.&rdquo;</strong><a hidden class=anchor aria-hidden=true href=#--7>#</a></h3><h4 id=-literal-meaning-7>✅ Literal meaning:<a hidden class=anchor aria-hidden=true href=#-literal-meaning-7>#</a></h4><p>The engine knows what <code>let</code>, <code>function</code>, <code>Promise</code>, etc., mean. That’s ECMAScript.</p><h4 id=-deeper-understanding-7>🔍 Deeper understanding:<a hidden class=anchor aria-hidden=true href=#-deeper-understanding-7>#</a></h4><p>Things like <code>setTimeout</code> or <code>document.querySelector</code>? Those are host-provided, not part of the language spec.</p><h4 id=-analogy-7>🧠 Analogy:<a hidden class=anchor aria-hidden=true href=#-analogy-7>#</a></h4><p>The engine knows English. The host gives it a job — like reading a book, or talking to a user.</p><hr><h3 id=--8>🌍 <strong>&ldquo;In order to interact with the outside world [&mldr;] we need additional environment-specific mechanisms provided by the host environment.&rdquo;</strong><a hidden class=anchor aria-hidden=true href=#--8>#</a></h3><h4 id=-literal-meaning-8>✅ Literal meaning:<a hidden class=anchor aria-hidden=true href=#-literal-meaning-8>#</a></h4><p>To talk to files, web APIs, timers, you need help from the host — JS alone can’t do it.</p><h4 id=-deeper-understanding-8>🔍 Deeper understanding:<a hidden class=anchor aria-hidden=true href=#-deeper-understanding-8>#</a></h4><p>This is where browsers give us <code>document</code>, and Node gives us <code>fs</code>, etc. It’s why JS looks different in each environment.</p><h4 id=-analogy-8>🧠 Analogy:<a hidden class=anchor aria-hidden=true href=#-analogy-8>#</a></h4><p>JavaScript is a brilliant chef, but it needs the host to supply groceries, an oven, or even the guests to cook for.</p><hr><h3 id=--9>🌐 <strong>&ldquo;For example, the HTML DOM is the host environment when JavaScript is executed in a web browser. Node.js is another host environment&mldr;&rdquo;</strong><a hidden class=anchor aria-hidden=true href=#--9>#</a></h3><h4 id=-literal-meaning-9>✅ Literal meaning:<a hidden class=anchor aria-hidden=true href=#-literal-meaning-9>#</a></h4><p>DOM and <code>window</code> exist only in the browser. <code>require</code> and <code>process</code> exist only in Node.</p><h4 id=-deeper-understanding-9>🔍 Deeper understanding:<a hidden class=anchor aria-hidden=true href=#-deeper-understanding-9>#</a></h4><p>Same language, different surroundings = different power/tools. JS is <em>host-agnostic</em>; host APIs change.</p><h4 id=-analogy-9>🧠 Analogy:<a hidden class=anchor aria-hidden=true href=#-analogy-9>#</a></h4><p>Same actor, different movie set. A sci-fi set vs. a historical drama set gives the actor different things to interact with.</p><hr><p>Awesome — let&rsquo;s dive into a <strong>line-by-line, recursive breakdown</strong> of the JavaScript Execution Model section. I&rsquo;ll break down each sentence, unpack the underlying concepts, and relate them to real-world analogies and code where helpful.</p><hr><h3 id=javascript-execution-model>🔹<strong>JavaScript execution model</strong><a hidden class=anchor aria-hidden=true href=#javascript-execution-model>#</a></h3><blockquote><p><strong>This page introduces the basic infrastructure of the JavaScript runtime environment.</strong></p></blockquote><ul><li><strong>Breakdown:</strong> We’re about to learn how JavaScript runs &ldquo;under the hood.&rdquo; That means looking beyond syntax into how your code gets executed, managed, and scheduled by the JS engine.</li></ul><blockquote><p><strong>The model is largely theoretical and abstract, without any platform-specific or implementation-specific details.</strong></p></blockquote><ul><li><strong>Breakdown:</strong> This is not about how Chrome, Node, or Deno <em>implement</em> JavaScript — it’s about the ECMAScript <strong>specification-level model</strong>. Think of this as the universal blueprint all JS engines follow.</li></ul><blockquote><p><strong>Modern JavaScript engines heavily optimize the described semantics.</strong></p></blockquote><ul><li><strong>Breakdown:</strong> V8 (Chrome), SpiderMonkey (Firefox), and others add many performance improvements — JIT compilation, inlining, hidden classes — but they <strong>preserve the behavior</strong> defined in this theoretical model.</li></ul><hr><h3 id=this-page-is-a-reference-it-assumes-you-are-already-familiar-with-the-execution-model-of-other-programming-languages-such-as-c-and-java>🔹<strong>This page is a reference. It assumes you are already familiar with the execution model of other programming languages, such as C and Java.</strong><a hidden class=anchor aria-hidden=true href=#this-page-is-a-reference-it-assumes-you-are-already-familiar-with-the-execution-model-of-other-programming-languages-such-as-c-and-java>#</a></h3><ul><li><strong>Breakdown:</strong> It expects you know what a <em>call stack</em>, <em>heap</em>, and <em>execution context</em> are from other languages — but don&rsquo;t worry, we’ll unpack everything from a JavaScript-first view.</li></ul><hr><h3 id=the-engine-and-the-host>🔹<strong>The engine and the host</strong><a hidden class=anchor aria-hidden=true href=#the-engine-and-the-host>#</a></h3><blockquote><p><strong>JavaScript execution requires the cooperation of two pieces of software: the JavaScript engine and the host environment.</strong></p></blockquote><ul><li><strong>Breakdown:</strong><ul><li><strong>Engine</strong> → Understands & runs JS (e.g. V8, SpiderMonkey).</li><li><strong>Host</strong> → Provides APIs <strong>outside</strong> of JS (e.g., the DOM, <code>setTimeout</code>, <code>fs</code> in Node).</li></ul></li></ul><p>📌 Analogy: The engine is the actor, but the host is the stage, props, and audience.</p><hr><blockquote><p><strong>The JavaScript engine implements the ECMAScript (JavaScript) language, providing the core functionality. It takes source code, parses it, and executes it.</strong></p></blockquote><ul><li><strong>Breakdown:</strong><ol><li><strong>Parses</strong> → Converts your code into an Abstract Syntax Tree (AST).</li><li><strong>Executes</strong> → Evaluates it via interpreters or compilers.</li></ol></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>let</span> <span class=nx>x</span> <span class=o>=</span> <span class=mi>5</span><span class=p>;</span>
</span></span></code></pre></div><ul><li>Engine knows how to parse and execute this, but not how to access the DOM. That’s the host&rsquo;s job.</li></ul><hr><blockquote><p><strong>However, in order to interact with the outside world, such as to produce any meaningful output, to interface with external resources, or to implement security- or performance-related mechanisms, we need additional environment-specific mechanisms provided by the host environment.</strong></p></blockquote><ul><li><strong>Breakdown:</strong> Engine alone can’t do I/O, networking, file access. Host provides:<ul><li><code>console.log</code>, <code>fetch</code>, <code>setTimeout</code>, <code>document</code>, <code>process.env</code>, etc.</li></ul></li></ul><hr><blockquote><p><strong>For example, the HTML DOM is the host environment when JavaScript is executed in a web browser. Node.js is another host environment that allows JavaScript to be run on the server side.</strong></p></blockquote><ul><li><strong>Breakdown:</strong><ul><li>Browser = JS engine + DOM + <code>window</code> + events.</li><li>Node = JS engine + <code>fs</code>, <code>http</code>, <code>Buffer</code>, <code>process</code>, etc.</li></ul></li></ul><hr><blockquote><p><strong>While we focus primarily on the mechanisms defined in ECMAScript in this reference, we will occasionally talk about mechanisms defined in the HTML spec, which is often mimicked by other host environments like Node.js or Deno.</strong></p></blockquote><ul><li><strong>Breakdown:</strong><ul><li>Core focus = ECMAScript (language spec).</li><li>But we&rsquo;ll touch on HTML-defined behaviors (like the Event Loop, microtasks) — because Node/Deno borrow them too.</li></ul></li></ul><hr><h3 id=agent-execution-model>🔹<strong>Agent Execution Model</strong><a hidden class=anchor aria-hidden=true href=#agent-execution-model>#</a></h3><blockquote><p><strong>In the JavaScript specification, each autonomous executor of JavaScript is called an agent, which maintains its facilities for code execution:</strong></p></blockquote><ul><li><strong>Breakdown:</strong><ul><li>Think of an <strong>agent</strong> as an independent &ldquo;runner&rdquo; of JavaScript — like a tab, worker, or Node thread.</li><li>Each agent has its own <strong>heap</strong>, <strong>call stack</strong>, and <strong>job queue</strong>.</li></ul></li></ul><hr><p>Now, let’s recursively unpack the <strong>three components</strong> of an agent:</p><hr><h4 id=-heap-of-objects>🔸 <strong>Heap (of objects)</strong><a hidden class=anchor aria-hidden=true href=#-heap-of-objects>#</a></h4><blockquote><p><strong>This is just a name to denote a large (mostly unstructured) region of memory. It gets populated as objects get created in the program.</strong></p></blockquote><ul><li><strong>Breakdown:</strong><ul><li>Heap = where <strong>reference types</strong> live: objects, arrays, closures, functions.</li><li>Variables like <code>let obj = {}</code> create entries in the heap.</li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>let</span> <span class=nx>obj</span> <span class=o>=</span> <span class=p>{</span> <span class=nx>name</span><span class=o>:</span> <span class=s2>&#34;you&#34;</span> <span class=p>};</span>
</span></span></code></pre></div><p>The object lives in the heap; <code>obj</code> points to it.</p><hr><blockquote><p><strong>Note that in the case of shared memory, each agent has its own heap with its own version of a SharedArrayBuffer object, but the underlying memory represented by the buffer is shared.</strong></p></blockquote><ul><li><strong>Breakdown:</strong><ul><li>Each worker/tab has its own isolated heap — but <strong>shared memory</strong> (via <code>SharedArrayBuffer</code>) creates <strong>cross-agent bridges</strong>.</li><li>Shared memory enables atomic operations between agents.</li></ul></li></ul><p>📌 Think: <em>Multiple agents → own memory → but one shared space for coordination</em>.</p><hr><h4 id=-queue-of-jobs>🔸 <strong>Queue (of jobs)</strong><a hidden class=anchor aria-hidden=true href=#-queue-of-jobs>#</a></h4><blockquote><p><strong>This is known in HTML (and also commonly) as the event loop which enables asynchronous programming in JavaScript while being single-threaded.</strong></p></blockquote><ul><li><strong>Breakdown:</strong><ul><li>Queue = <strong>Job Queue / Task Queue</strong>.</li><li>Works with the <strong>event loop</strong> to schedule <strong>async tasks</strong> (like <code>setTimeout</code>, Promises).</li></ul></li></ul><hr><blockquote><p><strong>It&rsquo;s called a queue because it&rsquo;s generally first-in-first-out: earlier jobs are executed before later ones.</strong></p></blockquote><ul><li><strong>Breakdown:</strong><ul><li>Classic <strong>FIFO</strong> structure.</li><li>Tasks are queued and <strong>executed one by one</strong>, preserving order.</li></ul></li></ul><hr><h4 id=-stack-of-execution-contexts>🔸 <strong>Stack (of execution contexts)</strong><a hidden class=anchor aria-hidden=true href=#-stack-of-execution-contexts>#</a></h4><blockquote><p><strong>This is what&rsquo;s known as a call stack and allows transferring control flow by entering and exiting execution contexts like functions.</strong></p></blockquote><ul><li><strong>Breakdown:</strong><ul><li>Stack = execution history — functions being called and exited.</li><li>LIFO — last-in, first-out.</li></ul></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>a</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>b</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>b</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>c</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>a</span><span class=p>();</span> <span class=c1>// a → b → c → return → return → return
</span></span></span></code></pre></div><hr><blockquote><p><strong>It&rsquo;s called a stack because it&rsquo;s last-in-first-out. Every job enters by pushing a new frame onto the (empty) stack, and exits by emptying the stack.</strong></p></blockquote><ul><li><strong>Breakdown:</strong><ul><li>A function call pushes a <strong>frame</strong> onto the stack.</li><li>When it returns, the frame is popped off.</li></ul></li></ul><hr><blockquote><p><strong>These are three distinct data structures that keep track of different data.</strong></p></blockquote><ul><li><strong>Heap</strong> → Long-lived objects.</li><li><strong>Queue</strong> → Pending jobs (like <code>fetch().then()</code>).</li><li><strong>Stack</strong> → Current execution chain (call stack).</li></ul><hr><blockquote><p><strong>We will introduce the queue and the stack in more detail in the following sections. To read more about how heap memory is allocated and freed, see memory management.</strong></p></blockquote><ul><li><strong>Breakdown:</strong><ul><li>Stack and queue will be our main focus because they control <strong>how code runs</strong>.</li><li>Heap is for <strong>storage</strong>, not <strong>flow</strong>.</li></ul></li></ul><hr><h3 id=-up-next>🧠 Up Next:<a hidden class=anchor aria-hidden=true href=#-up-next>#</a></h3><p>We’ll dive into the next section — <strong>realms</strong>, agents on the web (workers, windows), and how these fit together using the diagram you shared.</p><p>Want to continue into that next?</p><p>Awesome — let’s go <em>line by line</em>, <em>step by step</em>, <em>recursively breaking down</em> every idea here. I&rsquo;ll unpack it intuitively, back it up with examples, and link it to real-world behavior.</p><hr><h2 id=-line-1>🔹 Line 1:<a hidden class=anchor aria-hidden=true href=#-line-1>#</a></h2><blockquote><p><strong>&ldquo;These are three distinct data structures that keep track of different data.&rdquo;</strong></p></blockquote><h3 id=-intuition>🧠 Intuition:<a hidden class=anchor aria-hidden=true href=#-intuition>#</a></h3><p>In the agent model, three “buckets” manage different responsibilities:</p><table><thead><tr><th>Structure</th><th>Purpose</th><th>Example</th></tr></thead><tbody><tr><td><strong>Heap</strong></td><td>Stores all dynamic data (objects, functions)</td><td><code>{name: "John"}</code> or an array <code>[1,2,3]</code> lives here</td></tr><tr><td><strong>Queue</strong></td><td>List of &ldquo;jobs&rdquo; waiting to run (asynchronous tasks)</td><td><code>setTimeout(() => {}, 1000)</code> gets added to queue</td></tr><tr><td><strong>Stack</strong></td><td>Keeps track of what function is running right now</td><td>When calling functions, stack tracks &ldquo;who called who&rdquo;</td></tr></tbody></table><h3 id=-real-world-analogy>🎯 Real-World Analogy:<a hidden class=anchor aria-hidden=true href=#-real-world-analogy>#</a></h3><ul><li><strong>Heap</strong> = Warehouse of data</li><li><strong>Stack</strong> = A to-do list that follows <em>last in, first out</em> — newest task gets done first</li><li><strong>Queue</strong> = A waiting room — <em>first in, first out</em> — oldest task gets picked up first</li></ul><hr><h2 id=-line-2>🔹 Line 2:<a hidden class=anchor aria-hidden=true href=#-line-2>#</a></h2><blockquote><p><strong>&ldquo;We will introduce the queue and the stack in more detail in the following sections.&rdquo;</strong></p></blockquote><h3 id=-intuition-1>🧠 Intuition:<a hidden class=anchor aria-hidden=true href=#-intuition-1>#</a></h3><ul><li>They’re setting you up: <em>heap</em> is mostly a memory detail (not directly manipulated much), but <em>queue</em> and <em>stack</em> are <strong>critical</strong> to how JavaScript behaves, especially:<ul><li>Why async code works</li><li>Why <code>console.log</code> runs before a <code>setTimeout</code></li><li>Why promises feel synchronous sometimes</li></ul></li></ul><p>You&rsquo;ll learn:</p><ul><li>Stack: Why recursion fails with “maximum call stack size exceeded”</li><li>Queue: Why this logs in order:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;A&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;B&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;C&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=c1>// Output: A C B
</span></span></span></code></pre></div><hr><h2 id=-line-3>🔹 Line 3:<a hidden class=anchor aria-hidden=true href=#-line-3>#</a></h2><blockquote><p><strong>&ldquo;To read more about how heap memory is allocated and freed, see memory management.&rdquo;</strong></p></blockquote><h3 id=-intuition-2>🧠 Intuition:<a hidden class=anchor aria-hidden=true href=#-intuition-2>#</a></h3><p>The <strong>heap</strong> is where all your objects live — and they stick around as long as something <em>references</em> them.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>let</span> <span class=nx>x</span> <span class=o>=</span> <span class=p>{</span> <span class=nx>name</span><span class=o>:</span> <span class=s2>&#34;Alice&#34;</span> <span class=p>};</span> <span class=c1>// stored in the heap
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>x</span> <span class=o>=</span> <span class=kc>null</span><span class=p>;</span> <span class=c1>// garbage collected (freed from heap eventually)
</span></span></span></code></pre></div><p>No manual memory management in JS. The garbage collector watches references.</p><hr><h2 id=-line-4>🔹 Line 4:<a hidden class=anchor aria-hidden=true href=#-line-4>#</a></h2><blockquote><p><strong>&ldquo;Each agent is analogous to a thread (note that the underlying implementation may or may not be an actual operating system thread).&rdquo;</strong></p></blockquote><h3 id=-key-concept-agent--thread>🧠 Key Concept: <strong>Agent ≈ Thread</strong><a hidden class=anchor aria-hidden=true href=#-key-concept-agent--thread>#</a></h3><p>But not exactly.</p><ul><li><strong>JavaScript itself is single-threaded</strong> — only <em>one agent</em> running main code.</li><li>But environments (like browsers or Node.js) <em>spawn multiple agents</em> (like Web Workers).</li></ul><p>🔍 Important: <em>Just because JavaScript feels single-threaded doesn&rsquo;t mean there&rsquo;s only one thread underneath.</em></p><blockquote><p>Example: If you use a <strong>Web Worker</strong>, that code runs in its own agent, with its <strong>own heap, queue, and stack</strong>.</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// main.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>worker</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Worker</span><span class=p>(</span><span class=s2>&#34;worker.js&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// worker.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>onmessage</span> <span class=o>=</span> <span class=p>(</span><span class=nx>e</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=c1>// This is a separate agent!
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=nx>postMessage</span><span class=p>(</span><span class=s2>&#34;Got it&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><hr><h2 id=-line-5>🔹 Line 5:<a hidden class=anchor aria-hidden=true href=#-line-5>#</a></h2><blockquote><p><strong>&ldquo;Each agent can own multiple realms (which 1-to-1 correlate with global objects) that can synchronously access each other, and thus needs to run in a single execution thread.&rdquo;</strong></p></blockquote><h3 id=-intuition-3>🧠 Intuition:<a hidden class=anchor aria-hidden=true href=#-intuition-3>#</a></h3><ul><li>A <strong>realm</strong> is like a <strong>sandboxed environment</strong>: it has its own <code>globalThis</code>, <code>Array</code>, <code>Function</code>, etc.</li><li>Inside one agent, multiple realms can talk to each other <strong>synchronously</strong> (because they share the same stack/queue).</li></ul><p>📦 Real-world example:</p><ul><li>In a browser, your main page and a <strong>same-origin iframe</strong> are in the same agent, but <strong>different realms</strong>.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>iframe</span> <span class=na>src</span><span class=o>=</span><span class=s>&#34;same-origin.html&#34;</span><span class=p>&gt;&lt;/</span><span class=nt>iframe</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Inside both:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nb>window</span><span class=p>.</span><span class=nb>Array</span> <span class=o>===</span> <span class=nx>iframe</span><span class=p>.</span><span class=nx>contentWindow</span><span class=p>.</span><span class=nb>Array</span><span class=p>);</span> <span class=c1>// ❌ false
</span></span></span></code></pre></div><p>Why? Different realms, different versions of built-in objects like <code>Array</code>.</p><hr><h2 id=-line-6>🔹 Line 6:<a hidden class=anchor aria-hidden=true href=#-line-6>#</a></h2><blockquote><p><strong>&ldquo;An agent also has a single memory model, indicating whether it&rsquo;s little-endian, whether it can be synchronously blocked, whether atomic operations are lock-free, etc.&rdquo;</strong></p></blockquote><h3 id=-what-this-means>🧠 What this means:<a hidden class=anchor aria-hidden=true href=#-what-this-means>#</a></h3><p>This dives into <strong>low-level behavior</strong>, useful when you’re dealing with <strong>shared memory</strong> (e.g., <code>SharedArrayBuffer</code>) and <strong>concurrency</strong>.</p><ul><li><strong>Little-endian</strong>: Byte ordering in memory (most systems are little-endian).</li><li><strong>Lock-free atomic operations</strong>: Allows agents to coordinate via memory safely.</li><li><strong>Synchronous blocking</strong>: Whether one agent can halt another (usually avoided in JS for responsiveness).</li></ul><p>🛠 You’ll care about this if you&rsquo;re:</p><ul><li>Using <code>Atomics.wait</code> / <code>Atomics.notify</code></li><li>Coordinating workers via shared memory</li><li>Doing real-time or performance-critical code</li></ul><hr><h2 id=-summary-table>✅ Summary Table<a hidden class=anchor aria-hidden=true href=#-summary-table>#</a></h2><table><thead><tr><th>Concept</th><th>What It Does</th><th>Practical Example</th></tr></thead><tbody><tr><td>Heap</td><td>Stores all objects</td><td><code>{ user: "A" }</code></td></tr><tr><td>Stack</td><td>Tracks function calls</td><td><code>foo()</code> calls <code>bar()</code></td></tr><tr><td>Queue</td><td>Holds async jobs</td><td><code>setTimeout()</code>, <code>Promise.then()</code></td></tr><tr><td>Agent</td><td>Self-contained executor (heap+stack+queue)</td><td>Main thread or Worker</td></tr><tr><td>Realm</td><td>Global environment inside an agent</td><td>Main page vs iframe</td></tr><tr><td>Memory Model</td><td>Rules for memory access</td><td><code>SharedArrayBuffer</code>, <code>Atomics</code></td></tr></tbody></table><hr><h3 id=-want-to-go-deeper-into-one-of-these-now>🔥 Want to go deeper into one of these now?<a hidden class=anchor aria-hidden=true href=#-want-to-go-deeper-into-one-of-these-now>#</a></h3><p>I can:</p><ul><li>Visualize how a realm compares to an agent</li><li>Show a step-by-step simulation of the stack and queue</li><li>Break down how two agents use shared memory safely</li></ul><p>Let me know your next target — I’m ready to go recursive on it.</p><p>Great! Let&rsquo;s continue the <strong>recursive breakdown</strong> from where we left off. We just finished:</p><blockquote><p>&ldquo;An agent also has a single memory model, indicating whether it&rsquo;s little-endian, whether it can be synchronously blocked, whether atomic operations are lock-free, etc.&rdquo;</p></blockquote><p>Now, the next part of the MDN doc says:</p><hr><h2 id=-next-block>📌 Next block:<a hidden class=anchor aria-hidden=true href=#-next-block>#</a></h2><blockquote><h3 id=an-agent-on-the-web-can-be-one-of-the-following>“An agent on the web can be one of the following:<a hidden class=anchor aria-hidden=true href=#an-agent-on-the-web-can-be-one-of-the-following>#</a></h3><ul><li>A Similar-origin window agent, which contains various Window objects which can potentially reach each other, either directly or by using <code>document.domain</code>. If the window is origin-keyed, then only same-origin windows can reach each other.</li><li>A Dedicated worker agent containing a single <code>DedicatedWorkerGlobalScope</code>.</li><li>A Shared worker agent containing a single <code>SharedWorkerGlobalScope</code>.</li><li>A Service worker agent containing a single <code>ServiceWorkerGlobalScope</code>.</li><li>A Worklet agent containing a single <code>WorkletGlobalScope</code>.”</li></ul></blockquote><hr><h3 id=-lets-go-line-by-line-and-recursively-break-this-down>✅ Let&rsquo;s go <strong>line-by-line and recursively break this down</strong>:<a hidden class=anchor aria-hidden=true href=#-lets-go-line-by-line-and-recursively-break-this-down>#</a></h3><hr><h3 id=-line-1-1>🔹 Line 1:<a hidden class=anchor aria-hidden=true href=#-line-1-1>#</a></h3><blockquote><p><strong>&ldquo;An agent on the web can be one of the following:&rdquo;</strong></p></blockquote><p>🧠 <strong>Big idea</strong>: On the web, <strong>each type of “execution environment”</strong> (like a browser tab, a worker, etc.) is backed by its own <strong>agent</strong> — meaning it has its own <strong>heap</strong>, <strong>stack</strong>, and <strong>queue</strong>.</p><blockquote><p>Think of each agent as its own little JS runtime.</p></blockquote><hr><h3 id=-line-2-1>🔹 Line 2:<a hidden class=anchor aria-hidden=true href=#-line-2-1>#</a></h3><blockquote><p><strong>&ldquo;A Similar-origin window agent, which contains various Window objects which can potentially reach each other, either directly or by using <code>document.domain</code>. If the window is origin-keyed, then only same-origin windows can reach each other.&rdquo;</strong></p></blockquote><h3 id=-whats-going-on-here>🧠 What&rsquo;s going on here?<a hidden class=anchor aria-hidden=true href=#-whats-going-on-here>#</a></h3><p>A <strong>window agent</strong> = Your main page + all <strong>same-origin iframes</strong> you embed in it.</p><h4 id=-shared-agent-example>🔄 Shared Agent Example:<a hidden class=anchor aria-hidden=true href=#-shared-agent-example>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl><span class=c>&lt;!-- index.html --&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>iframe</span> <span class=na>src</span><span class=o>=</span><span class=s>&#34;https://yourdomain.com/page.html&#34;</span><span class=p>&gt;&lt;/</span><span class=nt>iframe</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>These two can <strong>share memory and synchronously access each other</strong>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// From parent page
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nb>window</span><span class=p>.</span><span class=nx>frames</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=nb>document</span><span class=p>.</span><span class=nx>body</span><span class=p>);</span>
</span></span></code></pre></div><p>🧪 But if the iframe is cross-origin, access is blocked for security.</p><h4 id=-security-twist>⚠️ Security twist:<a hidden class=anchor aria-hidden=true href=#-security-twist>#</a></h4><p>If <code>document.domain</code> is set (deprecated but still used), two <strong>subdomains</strong> can loosen the restriction a bit.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// both pages set
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>document</span><span class=p>.</span><span class=nx>domain</span> <span class=o>=</span> <span class=s2>&#34;example.com&#34;</span><span class=p>;</span>
</span></span></code></pre></div><p>Then they can reach each other, even if one is <code>a.example.com</code> and one is <code>b.example.com</code>.</p><hr><h3 id=-line-3-1>🔹 Line 3:<a hidden class=anchor aria-hidden=true href=#-line-3-1>#</a></h3><blockquote><p><strong>&ldquo;A Dedicated worker agent containing a single <code>DedicatedWorkerGlobalScope</code>.&rdquo;</strong></p></blockquote><h3 id=-what-is-a-dedicated-worker-agent>🧠 What is a <strong>Dedicated Worker Agent</strong>?<a hidden class=anchor aria-hidden=true href=#-what-is-a-dedicated-worker-agent>#</a></h3><p>When you create a <strong>Web Worker</strong> in the browser:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>worker</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Worker</span><span class=p>(</span><span class=s2>&#34;worker.js&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>That script (<code>worker.js</code>) runs in its own <strong>dedicated worker agent</strong> — with its <strong>own heap, queue, and stack</strong> — completely separate from the main thread.</p><p>🔁 Communication is done <strong>asynchronously</strong> via <code>postMessage()</code> — like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// main.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>worker</span><span class=p>.</span><span class=nx>postMessage</span><span class=p>(</span><span class=s2>&#34;hi&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// worker.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>onmessage</span> <span class=o>=</span> <span class=p>(</span><span class=nx>e</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Got:&#34;</span><span class=p>,</span> <span class=nx>e</span><span class=p>.</span><span class=nx>data</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><blockquote><p>⚠️ You <strong>cannot</strong> synchronously access memory between main thread and a dedicated worker (unless using <code>SharedArrayBuffer</code>).</p></blockquote><hr><h3 id=-line-4-1>🔹 Line 4:<a hidden class=anchor aria-hidden=true href=#-line-4-1>#</a></h3><blockquote><p><strong>&ldquo;A Shared worker agent containing a single <code>SharedWorkerGlobalScope</code>.&rdquo;</strong></p></blockquote><h3 id=-difference-between-shared-worker-and-dedicated-worker>🧠 Difference between <strong>Shared Worker</strong> and <strong>Dedicated Worker</strong>?<a hidden class=anchor aria-hidden=true href=#-difference-between-shared-worker-and-dedicated-worker>#</a></h3><ul><li><strong>Dedicated Worker</strong>: Only 1 page can talk to it.</li><li><strong>Shared Worker</strong>: Multiple tabs (from the same origin) can talk to the same worker.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// In two tabs of the same site:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>sharedWorker</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>SharedWorker</span><span class=p>(</span><span class=s2>&#34;worker.js&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>Now both tabs talk to the same long-living agent!</p><p>Why use this?</p><ul><li>Share data between tabs</li><li>Maintain a centralized cache</li><li>Reduce memory usage</li></ul><p>📦 But again — it&rsquo;s <strong>a separate agent</strong> with <strong>its own stack/heap/queue</strong>.</p><hr><h3 id=-line-5-1>🔹 Line 5:<a hidden class=anchor aria-hidden=true href=#-line-5-1>#</a></h3><blockquote><p><strong>&ldquo;A Service worker agent containing a single <code>ServiceWorkerGlobalScope</code>.&rdquo;</strong></p></blockquote><h3 id=-whats-special-about-service-workers>🧠 What’s special about <strong>Service Workers</strong>?<a hidden class=anchor aria-hidden=true href=#-whats-special-about-service-workers>#</a></h3><ul><li>They’re <strong>background scripts</strong> that sit between your site and the network.</li><li>Intercept requests (<code>fetch</code>), cache stuff, serve offline pages.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// Registering a service worker
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>navigator</span><span class=p>.</span><span class=nx>serviceWorker</span><span class=p>.</span><span class=nx>register</span><span class=p>(</span><span class=s2>&#34;sw.js&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>🧠 They:</p><ul><li>Outlive pages</li><li>Don’t have access to DOM</li><li>Run in <strong>their own agent</strong></li></ul><p>💡 Use case:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>self</span><span class=p>.</span><span class=nx>addEventListener</span><span class=p>(</span><span class=s2>&#34;fetch&#34;</span><span class=p>,</span> <span class=p>(</span><span class=nx>event</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>event</span><span class=p>.</span><span class=nx>respondWith</span><span class=p>(</span><span class=nx>caches</span><span class=p>.</span><span class=nx>match</span><span class=p>(</span><span class=nx>event</span><span class=p>.</span><span class=nx>request</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></div><p>Service workers have a <strong>completely isolated memory space</strong> and no direct access to the DOM.</p><hr><h3 id=-line-6-1>🔹 Line 6:<a hidden class=anchor aria-hidden=true href=#-line-6-1>#</a></h3><blockquote><p><strong>&ldquo;A Worklet agent containing a single <code>WorkletGlobalScope</code>.&rdquo;</strong></p></blockquote><h3 id=-whats-a-worklet>🧠 What’s a <strong>Worklet</strong>?<a hidden class=anchor aria-hidden=true href=#-whats-a-worklet>#</a></h3><p>Advanced topic — used for things like:</p><ul><li><strong>CSS Paint API</strong></li><li><strong>Web Audio API (AudioWorklet)</strong></li><li><strong>Animations</strong></li></ul><p>🔊 Example: An <code>AudioWorklet</code> lets you do <strong>low-latency audio processing</strong> on a separate thread (agent).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// In main thread
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>audioContext</span><span class=p>.</span><span class=nx>audioWorklet</span><span class=p>.</span><span class=nx>addModule</span><span class=p>(</span><span class=s2>&#34;processor.js&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// processor.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>class</span> <span class=nx>MyProcessor</span> <span class=kr>extends</span> <span class=nx>AudioWorkletProcessor</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>process</span><span class=p>(</span><span class=nx>inputs</span><span class=p>,</span> <span class=nx>outputs</span><span class=p>,</span> <span class=nx>parameters</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// run audio processing
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>registerProcessor</span><span class=p>(</span><span class=s2>&#34;my-processor&#34;</span><span class=p>,</span> <span class=nx>MyProcessor</span><span class=p>);</span>
</span></span></code></pre></div><p>These agents are <strong>super-lightweight</strong>, meant for <strong>tiny, focused jobs</strong> like drawing or audio frames.</p><hr><h2 id=-summary>🧠 Summary:<a hidden class=anchor aria-hidden=true href=#-summary>#</a></h2><table><thead><tr><th>Agent Type</th><th>Runs in</th><th>Has Own Stack/Heap/Queue?</th><th>Use Case</th></tr></thead><tbody><tr><td>Similar-origin Window Agent</td><td>Main page + iframes (same origin)</td><td>✅ Yes</td><td>Regular DOM pages</td></tr><tr><td>Dedicated Worker Agent</td><td>Worker created via <code>new Worker()</code></td><td>✅ Yes</td><td>Offload CPU-intensive tasks</td></tr><tr><td>Shared Worker Agent</td><td>Shared among multiple tabs</td><td>✅ Yes</td><td>Tab-to-tab communication</td></tr><tr><td>Service Worker Agent</td><td>Background fetch/caching logic</td><td>✅ Yes</td><td>Offline apps, PWA</td></tr><tr><td>Worklet Agent</td><td>Lightweight visual/audio tasks</td><td>✅ Yes</td><td>Audio, CSS, animations</td></tr></tbody></table><hr><p>You want to continue to the <strong>next part</strong> after this? It’s:</p><blockquote><p><strong>“In other words, each worker creates its own agent, while one or more windows may be within the same agent—usually a main document and its similar-origin iframes…”</strong></p></blockquote><p>Just say the word and we’ll keep recursively breaking it down with visuals and mental models.</p><p>Perfect! Let’s do a <strong>recursive breakdown</strong> of this next section, <strong>line by line</strong>, with <strong>intuitive mental models, visuals-in-your-head, and real-world JavaScript usage</strong>.</p><hr><h2 id=-big-context>🧠 Big Context:<a hidden class=anchor aria-hidden=true href=#-big-context>#</a></h2><p>You just learned that <strong>each agent is like an isolated JavaScript runtime</strong>: it has its own heap, call stack, and job queue.</p><p>Now you&rsquo;re learning:</p><blockquote><p>🔍 <strong>&ldquo;What are the different types of agents on the web?&rdquo;</strong></p></blockquote><p>Let’s go <strong>line by line</strong>:</p><hr><h3 id=-1-an-agent-on-the-web-can-be-one-of-the-following>🔹 1. “An agent on the web can be one of the following:”<a hidden class=anchor aria-hidden=true href=#-1-an-agent-on-the-web-can-be-one-of-the-following>#</a></h3><p>✅ <strong>Translation</strong>:<br>On the web, there are several &ldquo;execution environments&rdquo; where JavaScript can run.<br>Each is backed by a <strong>separate agent</strong>, i.e., its own isolated execution infrastructure.</p><hr><h2 id=-now-we-explore-each-type>🧩 Now we explore each type:<a hidden class=anchor aria-hidden=true href=#-now-we-explore-each-type>#</a></h2><hr><h3 id=-2-a-similar-origin-window-agent-which-contains-various-window-objects-which-can-potentially-reach-each-other-either-directly-or-by-using-documentdomain-if-the-window-is-origin-keyed-then-only-same-origin-windows-can-reach-each-other>🔹 2. “A Similar-origin window agent, which contains various Window objects which can potentially reach each other, either directly or by using <code>document.domain</code>. If the window is origin-keyed, then only same-origin windows can reach each other.”<a hidden class=anchor aria-hidden=true href=#-2-a-similar-origin-window-agent-which-contains-various-window-objects-which-can-potentially-reach-each-other-either-directly-or-by-using-documentdomain-if-the-window-is-origin-keyed-then-only-same-origin-windows-can-reach-each-other>#</a></h3><h3 id=-what-this-means-1>🧠 What this means:<a hidden class=anchor aria-hidden=true href=#-what-this-means-1>#</a></h3><ul><li>This is your <strong>main webpage</strong>, plus any <strong>iframes</strong> inside it that share the same origin (protocol + host + port).</li><li>These &ldquo;windows&rdquo; share the same <strong>agent</strong>, and can <strong>talk to each other synchronously</strong>.</li></ul><h4 id=-real-world-example>🧪 Real-World Example:<a hidden class=anchor aria-hidden=true href=#-real-world-example>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl><span class=c>&lt;!-- index.html --&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>iframe</span> <span class=na>src</span><span class=o>=</span><span class=s>&#34;https://yourdomain.com/page.html&#34;</span><span class=p>&gt;&lt;/</span><span class=nt>iframe</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>You can do this from the parent:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>iframeDoc</span> <span class=o>=</span> <span class=nb>window</span><span class=p>.</span><span class=nx>frames</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=nb>document</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>iframeDoc</span><span class=p>.</span><span class=nx>title</span><span class=p>);</span> <span class=c1>// works if same origin
</span></span></span></code></pre></div><blockquote><p>⚠️ If they&rsquo;re <strong>cross-origin</strong>, that line throws a security error (unless both set <code>document.domain</code>).</p></blockquote><h4 id=-what-is-documentdomain>📌 What is <code>document.domain</code>?<a hidden class=anchor aria-hidden=true href=#-what-is-documentdomain>#</a></h4><p>A deprecated way to let subdomains trust each other:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// a.example.com and b.example.com both set:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>document</span><span class=p>.</span><span class=nx>domain</span> <span class=o>=</span> <span class=s2>&#34;example.com&#34;</span><span class=p>;</span> 
</span></span></code></pre></div><p>→ Now they can talk synchronously.</p><hr><h3 id=-3-a-dedicated-worker-agent-containing-a-single-dedicatedworkerglobalscope>🔹 3. “A Dedicated worker agent containing a single <code>DedicatedWorkerGlobalScope</code>.”<a hidden class=anchor aria-hidden=true href=#-3-a-dedicated-worker-agent-containing-a-single-dedicatedworkerglobalscope>#</a></h3><h3 id=-what-this-means-2>🧠 What this means:<a hidden class=anchor aria-hidden=true href=#-what-this-means-2>#</a></h3><p>When you use a <strong>Web Worker</strong>, like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>worker</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Worker</span><span class=p>(</span><span class=s2>&#34;worker.js&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>You’re spinning up a <strong>new agent</strong> behind the scenes.<br>That agent has:</p><ul><li>Its own <strong>heap</strong></li><li>Its own <strong>stack</strong></li><li>Its own <strong>event queue</strong></li></ul><p>It runs <code>worker.js</code> in isolation.</p><h4 id=-real-world-use-case>💡 Real-World Use Case:<a hidden class=anchor aria-hidden=true href=#-real-world-use-case>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// main.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>worker</span><span class=p>.</span><span class=nx>postMessage</span><span class=p>({</span> <span class=nx>task</span><span class=o>:</span> <span class=s2>&#34;fibonacci&#34;</span><span class=p>,</span> <span class=nx>n</span><span class=o>:</span> <span class=mi>40</span> <span class=p>});</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// worker.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>onmessage</span> <span class=o>=</span> <span class=p>(</span><span class=nx>e</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>result</span> <span class=o>=</span> <span class=nx>doHeavyFibonacci</span><span class=p>(</span><span class=nx>e</span><span class=p>.</span><span class=nx>data</span><span class=p>.</span><span class=nx>n</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=nx>postMessage</span><span class=p>(</span><span class=nx>result</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>→ This keeps your UI thread <strong>smooth and responsive</strong> while the heavy calculation runs in another <strong>agent</strong> (aka thread-like sandbox).</p><hr><h3 id=-4-a-shared-worker-agent-containing-a-single-sharedworkerglobalscope>🔹 4. “A Shared worker agent containing a single <code>SharedWorkerGlobalScope</code>.”<a hidden class=anchor aria-hidden=true href=#-4-a-shared-worker-agent-containing-a-single-sharedworkerglobalscope>#</a></h3><h3 id=-meaning>🧠 Meaning:<a hidden class=anchor aria-hidden=true href=#-meaning>#</a></h3><p>Unlike a dedicated worker, a <strong>SharedWorker</strong> is <strong>shared across multiple tabs</strong>.</p><p>You create it like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>sharedWorker</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>SharedWorker</span><span class=p>(</span><span class=s2>&#34;worker.js&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>This launches an <strong>agent that lives beyond a single page</strong>, shared between tabs of the same origin.</p><h4 id=-use-case>📌 Use case:<a hidden class=anchor aria-hidden=true href=#-use-case>#</a></h4><p>You&rsquo;re building a <strong>real-time dashboard</strong> with multiple tabs.<br>You want all tabs to share a single:</p><ul><li>WebSocket connection</li><li>Cache</li><li>State</li></ul><p>The <strong>shared worker agent</strong> holds that logic, and all tabs send messages to it.</p><hr><h3 id=-5-a-service-worker-agent-containing-a-single-serviceworkerglobalscope>🔹 5. “A Service worker agent containing a single <code>ServiceWorkerGlobalScope</code>.”<a hidden class=anchor aria-hidden=true href=#-5-a-service-worker-agent-containing-a-single-serviceworkerglobalscope>#</a></h3><h3 id=-meaning-1>🧠 Meaning:<a hidden class=anchor aria-hidden=true href=#-meaning-1>#</a></h3><p>Service workers are special. They&rsquo;re not tied to a tab.<br>They sit in the background and intercept network requests.</p><p>You register one like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>navigator</span><span class=p>.</span><span class=nx>serviceWorker</span><span class=p>.</span><span class=nx>register</span><span class=p>(</span><span class=s2>&#34;/sw.js&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>The <code>sw.js</code> file runs in its own <strong>agent</strong> with:</p><ul><li>No DOM access</li><li>Its own global scope (<code>ServiceWorkerGlobalScope</code>)</li><li>A lifetime independent from your pages</li></ul><h4 id=-use-case-1>📌 Use case:<a hidden class=anchor aria-hidden=true href=#-use-case-1>#</a></h4><ul><li>Offline support</li><li>Background sync</li><li>Push notifications</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// sw.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>self</span><span class=p>.</span><span class=nx>addEventListener</span><span class=p>(</span><span class=s2>&#34;fetch&#34;</span><span class=p>,</span> <span class=p>(</span><span class=nx>event</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>event</span><span class=p>.</span><span class=nx>respondWith</span><span class=p>(</span><span class=nx>caches</span><span class=p>.</span><span class=nx>match</span><span class=p>(</span><span class=nx>event</span><span class=p>.</span><span class=nx>request</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></div><p>This runs in a <strong>background agent</strong> even when no tabs are open.</p><hr><h3 id=-6-a-worklet-agent-containing-a-single-workletglobalscope>🔹 6. “A Worklet agent containing a single <code>WorkletGlobalScope</code>.”<a hidden class=anchor aria-hidden=true href=#-6-a-worklet-agent-containing-a-single-workletglobalscope>#</a></h3><h3 id=-what-is-a-worklet>🧠 What is a <strong>Worklet</strong>?<a hidden class=anchor aria-hidden=true href=#-what-is-a-worklet>#</a></h3><p>Worklets are tiny, low-latency JS programs.<br>They&rsquo;re used for <strong>audio processing</strong>, <strong>custom painting</strong>, etc.</p><p>They are <strong>isolated agents</strong> that are super-performant, meant for <strong>frame-by-frame rendering</strong> or <strong>DSP (digital signal processing)</strong>.</p><h4 id=-use-case-2>🧪 Use Case:<a hidden class=anchor aria-hidden=true href=#-use-case-2>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// AudioWorklet
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>audioContext</span><span class=p>.</span><span class=nx>audioWorklet</span><span class=p>.</span><span class=nx>addModule</span><span class=p>(</span><span class=s2>&#34;processor.js&#34;</span><span class=p>);</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// processor.js
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>registerProcessor</span><span class=p>(</span><span class=s2>&#34;my-processor&#34;</span><span class=p>,</span> <span class=kr>class</span> <span class=kr>extends</span> <span class=nx>AudioWorkletProcessor</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>process</span><span class=p>(</span><span class=nx>inputs</span><span class=p>,</span> <span class=nx>outputs</span><span class=p>,</span> <span class=nx>params</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// handle audio here
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=kc>true</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span></code></pre></div><p>Each worklet runs in a <strong>micro-agent</strong> with hard real-time constraints.</p><hr><h3 id=-7-in-other-words-each-worker-creates-its-own-agent-while-one-or-more-windows-may-be-within-the-same-agentusually-a-main-document-and-its-similar-origin-iframes>🔹 7. “In other words, each worker creates its own agent, while one or more windows may be within the same agent—usually a main document and its similar-origin iframes.”<a hidden class=anchor aria-hidden=true href=#-7-in-other-words-each-worker-creates-its-own-agent-while-one-or-more-windows-may-be-within-the-same-agentusually-a-main-document-and-its-similar-origin-iframes>#</a></h3><h3 id=-recap>🔁 Recap:<a hidden class=anchor aria-hidden=true href=#-recap>#</a></h3><ul><li>Workers (dedicated, shared, service, worklet) → <strong>always create new agents</strong></li><li>Windows (tabs, iframes) → may share <strong>one agent</strong> if they are <strong>same origin</strong></li></ul><p>📦 So:</p><ul><li>If you <code>new Worker()</code>, you get a new agent.</li><li>If you create a same-origin iframe, it&rsquo;s part of your agent.</li><li>If it&rsquo;s a cross-origin iframe, it likely gets its <strong>own agent</strong>.</li></ul><hr><h3 id=-8-in-nodejs-a-similar-concept-called-worker-threads-is-available>🔹 8. “In Node.js, a similar concept called worker threads is available.”<a hidden class=anchor aria-hidden=true href=#-8-in-nodejs-a-similar-concept-called-worker-threads-is-available>#</a></h3><h3 id=-in-nodejs>🧠 In Node.js:<a hidden class=anchor aria-hidden=true href=#-in-nodejs>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=p>{</span> <span class=nx>Worker</span> <span class=p>}</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s2>&#34;worker_threads&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>new</span> <span class=nx>Worker</span><span class=p>(</span><span class=s2>&#34;./worker.js&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>That is <strong>exactly equivalent</strong> to a <strong>dedicated worker agent</strong> on the web.</p><ul><li>It has its own stack, heap, queue</li><li>Communicates via <code>postMessage</code></li><li>Can use <code>SharedArrayBuffer</code> for shared memory</li></ul><p>🔧 This is Node’s way of mimicking browser agents in the backend.</p><hr><h2 id=-summary-mental-model>✅ Summary Mental Model:<a hidden class=anchor aria-hidden=true href=#-summary-mental-model>#</a></h2><p>Imagine each <strong>agent</strong> as a little isolated <strong>mini JavaScript world</strong> with:</p><ul><li>📦 its own memory (<code>heap</code>)</li><li>🧠 its own thinking (<code>call stack</code>)</li><li>🕓 its own scheduler (<code>job queue</code>)</li></ul><p>Then:</p><ul><li><code>new Worker()</code> → new agent</li><li><code>SharedWorker</code> → shared agent across tabs</li><li><code>ServiceWorker</code> → background agent</li><li><code>Worklet</code> → real-time micro-agent</li><li><code>Same-origin iframe</code> → stays in same agent as parent</li></ul><hr><p>Want to move to the <strong>next block</strong> (i.e., Realms)?<br>It starts with:</p><blockquote><p>&ldquo;Each agent owns one or more realms&mldr;&rdquo;</p></blockquote><p>Just say <strong>&ldquo;next&rdquo;</strong>, and I’ll recursively break that one down too.</p><p>Perfect. Let’s do a <strong>deep recursive breakdown</strong> of this <strong>“Realms”</strong> section—<strong>line by line</strong>, with intuition, real examples, and mental models.</p><hr><h3 id=-topic-what-is-a-realm>🔰 Topic: <strong>What is a Realm?</strong><a hidden class=anchor aria-hidden=true href=#-topic-what-is-a-realm>#</a></h3><p>A <strong>Realm</strong> is like a <strong>self-contained JS universe</strong> inside an agent.<br>Think of it as a <strong>&ldquo;VM inside a thread&rdquo;</strong>.</p><hr><h2 id=-line-1-2>🔹 Line 1:<a hidden class=anchor aria-hidden=true href=#-line-1-2>#</a></h2><blockquote><p><strong>&ldquo;Each agent owns one or more realms.&rdquo;</strong></p></blockquote><p>🧠 <strong>Intuition</strong>:<br>We already learned that an <strong>agent</strong> is like a JS thread — with its own stack, heap, and event queue.</p><p>A <strong>realm</strong> lives <em>inside</em> an agent.<br>So one agent can have <strong>many realms</strong>.</p><hr><h3 id=-real-world-analogy-1>💡 Real-world Analogy:<a hidden class=anchor aria-hidden=true href=#-real-world-analogy-1>#</a></h3><ul><li><strong>Agent = one CPU core</strong> running JavaScript</li><li><strong>Realm = one JavaScript sandbox</strong> running a specific program (like a tab or an iframe)</li></ul><p>🧪 On the web:</p><ul><li>A <strong>main tab</strong> is one realm.</li><li>A <strong>same-origin iframe</strong> is a different realm.</li><li>But both can live inside the <strong>same agent</strong> (thread).</li></ul><hr><h2 id=-line-2-2>🔹 Line 2:<a hidden class=anchor aria-hidden=true href=#-line-2-2>#</a></h2><blockquote><p><strong>&ldquo;Each piece of JavaScript code is associated with a realm when it&rsquo;s loaded, which remains the same even when called from another realm.&rdquo;</strong></p></blockquote><h3 id=-whats-happening>🧠 What&rsquo;s happening?<a hidden class=anchor aria-hidden=true href=#-whats-happening>#</a></h3><p>When a JS file loads in a context (tab, iframe, worker), it’s <strong>bound to the realm of that context</strong>.</p><p>Even if it&rsquo;s later called <strong>from another realm</strong>, it still uses the <strong>original realm</strong> it was loaded in.</p><h4 id=-example>📦 Example:<a hidden class=anchor aria-hidden=true href=#-example>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl><span class=c>&lt;!-- index.html --&gt;</span>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>iframe</span> <span class=na>id</span><span class=o>=</span><span class=s>&#34;frame&#34;</span> <span class=na>src</span><span class=o>=</span><span class=s>&#34;iframe.html&#34;</span><span class=p>&gt;&lt;/</span><span class=nt>iframe</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>script</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>fn</span> <span class=o>=</span> <span class=nb>window</span><span class=p>.</span><span class=nx>frames</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=nx>someFunction</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nx>fn</span><span class=p>();</span> <span class=c1>// This still executes in iframe.html’s realm!
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>&lt;/</span><span class=nt>script</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>Even though you called the function from the main page, it still executes with the context of the iframe realm. Why? Because that’s where it was <strong>created</strong>.</p><p>🧠 Functions are <strong>sticky</strong> to the realm they were born in.</p><hr><h2 id=-line-35>🔹 Line 3–5:<a hidden class=anchor aria-hidden=true href=#-line-35>#</a></h2><blockquote><p><strong>&ldquo;A realm consists of the following information:</strong></p><ul><li>A list of intrinsic objects like <code>Array</code>, <code>Array.prototype</code>, etc.</li><li>Globally declared variables, the value of <code>globalThis</code>, and the global object</li><li>A cache of template literal arrays, because evaluation of the same tagged template literal expression always causes the tag to receive the same array object&rdquo;</li></ul></blockquote><hr><h3 id=-1-intrinsic-objects-eg-array-object-function-etc>🔸 1. <strong>Intrinsic objects</strong> (e.g. <code>Array</code>, <code>Object</code>, <code>Function</code>, etc.)<a hidden class=anchor aria-hidden=true href=#-1-intrinsic-objects-eg-array-object-function-etc>#</a></h3><p>Every realm gets <strong>its own versions</strong> of core JS constructors:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// iframe.html
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>Array</span> <span class=o>!==</span> <span class=nx>parent</span><span class=p>.</span><span class=nb>Array</span><span class=p>;</span> <span class=c1>// true
</span></span></span></code></pre></div><p>Each realm gets its own <code>Array</code>, <code>Object</code>, <code>Function</code>, etc.<br>They might behave the same — but they are <strong>different objects in memory</strong>.</p><hr><h3 id=-2-global-variables-and>🔸 2. <strong>Global variables and <code>globalThis</code></strong><a hidden class=anchor aria-hidden=true href=#-2-global-variables-and>#</a></h3><p>Every realm has its <strong>own global scope</strong> — this includes:</p><ul><li><code>window</code> in main thread</li><li><code>self</code> in workers</li><li><code>globalThis</code> (unified access)</li></ul><p>So in two realms:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// Realm A
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>globalThis</span> <span class=o>===</span> <span class=nb>window</span><span class=p>;</span> <span class=c1>// true
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// Realm B (worker)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>globalThis</span> <span class=o>===</span> <span class=nx>self</span><span class=p>;</span> <span class=c1>// true
</span></span></span></code></pre></div><p>But:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>realmA</span><span class=p>.</span><span class=nx>globalThis</span> <span class=o>!==</span> <span class=nx>realmB</span><span class=p>.</span><span class=nx>globalThis</span><span class=p>;</span> <span class=c1>// true
</span></span></span></code></pre></div><p>Each has its own <strong>isolated namespace</strong>.</p><hr><h3 id=-3-template-literal-cache>🔸 3. <strong>Template literal cache</strong><a hidden class=anchor aria-hidden=true href=#-3-template-literal-cache>#</a></h3><p>This is a performance optimization:</p><p>When you use <strong>tagged template literals</strong>, the same <strong>template array object</strong> is reused:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>tag</span><span class=p>(</span><span class=nx>strings</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>strings</span><span class=p>);</span> <span class=c1>// same array on repeated calls
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>tag</span><span class=sb>`Hello </span><span class=si>${</span><span class=nx>name</span><span class=si>}</span><span class=sb>`</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nx>tag</span><span class=sb>`Hello </span><span class=si>${</span><span class=nx>name</span><span class=si>}</span><span class=sb>`</span><span class=p>;</span>
</span></span></code></pre></div><p>This cache is <strong>per-realm</strong>, not global.</p><hr><h2 id=-line-6-2>🔹 Line 6:<a hidden class=anchor aria-hidden=true href=#-line-6-2>#</a></h2><blockquote><p><strong>&ldquo;On the web, the realm and the global object are 1-to-1 corresponded. The global object is either a <code>Window</code>, a <code>WorkerGlobalScope</code>, or a <code>WorkletGlobalScope</code>.&rdquo;</strong></p></blockquote><p>🧠 Translation:</p><p>Each realm has exactly <strong>one global object</strong>, and vice versa.</p><p>On the web:</p><table><thead><tr><th>Realm</th><th>Global Object</th></tr></thead><tbody><tr><td>Tab / iframe</td><td><code>Window</code></td></tr><tr><td>Worker</td><td><code>WorkerGlobalScope</code></td></tr><tr><td>Worklet</td><td><code>WorkletGlobalScope</code></td></tr></tbody></table><blockquote><p>That’s why if you get the <code>window</code> in the main page and compare it to an iframe’s, they’re not equal.</p></blockquote><hr><h2 id=-line-7>🔹 Line 7:<a hidden class=anchor aria-hidden=true href=#-line-7>#</a></h2><blockquote><p><strong>&ldquo;So for example, every iframe executes in a different realm, though it may be in the same agent as the parent window.&rdquo;</strong></p></blockquote><p>✅ Recap of layers:</p><ul><li><code>iframe.html</code> = different realm</li><li><code>index.html</code> = different realm</li><li>But both can share the same <strong>agent</strong> (thread), and thus talk <strong>synchronously</strong></li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>iframe</span> <span class=o>=</span> <span class=nb>window</span><span class=p>.</span><span class=nx>frames</span><span class=p>[</span><span class=mi>0</span><span class=p>];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>iframe</span><span class=p>.</span><span class=nb>document</span> <span class=o>!==</span> <span class=nb>document</span> <span class=c1>// ✅ different realm
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>typeof</span> <span class=nx>iframe</span><span class=p>.</span><span class=nb>Array</span> <span class=o>===</span> <span class=s2>&#34;function&#34;</span> <span class=c1>// ✅ iframe has its own Array constructor
</span></span></span></code></pre></div><hr><h2 id=-line-8>🔹 Line 8:<a hidden class=anchor aria-hidden=true href=#-line-8>#</a></h2><blockquote><p><strong>&ldquo;Realms are usually mentioned when talking about the identities of global objects.&rdquo;</strong></p></blockquote><p>🧠 This sets up the next gotcha:</p><ul><li>Objects might &ldquo;look&rdquo; the same (e.g. arrays from two realms)</li><li>But under the hood, their <strong>identity</strong> is different</li></ul><hr><h2 id=-final-line>🔹 Final Line:<a hidden class=anchor aria-hidden=true href=#-final-line>#</a></h2><blockquote><p><strong>&ldquo;For example, we need methods such as <code>Array.isArray()</code> or <code>Error.isError()</code>, because an array constructed in another realm will have a different prototype object than the <code>Array.prototype</code> object in the current realm, so <code>instanceof Array</code> will wrongly return false.&rdquo;</strong></p></blockquote><hr><h3 id=-mind-blowing-real-world-bug>🧪 Mind-blowing Real World Bug:<a hidden class=anchor aria-hidden=true href=#-mind-blowing-real-world-bug>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// index.html
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>arr</span> <span class=o>=</span> <span class=nb>window</span><span class=p>.</span><span class=nx>frames</span><span class=p>[</span><span class=mi>0</span><span class=p>].</span><span class=nx>contentWindow</span><span class=p>.</span><span class=nb>eval</span><span class=p>(</span><span class=s2>&#34;[]&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>arr</span> <span class=k>instanceof</span> <span class=nb>Array</span><span class=p>);</span> <span class=c1>// ❌ false
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>Array</span><span class=p>.</span><span class=nx>isArray</span><span class=p>(</span><span class=nx>arr</span><span class=p>);</span>                <span class=c1>// ✅ true
</span></span></span></code></pre></div><h4 id=why>Why?<a hidden class=anchor aria-hidden=true href=#why>#</a></h4><p>Because:</p><ul><li><code>instanceof</code> uses <strong>current realm’s Array.prototype</strong></li><li>But <code>arr</code> was created in <strong>another realm</strong>, so it&rsquo;s linked to <strong>iframe’s Array.prototype</strong></li></ul><p>→ So they’re <strong>not the same prototype</strong> — <code>instanceof</code> fails.</p><p>✅ <code>Array.isArray()</code> uses <strong>internal tags</strong> and works across realms.</p><hr><h2 id=-summary-mental-model-1>🔄 Summary (Mental Model)<a hidden class=anchor aria-hidden=true href=#-summary-mental-model-1>#</a></h2><table><thead><tr><th>Concept</th><th>Meaning</th></tr></thead><tbody><tr><td><strong>Realm</strong></td><td>A self-contained JS &ldquo;universe&rdquo; with its own global scope and built-in objects</td></tr><tr><td><strong>Agent</strong></td><td>A thread-like runner that can host one or more realms</td></tr><tr><td><strong>Function&rsquo;s Realm</strong></td><td>Determined by where it was created, not called</td></tr><tr><td><strong>Cross-realm instanceof fails</strong></td><td>Because <code>prototype</code> objects are realm-specific</td></tr><tr><td><strong>Global object</strong></td><td>The realm’s anchor: <code>Window</code>, <code>WorkerGlobalScope</code>, etc.</td></tr><tr><td><strong>Tag template cache</strong></td><td>Cached per-realm to avoid array recreation</td></tr></tbody></table><hr><p>Would you like to move on to the next section:</p><blockquote><p><strong>&ldquo;Stack and execution contexts&rdquo;</strong></p></blockquote><p>Just say <strong>“next”</strong> and I’ll break that down in the same step-by-step, deeply intuitive style.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://archit15singh.github.io/tags/javascript/>JavaScript</a></li><li><a href=https://archit15singh.github.io/tags/javascript-execution-model/>JavaScript Execution Model</a></li></ul><nav class=paginav><a class=prev href=https://archit15singh.github.io/posts/minimal-test-post/><span class=title>« Prev Page</span><br><span>Minimal Test Post</span>
</a><a class=next href=https://archit15singh.github.io/posts/2022-07-29-test-post/><span class=title>Next Page »</span><br><span>Test Post</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share JS execution model in depth on twitter" href="https://twitter.com/intent/tweet/?text=JS%20execution%20model%20in%20depth&amp;url=https%3a%2f%2farchit15singh.github.io%2fposts%2f2022-07-29-js-execution-model-in-depth%2f&amp;hashtags=JavaScript%2cJavaScriptExecutionModel"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share JS execution model in depth on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2farchit15singh.github.io%2fposts%2f2022-07-29-js-execution-model-in-depth%2f&amp;title=JS%20execution%20model%20in%20depth&amp;summary=JS%20execution%20model%20in%20depth&amp;source=https%3a%2f%2farchit15singh.github.io%2fposts%2f2022-07-29-js-execution-model-in-depth%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share JS execution model in depth on reddit" href="https://reddit.com/submit?url=https%3a%2f%2farchit15singh.github.io%2fposts%2f2022-07-29-js-execution-model-in-depth%2f&title=JS%20execution%20model%20in%20depth"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share JS execution model in depth on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2farchit15singh.github.io%2fposts%2f2022-07-29-js-execution-model-in-depth%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share JS execution model in depth on whatsapp" href="https://api.whatsapp.com/send?text=JS%20execution%20model%20in%20depth%20-%20https%3a%2f%2farchit15singh.github.io%2fposts%2f2022-07-29-js-execution-model-in-depth%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share JS execution model in depth on telegram" href="https://telegram.me/share/url?text=JS%20execution%20model%20in%20depth&amp;url=https%3a%2f%2farchit15singh.github.io%2fposts%2f2022-07-29-js-execution-model-in-depth%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><div class=container><div class="content has-text-centered"><p><strong>Archit's Space</strong> - Sharing knowledge one post at a time.<br>Crafted with ❤️ by Archit Singh</a>.<br>Connect with me on
<a href=https://github.com/archit15singh target=_blank>GitHub</a>,
<a href=https://www.linkedin.com/in/archit15singh target=_blank>LinkedIn</a>,
and <a href=https://twitter.com/archit15singh target=_blank>Twitter</a>.</p></div></div></footer><script data-goatcounter=https://architsingh.goatcounter.com/count async src=//gc.zgo.at/count.js></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>