<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive) | Archit's Space</title>
<meta name=keywords content="JavaScript,Technical Deep Dive"><meta name=description content="Explore how JavaScript code actually runs: from the engine and host environment to call stacks, queues, realms, agents, and async behavior ‚Äî explained with mental models, real code, and execution traces."><meta name=author content="Archit Singh"><link rel=canonical href=https://archit15singh.github.io/posts/2022-07-29-js-execution-model-in-depth/><link crossorigin=anonymous href=/assets/css/stylesheet.min.1c5241cc5c31e8a1af5a56caa332bfa60cee35277d8fb31c7063ca9ed7258093.css integrity="sha256-HFJBzFwx6KGvWlbKozK/pgzuNSd9j7MccGPKntclgJM=" rel="preload stylesheet" as=style><link rel=icon href=https://archit15singh.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://archit15singh.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://archit15singh.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://archit15singh.github.io/apple-touch-icon.png><link rel=mask-icon href=https://archit15singh.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.145.0"><link rel=alternate hreflang=en href=https://archit15singh.github.io/posts/2022-07-29-js-execution-model-in-depth/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive)"><meta property="og:description" content="Explore how JavaScript code actually runs: from the engine and host environment to call stacks, queues, realms, agents, and async behavior ‚Äî explained with mental models, real code, and execution traces."><meta property="og:type" content="article"><meta property="og:url" content="https://archit15singh.github.io/posts/2022-07-29-js-execution-model-in-depth/"><meta property="og:image" content="https://archit15singh.github.io/images/uploads/cosmic-timetraveler.webp"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-07-29T12:00:00+00:00"><meta property="article:modified_time" content="2022-07-29T12:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://archit15singh.github.io/images/uploads/cosmic-timetraveler.webp"><meta name=twitter:title content="How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive)"><meta name=twitter:description content="Explore how JavaScript code actually runs: from the engine and host environment to call stacks, queues, realms, agents, and async behavior ‚Äî explained with mental models, real code, and execution traces."><meta name=twitter:site content="@https://twitter.com/archit_singh15"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://archit15singh.github.io/posts/"},{"@type":"ListItem","position":2,"name":"How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive)","item":"https://archit15singh.github.io/posts/2022-07-29-js-execution-model-in-depth/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive)","name":"How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive)","description":"Explore how JavaScript code actually runs: from the engine and host environment to call stacks, queues, realms, agents, and async behavior ‚Äî explained with mental models, real code, and execution traces.","keywords":["JavaScript","Technical Deep Dive"],"articleBody":"How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive) üöÄ What This Series Will Teach You This blog post is the first step of a multi-part deep dive into the JS execution model. You‚Äôll learn:\nHow JavaScript handles synchronous and asynchronous code What the call stack, job queue, microtasks, and event loop really are How realms, agents, and execution contexts work together How engines like V8 optimize while staying spec-compliant Why seemingly simple code can behave unexpectedly ‚Äî and how to reason through it Each section will build your mental model ‚Äî with visuals, real code traces, intuitive metaphors, and runtime behavior breakdowns.\nüìå Whether you‚Äôre building a single-page app, debugging race conditions, or writing high-performance server-side JS ‚Äî knowing how JS really runs is your ultimate superpower.\n1. üéØ Introduction: What is the JavaScript Execution Model? JavaScript might look simple ‚Äî you write let x = 10, it runs. You call a function, it executes. But under the hood, a sophisticated system choreographs every line you write. That system is called the JavaScript execution model.\nüß† So‚Ä¶ what is it? At its core, the JavaScript execution model defines how JavaScript code runs:\nHow the engine interprets your code How memory is allocated and freed How functions get stacked and unstacked How asynchronous code (like setTimeout or fetch) is managed How multiple ‚Äúthreads‚Äù (agents) interact ‚Äî or don‚Äôt It‚Äôs like the operating system of JavaScript ‚Äî the abstract machine that governs how your code behaves, step-by-step.\nüß© Why should developers care? You don‚Äôt need to know every VM optimization trick to write JavaScript‚Ä¶\nBut if you want to:\nFix timing bugs Master Promises, async/await, and the event loop Avoid race conditions and memory leaks Write responsive apps that never freeze the UI Debug async issues like ‚ÄúWhy does this log after that?‚Äù ‚Ä¶then understanding the execution model isn‚Äôt optional ‚Äî it‚Äôs essential.\nIt‚Äôs the foundation beneath everything from simple loops to complex front-end architectures to performance-critical backends.\nüÜö Spec vs Reality: Goals of the Execution Model The ECMAScript specification (the official language definition) defines the execution model in a platform-neutral, abstract way.\nThis spec outlines the rules all JavaScript engines must follow, regardless of environment:\nBrowsers (Chrome/V8, Firefox/SpiderMonkey, Safari/JavaScriptCore) Servers (Node.js, Deno) Embedded runtimes (e.g. IoT devices) However, real engines are free to optimize ‚Äî just like how chess players can use different tactics, but must follow the same rules.\nFor example:\nV8 (Chrome/Node.js) uses Just-In-Time (JIT) compilation, inline caching, and memory optimizations. But it still follows the logical model the spec describes: same rules, different execution speed. üí° TL;DR: The spec defines what must happen, not how fast or how exactly an engine does it.\nüé≠ Real-World Metaphor: Actor, Stage, Script Let‚Äôs break it down with a metaphor:\nYour code = the script The JavaScript engine = the actor The host environment (browser, Node) = the stage, lighting, props, audience The execution model = the stage manager ‚Äî orchestrating who enters when, what lines are spoken, and how long each actor gets to perform The actor (engine) can‚Äôt improvise wildly ‚Äî it must follow the script (your code) ‚Äî but the stage manager decides when scenes start, what props are ready, and how long each act lasts.\nAnd just like in theater: no actor can speak two lines at the same time. JavaScript, too, is single-threaded ‚Äî one line at a time, unless you start spinning off background actors (Web Workers, Service Workers).\nüß© 2. Core Architecture of JavaScript Runtime To understand how JavaScript runs your code, we need to dissect what components make up the JS runtime.\nAt the core, JavaScript doesn‚Äôt run in a vacuum ‚Äî it needs an engine to interpret the code, and a host environment to provide real-world capabilities like networking, timers, and file access.\nLet‚Äôs peel this layer by layer.\nüîπ 2.1. The JavaScript Engine ‚úÖ Literal meaning: The engine is the heart of the JavaScript runtime. It‚Äôs the software that understands and executes ECMAScript ‚Äî the official JavaScript language specification.\nüß† What it provides: Parsing: Reads and interprets JS source code (e.g., turns function foo() {} into a syntax tree). Execution: Runs your code step-by-step, managing memory, stack, scopes, etc. Optimization: Applies techniques like JIT (Just-In-Time) compilation, inline caching, dead code elimination for speed. üõ† Examples of engines: V8 (Chrome, Node.js) SpiderMonkey (Firefox) JavaScriptCore (Safari) Chakra (deprecated, formerly in Edge) üß¨ Mental model: Think of the engine like a brain that knows how to read JavaScript, understand it, and run it ‚Äî but it‚Äôs stuck in a box. It can‚Äôt talk to the outside world unless someone wires it up.\n// This is purely engine territory: const x = 5 + 3; const doubled = x * 2; No DOM. No timers. No file I/O. Just language-level stuff.\nüîπ 2.2. The Host Environment ‚úÖ Literal meaning: This is the external system embedding the JS engine.\nIt provides platform-specific APIs and functionalities that the engine alone cannot offer.\nüåç Common host environments: Web browsers: Chrome, Firefox, Safari Node.js: Server-side JS runtime Deno: Secure, modern runtime for JS/TS React Native: JS inside mobile apps Adobe After Effects: JS for scripting animation! üõ† Host-provided APIs: These aren‚Äôt part of the JS language ‚Äî they‚Äôre provided by the host:\nAPI / Feature Provided by setTimeout() Browser / Node document.querySelector() Browser fs.readFile() Node.js fetch() Browser / Node (polyfilled) postMessage() Web Worker context navigator.geolocation Browser üíª Example: console.log(\"Hello\"); // Host provides the 'console' object setTimeout(() =\u003e { alert(\"Hi\"); }, 1000); // 'setTimeout' is NOT part of JS ‚Äî it's host API üß¨ Real-world analogy: The JS engine is the actor. The host environment is the stage, lighting, props, and audience. The actor can memorize lines (JavaScript), but can‚Äôt do anything ‚Äî like turn on a spotlight or play sound ‚Äî unless the stage supports it.\nüîπ 2.3. Engine vs Host: Division of Concerns ‚úÖ Literal meaning: JavaScript engines and host environments play distinct but collaborative roles.\nConcern Handled by let, const, class, =\u003e JavaScript Engine console.log, setTimeout Host Environment document.getElementById Host (Browser) fs.readFileSync Host (Node.js) üß† Why this matters: JavaScript isn‚Äôt ‚Äúbrowser-only‚Äù ‚Äî it‚Äôs a language, not a platform. This is why you can run JS in: a browser (with DOM), a server (Node.js), an embedded device (e.g. Espruino), or even in a text editor plugin (VS Code extensions). Each context offers different tools ‚Äî but the engine stays the same.\nüß™ Code Comparison: // Runs in browser setTimeout(() =\u003e console.log(\"Hi\"), 1000); document.body.style.background = \"black\"; // Runs in Node setTimeout(() =\u003e console.log(\"Hi\"), 1000); const fs = require(\"fs\"); fs.readFileSync(\"./file.txt\"); Same JS engine (V8), totally different capabilities, because of the host.\n‚ö†Ô∏è Gotcha: ‚ÄúWhy does JS code fail in Node but not in the browser?‚Äù // This fails in Node.js: document.getElementById(\"app\"); Because document is a host-provided object, and Node doesn‚Äôt include a DOM.\nüí° Same JavaScript. Different host. Different powers.\nüîó Related Concept: Polyfills and Environment Detection Because hosts vary:\nWe need feature detection (typeof window, if ('fetch' in globalThis)) We write polyfills (e.g., implement fetch in Node if it‚Äôs missing) üß† TL;DR Mental Model Layer Role JavaScript Engine Understands and executes ECMAScript code Host Environment Provides platform-specific capabilities JS Runtime Combination of engine + host (aka ‚ÄúJS in the wild‚Äù) üß© Summary Table Concept Engine or Host? Example Promise, Map Engine ECMAScript features setTimeout() Host Timer API (browser/Node) document Host (Browser) Web page interaction fs Host (Node.js) File system access console Host Logging (defined per host) function, =\u003e Engine Language-level syntax 3. üß† Agent Execution Model ‚Äî The Secret Engine Behind JavaScript‚Äôs Run-Time JavaScript may look like a language, but it runs like a machine. Under the hood, every line of your JavaScript code is managed by a tiny execution engine called an agent.\nLet‚Äôs crack open the hood and understand:\nWhat an agent actually is The key data structures that power it The lifecycle that makes async, generators, and tasks tick 3.1 üöÄ What is an Agent? In the JavaScript spec, an agent is a self-contained execution environment ‚Äî like a virtual CPU.\nIt has its own memory (heap) Its own call stack Its own event/job queue If you‚Äôre running JavaScript in a browser tab, that‚Äôs an agent.\nIf you‚Äôre running a Web Worker, that‚Äôs another agent.\nEach agent is isolated from the others (unless explicitly connected via SharedArrayBuffer).\nüß† Think of an agent as: A single thread of execution with all the gears it needs to process JavaScript independently.\nüî¨ Metaphor: If your code is a cooking recipe, an agent is the chef executing it ‚Äî with its own kitchen, ingredients, and clipboard of instructions.\n3.2 ‚öôÔ∏è Agent Data Structures: The Triad Every agent internally runs three major data structures ‚Äî the holy trinity of JS execution:\nüß† 1. Heap üì¶ Where objects and functions live ‚Äî long-term storage.\nEvery time you create an object ({}), array ([]), or function, it‚Äôs allocated on the heap. Think of the heap as your warehouse of live objects. const user = { name: \"Ada\" }; // lives in the heap This is unstructured memory ‚Äî managed automatically by the garbage collector.\nüß† 2. Call Stack üßæ Where functions are executed, tracked, and returned ‚Äî one frame at a time.\nJavaScript uses a stack (LIFO) to manage function calls. Each function call creates an execution context (aka stack frame). When a function finishes, the frame is popped off. function outer() { inner(); } function inner() { console.log(\"Hi\"); } outer(); Stack:\nouter() inner() console.log(...) Return, return, done ‚úÖ üî¨ Metaphor: Like opening nested boxes. You can‚Äôt close box A until you‚Äôve closed box B inside it.\nüß† 3. Job/Task Queue üïì A FIFO queue of pending asynchronous callbacks to run when the stack is empty.\nUsed by async actions: setTimeout, fetch, Promises Part of the event loop mechanism Each ‚Äújob‚Äù is a callback waiting to be pulled onto the stack console.log(\"A\"); setTimeout(() =\u003e console.log(\"B\")); console.log(\"C\"); Output: A ‚Üí C ‚Üí B\nBecause setTimeout schedules B on the task queue, which runs after the current stack empties.\nüî¨ All Together: Structure Type Role Heap Memory Stores all objects, functions Stack LIFO Tracks current function calls Queue FIFO Stores async jobs to run next 3.3 ‚è≥ Agent Lifecycle ‚Äî How Code Actually Runs The life of a JavaScript agent is a predictable cycle:\nüîÑ Step 1: A Job Begins A new job is pulled from the queue (e.g., a setTimeout callback) A new execution context is pushed onto the stack JS starts running the code in that callback üìà Step 2: Stack Fills Up The function may call other functions More execution contexts are added The call stack grows üìâ Step 3: Stack Empties Each function finishes and returns The stack pops back down to empty Once empty, the agent picks the next job from the queue üí§ Step 4: Idle or Re-entry If the queue is empty ‚Üí agent waits If the code yields (e.g. with a generator or async function), the context is paused It can later be resumed with the same state function* steps() { console.log(\"Start\"); yield; console.log(\"Resumed\"); } const g = steps(); g.next(); // Start g.next(); // Resumed üß† The function isn‚Äôt restarted ‚Äî it‚Äôs resumed from where it left off.\nüß† Why It Matters Understanding the agent model gives you deep insight into:\nWhy JS is single-threaded (per agent) Why async functions return promises Why await doesn‚Äôt block the thread Why stack overflows happen (Recursion!) üí° Bonus: Multi-Agent Systems You can have multiple agents running concurrently (e.g., Web Workers) Each has its own stack, heap, and queue They can only communicate via: postMessage (copying data) SharedArrayBuffer + Atomics (shared memory) ‚úÖ Recap: Agent Model Mental Picture Part Role Behavior Agent The JS ‚Äúruntime engine‚Äù Runs JS code sequentially Heap Stores objects Grows dynamically, managed by GC Stack Manages function calls LIFO ‚Äî grows and shrinks Queue Schedules async jobs FIFO ‚Äî drives the event loop Lifecycle Pull job ‚Üí execute ‚Üí finish ‚Üí repeat Enables async flow ‚ú® Real-World Debugging Tip When your UI freezes or console.log appears out of order ‚Äî you‚Äôre seeing the agent lifecycle in action.\nIf you understand how the stack and queue interact, you can predict and control the timing of your code.\n4. üì¶ Execution Contexts \u0026 Call Stack 4.1. üß† What is an Execution Context? An execution context (also called a stack frame) is the smallest unit of JS code execution.\nWhenever JavaScript runs any code‚Äîbe it global, a function, or an eval‚Äîit wraps it in an execution context.\nüîç It contains: üßæ The currently executing function or script üì¶ Its Lexical Environment (all its declared variables, parameters, inner functions) üîó The associated Realm (global scope + intrinsics like Array) üí¨ Special bindings like this, arguments, and super üß≠ The return address (where to go back once the function completes) üß¨ Mental Model: Like a stack of sticky notes: each time a function is called, a new note (context) is added. It tracks what to do and where to return. Once done, it peels off.\nüíª Example: function add(a, b) { return a + b; } function compute(x) { const y = 2; return add(x, y); } compute(5); // Execution Contexts created: global -\u003e compute -\u003e add Each function call creates a new context with its own scope, this, and state.\nüß© Lexical Environment Every execution context has a Lexical Environment, which stores:\nLocal variable bindings (let, const, var) Function declarations Inner scopes (closures) It‚Äôs called lexical because it‚Äôs determined by where the code is written, not how it is called.\nüîÅ Closures: When a function is defined, it ‚Äúremembers‚Äù the Lexical Environment it was created in. This is what powers closures:\nfunction outer() { let count = 0; return function inner() { count++; return count; } } The inner function holds on to the outer‚Äôs lexical environment even after outer has returned.\nüåê Realm Association Each execution context is tied to a Realm, which determines:\nThe version of intrinsics like Array, Function, etc. The globalThis value Identity rules (e.g., x instanceof Array fails across realms) ‚ö†Ô∏è Gotcha: // If `arr` is created in iframe arr instanceof Array; // ‚ùå false (different realm's Array) Array.isArray(arr); // ‚úÖ works (uses internal tag) ‚öôÔ∏è this, arguments, and Bindings Each context stores runtime-bound values:\nthis ‚Äî depends on how the function is called (object method, arrow, etc.) arguments ‚Äî array-like object for parameters (non-arrow functions) super ‚Äî relevant in class methods New private class fields/methods also bind per context 4.2. üîÅ Function Invocation \u0026 Stack Frames When a function is invoked:\nJS creates a new execution context (stack frame) Pushes it onto the call stack Begins executing it üì§ When the function finishes: It returns a value or throws an error Its frame is popped off the stack Execution continues where it left off üíª Code Trace: function foo() { const x = 10; return bar(x); } function bar(n) { return n + 5; } foo(); üß± Stack trace:\n[global] ‚Üí foo() ‚Üê pushed ‚Üí bar(10) ‚Üê pushed ‚Üê return 15 ‚Üê bar popped ‚Üê return 15 ‚Üê foo popped üéØ Key behaviors: Return unwinds one frame Throw can unwind multiple frames up the stack (via try/catch or crash) Recursion builds up frames until base case or overflow ‚ö° 4.3. Tail Call Optimization (TCO) Tail Call = when a function returns the result of calling another function directly\n(i.e., no more work left to do after the call).\nfunction a() { return b(); // ‚Üê tail position } If supported, JS engines can reuse the current stack frame rather than creating a new one.\nüéØ Benefits: Prevents stack overflow in tail-recursive functions Improves memory efficiency for deeply nested calls üî• Example (ideal for TCO): function factorial(n, acc = 1) { if (n \u003c= 1) return acc; return factorial(n - 1, acc * n); // tail call } üîÅ Without TCO ‚Üí Stack grows with n\n‚úÖ With TCO ‚Üí Constant memory usage\n‚ö†Ô∏è Engine Support Caveats: ECMAScript 2015 specifies proper TCO. Only Safari implements it (as of now). V8, SpiderMonkey, Chakra do not support it due to debugging \u0026 stack trace concerns. üß† Summary Table Concept Meaning \u0026 Purpose Execution Context Metadata + bindings for running code Stack Frame Unit of execution pushed onto the call stack Lexical Environment Local scope: variables, closures, declarations Realm JS ‚Äúuniverse‚Äù for built-ins, globalThis, etc. Call Stack LIFO structure tracking nested calls Return / Throw Unwinds stack frames (1 or more) Tail Call Optimization Reuses stack frame for tail calls (not widely supported) 5. üåÄ Understanding Realms: The Hidden Worlds of JavaScript Execution When we talk about JavaScript execution, we often focus on the call stack, the event loop, or async jobs. But there‚Äôs a deeper architectural layer that rarely gets discussed‚ÄîRealms.\nThink of realms as self-contained universes within a single JavaScript agent. If you‚Äôre debugging why instanceof mysteriously returns false, or why your iframe‚Äôs Array behaves strangely, you‚Äôre bumping up against realms‚Äîwithout even knowing it.\nLet‚Äôs unpack this critical concept with surgical depth and practical clarity.\nüì¶ What Is a Realm? A realm is a sandboxed execution environment in JavaScript.\nEach realm has its own global object and its own copies of built-in constructors like Object, Array, Function, and so on.\nIn simpler terms:\nA realm is a complete JS world‚Äîwith its own set of laws (built-ins), and its own sky (global object). It exists within an agent (a JS thread), and multiple realms can coexist inside a single agent. üß† Mental Model: üßµ Agent = one JS thread\nüåç Realm = one JS environment (one globalThis)\nüí° Real-World Examples: Your main browser tab ‚Üí 1 realm. A same-origin ‚Üí another realm (but in the same agent). A Web Worker ‚Üí a separate agent with its own realm. üî¨ Realm Internals Let‚Äôs zoom into what makes up a realm:\n1. üß¨ Intrinsic Objects Each realm creates fresh copies of all intrinsic JS constructors and prototypes:\nArray !== iframe.contentWindow.Array; // ‚úÖ true Object !== iframe.contentWindow.Object; // ‚úÖ true These aren‚Äôt just shallow copies ‚Äî they‚Äôre entirely different objects in memory. This is what leads to one of the most notorious bugs in cross-realm JS‚Ä¶\n‚ö†Ô∏è Gotcha: instanceof fails across realms const iframeArray = iframe.contentWindow.eval(\"[]\"); iframeArray instanceof Array; // ‚ùå false Array.isArray(iframeArray); // ‚úÖ true Why? Because iframeArray‚Äôs prototype chain points to iframe‚Äôs Array.prototype, not yours.\nThis is why you should always use:\nArray.isArray(obj) Object.prototype.toString.call(obj) ‚Ä¶and never rely on instanceof when realms might be involved.\n2. ü™ê Global Object and globalThis Each realm gets its own global object, which defines the top-level scope.\nDepending on the context, this global object could be:\nA Window (in a tab or iframe) A WorkerGlobalScope (in a worker) A WorkletGlobalScope (in an audio or paint worklet) window.globalThis === window; // ‚úÖ in a tab self.globalThis === self; // ‚úÖ in a worker Each realm has a unique globalThis ‚Äî they don‚Äôt bleed into each other.\n3. üß† Template Literal Cache Tagged template literals reuse the same array object on repeated calls within the same realm:\nfunction tag(strings) { console.log(strings); // same object each time } tag`hello`; // strings === [\"hello\"] tag`hello`; // strings is the same object But that cache is per-realm. Use a different realm (like an iframe), and you‚Äôll get a different array object, even with the same template.\nüß© Realms vs Agents Let‚Äôs clarify the distinction:\nConcept Realm Agent What it is A JS environment with its own global scope \u0026 built-ins A JS thread (executor of code) Count Multiple per agent One per thread Global object Unique per realm (window, self, etc.) Not shared across agents Memory Shared heap (within same agent) Isolated between agents unless using SharedArrayBuffer üîÅ Realms Can Talk (if in same agent) If you have:\n\u003ciframe src=\"same-origin.html\"\u003e\u003c/iframe\u003e You can synchronously access the iframe‚Äôs realm:\niframe.contentWindow.document.title; // ‚úÖ works But remember: it‚Äôs a different realm. So be cautious with identity checks.\nüîê Why Realms Matter in the Real World 1. Security and Isolation Realms provide containment: Each realm is sandboxed with its own set of built-ins and globals. Cross-origin iframes get different agents and different realms, enforcing strict separation. 2. Framework \u0026 Testing Tooling Tools like Jest, JSDOM, or sandboxed evaluators often run code in isolated realms to prevent global pollution. 3. Micro-frontend Architecture In advanced front-end architectures, teams load independent apps in iframes or ShadowRealms to prevent conflicts. 4. Cross-Realm Bugs If you‚Äôre building libraries, especially polyfills or type-checking utils, you must account for realm differences. // Anti-pattern value instanceof Object; // ‚ùå not safe across realms // Safe alternative Object.prototype.toString.call(value) === \"[object Object]\"; // ‚úÖ üß† Takeaways A realm is a self-contained JS universe ‚Äî with its own global scope and its own versions of built-in types. Realms can coexist inside a single agent, but their built-ins and identity checks do not overlap. Always prefer realm-safe methods (Array.isArray, Object.prototype.toString.call) over instanceof. Understand realms if you‚Äôre working with: iframes workers multi-app frontends testing sandboxes serialization/deserialization across origins üìå Bonus: ShadowRealm (TC39 Stage 3) A new JS feature, ShadowRealm, allows you to create a new realm programmatically without using iframes:\nconst realm = new ShadowRealm(); const result = realm.evaluate(`1 + 1`); // 2 This is realm-level isolation, but still within the same agent. Great for security, testing, or plugin systems.\n‚úçÔ∏è Final Word JavaScript realms are like alternate realities ‚Äî isolated yet interconnected in subtle ways. They influence how your objects behave, how identity is checked, and how memory is managed.\nUnderstanding realms is a superpower ‚Äî especially if you‚Äôre debugging strange prototype issues or building frameworks and platforms. Master this layer, and you‚Äôre one step closer to mastering the entire JavaScript execution model.\n6. üåê Agent Types in the Web Platform 6.1. Main Window Agent 6.2. Dedicated Worker Agent 6.3. Shared Worker Agent 6.4. Service Worker Agent 6.5. Worklet Agent Each has its own heap, stack, queue Communication model (postMessage, SharedArrayBuffer) 6. üåê Agent Types in the Web Platform The web isn‚Äôt just one giant thread where all JavaScript code runs together. Instead, it‚Äôs composed of multiple agents ‚Äî isolated, independent runtimes that can each execute JS code with their own heap, call stack, and event loop. Understanding these agent types is crucial for mastering concurrency, memory isolation, and performance design patterns in modern web development.\nLet‚Äôs break down the main types of agents and why they matter:\n6.1 ü™ü Main Window Agent This is the agent you interact with most ‚Äî the tab in your browser running HTML, CSS, and JavaScript. It includes:\nThe global window object Access to the DOM Full access to browser APIs (e.g., document, alert, fetch) Multiple same-origin iframes can share the same agent, meaning they share the call stack and can synchronously call each other‚Äôs functions and access each other‚Äôs memory (within security limits).\nüìå Key traits:\nHas direct DOM access Can synchronously communicate with same-origin iframes Cannot be blocked via Atomics.wait() üß† Mental model: A control room managing user interaction, UI rendering, and input events ‚Äî all on one thread.\n6.2 üë∑ Dedicated Worker Agent Created via new Worker(), a Dedicated Worker runs JS in a completely separate agent ‚Äî its own isolated thread. It doesn‚Äôt have access to the DOM, but can perform heavy computations without blocking the main thread.\nüì¶ Separate agent = separate memory:\nOwn heap Own call stack Own event loop üß† Think of it like spawning a specialized assistant: you give it instructions via postMessage(), and it replies asynchronously.\n‚úÖ Can use SharedArrayBuffer for shared memory (with proper CORS and COOP/COEP headers)\nüíª\nconst worker = new Worker(\"worker.js\"); worker.postMessage({ task: \"compute\" }); 6.3 ü§ù Shared Worker Agent Shared Workers are like Dedicated Workers, but shared across multiple same-origin contexts ‚Äî tabs, iframes, or windows. They persist beyond a single page and can maintain shared state (like a single WebSocket connection).\nüìå Key distinction: They do not share memory with their clients. All communication is through postMessage() using structured cloning.\nüß† Metaphor: A shared database or message bus multiple clients talk to, but no one can directly poke into its memory.\n6.4 üõ∞ Service Worker Agent A Service Worker is a proxy-like agent that sits between your web app and the network. It doesn‚Äôt have a UI and cannot touch the DOM, but it can:\nIntercept network requests Serve cached assets Enable offline experiences Run even when the page is closed üì¶ It has its own agent ‚Äî its own heap, stack, and event queue ‚Äî and doesn‚Äôt share memory with any window.\nüß† Think of it as a background daemon that acts as a programmable router.\nüí° Bonus: Service workers are essential for building Progressive Web Apps (PWAs).\n6.5 üé® Worklet Agent Worklets are ultra-lightweight, low-latency agents used for frame-by-frame operations in:\nAudioWorklet (real-time DSP) PaintWorklet (CSS custom painting) LayoutWorklet (custom layout logic) These agents are stripped down for speed ‚Äî no DOM, no network access, but real-time-safe execution.\nüß† Imagine a tiny artist or sound engineer working just fast enough to keep up with your browser‚Äôs 60FPS heartbeat.\nüìå They run inside their own agent and can be memory-shared with their creators using SharedArrayBuffer.\nüß¨ All Agent Types Have: ‚úÖ Their own execution context:\nHeap: where objects live Call stack: for function execution Job queue: for async callbacks (event loop) ‚úÖ Communication model:\nüîÅ postMessage() for asynchronous messaging (structured cloning) üîó SharedArrayBuffer + Atomics for shared memory and synchronization (if in the same agent cluster) üß† Summary Table Agent Type DOM Access Memory Sharing Shared Across Tabs? Use Case Main Window Agent ‚úÖ Yes ‚úÖ with same-origin iframes ‚ùå UI logic, DOM interaction Dedicated Worker ‚ùå No ‚úÖ via SharedArrayBuffer ‚ùå Heavy computation, parallel tasks Shared Worker ‚ùå No ‚ùå ‚úÖ Cross-tab state sync, WebSocket hub Service Worker ‚ùå No ‚ùå ‚úÖ Offline support, request caching Worklet ‚ùå No ‚úÖ (when configured) ‚ùå Real-time audio/visual processing üîó Related Concepts: Agent Cluster: A group of agents that can share memory (SharedArrayBuffer) and synchronize with Atomics. Structured Cloning: Default communication method ‚Äî objects are copied, not shared. Heap / Stack / Queue: Every agent gets their own ‚Äî enabling safe, parallel, isolated execution. üì£ Takeaway:\nModern JavaScript isn‚Äôt single-threaded anymore ‚Äî it‚Äôs multi-agent.\nYou, as a developer, control which type of agent runs your code ‚Äî and how they communicate. Choose wisely based on memory safety, responsiveness, and your app‚Äôs architecture.\n7. üîÅ Job Queue \u0026 Event Loop Modern JavaScript feels synchronous ‚Äî but behaves asynchronously. That paradox is powered by one of the most elegant constructs in programming: the event loop.\nLet‚Äôs dive deep into how JavaScript keeps your code non-blocking, predictable, and responsive ‚Äî using jobs, queues, and a beautiful bit of choreography called the run-to-completion model.\n7.1 üîß What is a Job? Callback + Execution Context = Job\nEvery time your code hands off a function to be called later ‚Äî say, via setTimeout, a Promise, or a DOM event ‚Äî you‚Äôre scheduling a job. Think of it as a tiny program JS will run once it‚Äôs done with the current one.\nThese jobs are stored in queues and executed one at a time, with guaranteed order and isolation.\nüß† Mental Model:\nEach job is like a fully wrapped meal order ‚Äî a recipe (callback) bundled with ingredients (execution context). JS cooks them one-by-one, never two at once.\n7.2 üîÑ Event Loop: The Scheduler-in-Chief At the heart of this system is the event loop, the mechanism that:\nWaits for the stack to be empty Pulls the next job from the queue Executes it entirely before moving on This is the run-to-completion guarantee.\nüí° Why it matters:\nNo two callbacks ever run at the same time Shared variables are safe during a job Your program stays predictable and easy to reason about console.log(\"A\"); setTimeout(() =\u003e console.log(\"B\"), 0); console.log(\"C\"); // Output: // A // C // B üîç Even though the timer is 0ms, it gets queued as a job and only runs after current code finishes.\n7.3 ‚öñÔ∏è Microtasks vs Macrotasks Not all jobs are equal. The queue is actually two queues:\nType Examples Priority Microtasks Promise.then, queueMicrotask() üî• High (drained first) Macrotasks setTimeout, setInterval, DOM events ‚è≥ Lower After every job (macro or otherwise), the event loop drains all microtasks before running the next macro task.\nconsole.log(\"Start\"); setTimeout(() =\u003e console.log(\"Timeout\"), 0); Promise.resolve().then(() =\u003e console.log(\"Promise\")); console.log(\"End\"); // Output: // Start // End // Promise // Timeout üìå Microtasks are prioritized ‚Äî even over timers.\nüß† Metaphor:\nMicrotasks are sticky notes on your desk. Macrotasks are meetings. After finishing a job (macro), JS clears all sticky notes (micro) before going to the next meeting.\n7.4 üßµ Blocking vs Non-Blocking JS‚Äôs single-threaded nature means blocking is dangerous ‚Äî if your code stalls, your UI freezes, your app becomes unresponsive.\n‚úÖ Async I/O ‚Äî like fetch, setTimeout, readFile ‚Äî is non-blocking by design.\nüö´ But legacy APIs can block the agent entirely:\nAPI Behavior alert() Blocks entire tab confirm() Blocking XMLHttpRequest (sync) Blocking üí° Even while(true){} loops will freeze your app.\nüîç Modern JavaScript avoids blocking at all costs by using:\nThe event loop The job queue And a non-blocking I/O model üí° Final Mental Model Visualize JavaScript as a factory:\nüèóÔ∏è Call Stack: The active workstation (only one at a time) üì¨ Job Queue: A mailbox full of tasks to run üîÅ Event Loop: A robot that: Waits for the workstation to be free Picks the next job from the mailbox Ensures no job starts until the last one finishes And among the jobs:\nüìù Microtasks are urgent memos ‚Äî always read before any new mail. ‚è∞ Macrotasks are full packages ‚Äî scheduled deliveries that wait their turn. This model gives JS its magic mix of simplicity + power:\nSingle-threaded but never frozen (if you follow the rules) Predictable execution with async capabilities Safe by default, powerful when needed Next time you wonder why Promises beat timers, or why your UI freezes, or why console.log shows up before your setTimeout, remember:\nYou‚Äôre not just writing code ‚Äî you‚Äôre orchestrating a symphony of jobs in a beautifully synchronized single-threaded engine.\n8. üß† Concurrency \u0026 Memory Sharing In the world of JavaScript, we often talk about single-threaded execution, the event loop, and asynchronous callbacks. But what happens when multiple threads‚Äîagents, in ECMAScript speak‚Äîneed to share memory and coordinate? That‚Äôs where agent clusters, shared memory, and atomic operations come in.\nThis section dives into JavaScript‚Äôs low-level concurrency primitives, showing how modern engines manage parallelism safely using shared memory, and how developers can reason about memory consistency, data races, and synchronization.\n8.1 ‚ö° Agent Clusters: Who Can Share Memory with Whom? In JavaScript, every independent execution context‚Äîlike a tab, worker, or iframe‚Äîis called an agent. But not all agents are created equal. Only some can share memory.\nAgents that can share memory form what‚Äôs called an agent cluster.\nüß† Core Rule: If two agents can share a SharedArrayBuffer, they belong to the same cluster. If not, they are completely isolated.\n‚úÖ In the Same Cluster (can share memory): A Window and the Dedicated Worker it creates A Worker and the Dedicated Worker it spawns A Window and a same-origin iframe A Window and a same-origin opener window A Window and its Worklet ‚ùå Different Clusters (can‚Äôt share memory): A Window and a SharedWorker A Window and a ServiceWorker A Worker and a SharedWorker Two unrelated same-origin Window objects A Window and a cross-origin iframe Think of agent clusters like secure bubbles. If two agents are in the same bubble, they can point to the same memory. If not, even passing a reference is forbidden.\n8.2 üß† Shared Memory with SharedArrayBuffer JavaScript is traditionally copy-by-value when agents communicate. That‚Äôs how postMessage() works: it sends a structured clone of the data.\nBut there‚Äôs one exception: SharedArrayBuffer.\nüß¨ Metaphor: Normally, you‚Äôre emailing someone a photocopy of your notebook. With SharedArrayBuffer, you‚Äôre giving them the same notebook, and now you both can write in it‚Äîsimultaneously.\nüîó How It Works: const sab = new SharedArrayBuffer(1024); // shared memory const view = new Int32Array(sab); // typed view worker.postMessage(sab); // no clone ‚Äî both now point to the same memory Now both the main thread and the worker share that memory. But shared access means concurrent access, and that leads us to‚Ä¶\n8.3 üîí Synchronizing with Atomics Just because memory is shared doesn‚Äôt mean it‚Äôs safe.\nüß† Regular JS assignments like arr[0] = arr[0] + 1 are not atomic and can be torn apart when run from two agents at once.\nThat‚Äôs why ECMAScript gives us Atomics: a namespace of operations that guarantee safe, lock-free memory coordination.\nüõ† Tools in the Atomics toolbox: Atomics.load(view, index) ‚Äî safely read Atomics.store(view, index, value) ‚Äî safely write Atomics.add, sub, and, or, xor, etc. ‚Äî read-modify-write Atomics.wait(view, index, value) ‚Äî block until value changes Atomics.notify(view, index, count) ‚Äî wake up blocked agents // Thread 1 while (Atomics.load(view, 0) !== 1) { Atomics.wait(view, 0, 0); // wait until someone sets it to 1 } // Thread 2 Atomics.store(view, 0, 1); Atomics.notify(view, 0); This pattern enables thread-style coordination between agents ‚Äî like building your own semaphores or locks.\n‚ö†Ô∏è Only dedicated or shared workers can be blocked using Atomics.wait(). Windows and service workers are never allowed to block.\n8.4 üìè Memory Consistency and Data Races JavaScript‚Äôs memory model ensures predictable behavior only if you follow certain rules.\n‚úÖ Data race‚Äìfree = safe, consistent, sequential semantics\n‚ùå Data races = torn values, weird bugs, and undefined behavior\n‚ö†Ô∏è What‚Äôs a Data Race? When two agents access the same memory location at the same time, and at least one of them writes, without proper synchronization.\nüß™ Example of value tearing: // One agent writes a 32-bit int arr[0] = 0x12345678; // Another agent reads only the first 16 bits mid-write Result? You read a garbage value like 0x12340000. That‚Äôs value tearing.\nüîí Rule of Thumb: Always access shared memory via Atomics. Use the same access size and typed array across all agents. Avoid mixing atomic and non-atomic operations on the same memory cell. üß† Why This Matters Shared memory gives us high-performance parallelism in JavaScript ‚Äî without blocking the main thread.\nBut it comes with the responsibility of:\nDefining clear communication patterns Designing for race-freedom Understanding that postMessage() ‚â† shared memory unless you use SharedArrayBuffer Avoiding subtle bugs from cross-agent memory inconsistencies üì¶ In Summary Concept Description Agent Cluster Group of JS agents that can share memory SharedArrayBuffer Enables memory sharing between agents Atomics Enables safe, lock-free communication on shared memory Data Race When agents read/write same memory without sync Sequential Consistency All agents see memory changes in the same order if no races üí≠ Final Thought The introduction of shared memory and Atomics fundamentally changes what JavaScript is capable of ‚Äî enabling parallel algorithms, real-time audio processing, and high-throughput computation. But it also demands a new level of rigor. Just as Promise taught us to think about time, SharedArrayBuffer and Atomics teach us to think about space ‚Äî and how multiple minds can share the same thoughts without stepping on each other‚Äôs toes.\nWelcome to the world of concurrent JavaScript ‚Äî where your variables can now live in more than one mind at once.\n9. üöß Cluster Lifecycle \u0026 Blocking Modern JavaScript engines have evolved into distributed runtimes. And yet, most developers still think in terms of ‚Äúsingle-threaded async code‚Äù. But under the hood, agents, clusters, and shared memory enable fine-grained concurrency.\nThis section explores what really happens when JS environments start talking ‚Äî and blocking ‚Äî across boundaries.\n9.1. üß± Blocking APIs (Atomics.wait) üß† What does ‚Äúblocking‚Äù actually mean in JavaScript? We‚Äôre used to await yielding control ‚Äî letting the event loop breathe. But Atomics.wait()? That‚Äôs a different beast.\nAtomics.wait(int32Array, 0, 0); // üí• BLOCKS the agent This is not like Promises. It completely freezes the thread.\n‚úÖ Promise = async yield Returns control to the event loop Lets other jobs run while waiting ‚ùå Atomics.wait = sync block Halts everything in that agent (no event loop progress) Nothing else in that thread runs until another agent calls Atomics.notify üß¨ Mental Model:\nA waiter (Promise) steps aside while the kitchen runs. A locked door (Atomics.wait) freezes the kitchen until someone unlocks it.\n9.2. üõ° Forward Progress Guarantees Concurrency is dangerous ‚Äî race conditions, deadlocks, and starvation are real risks.\nThat‚Äôs why ECMAScript enforces forward progress guarantees, even in multi-agent systems.\nIf multiple agents share the same thread, the runtime must ensure no agent starves forever.\nüí° Fairness by design: The engine cannot ignore one agent just because another is busy. Even if two agents are blocking each other via Atomics, the spec mandates that some agent makes progress. üì¶ Why this matters: Imagine two workers sharing memory. If worker A holds a lock and gets suspended forever, and worker B is waiting to acquire it ‚Äî you‚Äôve just created a distributed deadlock.\nThe JavaScript memory model prevents that scenario by ensuring all agents in a cluster eventually get time to run.\nüß† Intuition: Even in tight concurrency loops, JavaScript won‚Äôt let one agent monopolize the thread indefinitely.\n9.3. üí• Agent Termination: The Cluster Is a Single Failure Domain Terminate one agent in a cluster, and you kill them all.\nThis is one of the lesser-known ‚Äî but crucial ‚Äî constraints of agent clusters.\n‚úÖ If agents share memory, they‚Äôre in the same cluster. üî• If one crashes, they all go down. Why?\nBecause allowing a shared-memory cluster to continue operating with a missing participant would:\nRisk memory corruption Break lock semantics Violate deterministic state models üß¨ System-level analogy: Imagine a nuclear power grid with interdependent control units. If one node goes offline during a write, the entire system must halt to avoid undefined behavior.\nüß™ What about fault-tolerance? Interestingly, the ECMAScript spec mentions a second strategy: detect a terminated agent and let others recover.\nBut:\nüîí It‚Äôs not implemented in any browser üõ† Still a theoretical model ‚Äî not production-grade yet ‚ö†Ô∏è Takeaways for System Builders If you‚Äôre using SharedArrayBuffer, Atomics, or any worker model with shared memory:\n‚úÖ Understand agent clusters: memory sharing defines membership üß† Don‚Äôt rely on postMessage for real concurrency ‚Äî use SAB + Atomics intentionally üõë Avoid assuming you can recover from crashes inside a cluster ‚Äî you can‚Äôt (yet) üßµ Be aware of blocking: Promises = cooperative, Atomics = hard locks üìå Final Thought:\nShared memory brings power ‚Äî and responsibility. You‚Äôre no longer in JavaScript‚Äôs comfy async sandbox. You‚Äôre in systems-land now ‚Äî where deadlocks, race conditions, and cluster-wide failure are real threats.\nUse the power. Know the cost.\nüîó 10. Putting It All Together üéØ Why this section matters: Everything we‚Äôve explored ‚Äî stacks, heaps, queues, jobs, realms, agents, workers, shared memory ‚Äî now comes together into a unified execution trace. This is where theory meets runtime. This is where your intuition levels up.\n10.1 ‚öôÔ∏è Full Execution Trace Let‚Äôs simulate a complete run of a JavaScript program involving:\nüß† Synchronous execution (stack) ‚è∞ setTimeout (macro-task queue) üí¨ Promise (microtask queue) üîÅ Nested function calls üîÑ Event loop orchestration üíª Code Example: console.log(\"Start\"); setTimeout(() =\u003e { console.log(\"Timeout 1\"); }, 0); Promise.resolve().then(() =\u003e { console.log(\"Promise 1\"); }); console.log(\"End\"); üîÅ Execution Timeline Step Stack Microtask Queue Task Queue Output 1 global() 2 log(‚ÄúStart‚Äù) Start 3 setTimeout(‚Ä¶) [Timeout callback] 4 Promise.then(‚Ä¶) [Promise callback] [Timeout callback] 5 log(‚ÄúEnd‚Äù) [Promise callback] [Timeout callback] End 6 Execute microtask [] [Timeout callback] Promise 1 7 Execute macro task [] [] Timeout 1 üß† Metaphor: Call stack is your desk ‚Äî only one function open at a time. Microtasks are sticky notes stuck to the monitor ‚Äî you handle them after the current task, but before picking a new one from the task queue. Macro-tasks (setTimeout) are tasks waiting in your inbox ‚Äî they only get attention after all microtasks are done. üîó Connections Stack: Tracks what code is currently running. Heap: Stores Promise, callback functions. Job Queue: Schedules promise callbacks (microtasks). Task Queue: Schedules setTimeout, events (macro-tasks). Event Loop: Pulls from microtask ‚Üí then macro ‚Üí repeat. üß¨ Subtle Gotchas Promise.then always runs before setTimeout, even if setTimeout has 0ms delay. This is because microtask queue is prioritized over macro-task queue. 10.2 üß† Mental Models \u0026 Visuals üìä Timeline Diagram Time ‚Üí | Stack: log(\"Start\") ‚Üí log(\"End\") ‚Üí [Empty] | Microtask: ‚Üí Promise.then() ‚Üí [Empty] | Task: setTimeout() ‚Üí ‚Üí setTimeout() Output: Start End Promise 1 Timeout 1 üß© Stack‚ÄìHeap‚ÄìQueue Visualization ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ Call Stack ‚îÇ ‚Üê Runs synchronous code (one frame at a time) ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ Global Execution ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ Heap ‚îÇ ‚Üê Stores objects, closures, promises ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ Promise, callbacks‚Ä¶ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ Microtask Q ‚îÇ ‚Üê Promise callbacks (then, catch) ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ () =\u003e console.log‚Ä¶ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ Task Queue ‚îÇ ‚Üê Timers, UI events ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ ‚îÇ setTimeout cb‚Ä¶ ‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò üß≠ Cross-Realm \u0026 Agent Flowchart [ Window (Agent A) ] ‚îÇ ‚îú‚îÄ setTimeout() ‚Üí Task Queue ‚îú‚îÄ Promise.then() ‚Üí Microtask Queue ‚îú‚îÄ Web Worker (Agent B) ‚îÇ ‚îú‚îÄ Own Heap ‚îÇ ‚îú‚îÄ Own Stack ‚îÇ ‚îî‚îÄ Communicates via postMessage or SharedArrayBuffer ‚îÇ ‚îî‚îÄ iframe (Realm B, same agent) ‚îú‚îÄ Own GlobalThis ‚îî‚îÄ Shared Stack/Queue (if same-origin) üéØ Interview Insight If you truly understand this unified flow, you can:\nPredict async code output reliably. Avoid callback hell and race conditions. Understand Node.js concurrency patterns. Handle shared memory in web workers safely. ‚úÖ Final Thought JavaScript isn‚Äôt just ‚Äúsingle-threaded.‚Äù\nIt‚Äôs a coordinated choreography of:\nAgents (runners) Realms (universes) Heaps (long-term memory) Stacks (call trace) Queues (scheduling) Event loop (the director) Master this mental model, and you‚Äôre not just writing JS ‚Äî you‚Äôre orchestrating time.\n","wordCount":"6914","inLanguage":"en","image":"https://archit15singh.github.io/images/uploads/cosmic-timetraveler.webp","datePublished":"2022-07-29T12:00:00Z","dateModified":"2022-07-29T12:00:00Z","author":{"@type":"Person","name":"Archit Singh"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://archit15singh.github.io/posts/2022-07-29-js-execution-model-in-depth/"},"publisher":{"@type":"Organization","name":"Archit's Space","logo":{"@type":"ImageObject","url":"https://archit15singh.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://archit15singh.github.io/ accesskey=h title="Archit's Space (Alt + H)">Archit's Space</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://archit15singh.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://archit15singh.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://archit15singh.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://archit15singh.github.io/>Home</a>&nbsp;¬ª&nbsp;<a href=https://archit15singh.github.io/posts/>Posts</a></div><h1 class=post-title>How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive)</h1><div class=post-description>Explore how JavaScript code actually runs: from the engine and host environment to call stacks, queues, realms, agents, and async behavior ‚Äî explained with mental models, real code, and execution traces.</div><div class=post-meta><span title="2022-07-29 12:00:00 +0000 UTC">July 29, 2022</span>&nbsp;¬∑&nbsp;33 min</div></header><figure class=entry-cover><img loading=lazy src=https://archit15singh.github.io/images/uploads/cosmic-timetraveler.webp alt="JS deep dive"><p>JS deep dive</p></figure><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#how-javascript-really-runs-from-engines-to-event-loop-execution-model-deep-dive aria-label="How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive)">How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive)</a><ul><li><a href=#-what-this-series-will-teach-you aria-label="üöÄ What This Series Will Teach You">üöÄ What This Series Will Teach You</a></li><li><a href=#1--introduction-what-is-the-javascript-execution-model aria-label="1. üéØ Introduction: What is the JavaScript Execution Model?">1. üéØ Introduction: What is the JavaScript Execution Model?</a><ul><li><a href=#-so-what-is-it aria-label="üß† So‚Ä¶ what is it?">üß† So‚Ä¶ what <em>is</em> it?</a></li></ul></li><li><a href=#-why-should-developers-care aria-label="üß© Why should developers care?">üß© Why should developers care?</a></li><li><a href=#-spec-vs-reality-goals-of-the-execution-model aria-label="üÜö Spec vs Reality: Goals of the Execution Model">üÜö Spec vs Reality: Goals of the Execution Model</a></li><li><a href=#-real-world-metaphor-actor-stage-script aria-label="üé≠ Real-World Metaphor: Actor, Stage, Script">üé≠ Real-World Metaphor: Actor, Stage, Script</a></li><li><a href=#-2-core-architecture-of-javascript-runtime aria-label="üß© 2. Core Architecture of JavaScript Runtime">üß© 2. <strong>Core Architecture of JavaScript Runtime</strong></a><ul><li><a href=#-21-the-javascript-engine aria-label="üîπ 2.1. The JavaScript Engine">üîπ 2.1. <strong>The JavaScript Engine</strong></a><ul><li><a href=#-literal-meaning aria-label="‚úÖ Literal meaning:">‚úÖ Literal meaning:</a></li><li><a href=#-what-it-provides aria-label="üß† What it provides:">üß† What it provides:</a></li><li><a href=#-examples-of-engines aria-label="üõ† Examples of engines:">üõ† Examples of engines:</a></li><li><a href=#-mental-model aria-label="üß¨ Mental model:">üß¨ Mental model:</a></li></ul></li><li><a href=#-22-the-host-environment aria-label="üîπ 2.2. The Host Environment">üîπ 2.2. <strong>The Host Environment</strong></a><ul><li><a href=#-literal-meaning-1 aria-label="‚úÖ Literal meaning:">‚úÖ Literal meaning:</a></li><li><a href=#-common-host-environments aria-label="üåç Common host environments:">üåç Common host environments:</a></li><li><a href=#-host-provided-apis aria-label="üõ† Host-provided APIs:">üõ† Host-provided APIs:</a></li><li><a href=#-example aria-label="üíª Example:">üíª Example:</a></li><li><a href=#-real-world-analogy aria-label="üß¨ Real-world analogy:">üß¨ Real-world analogy:</a></li></ul></li><li><a href=#-23-engine-vs-host-division-of-concerns aria-label="üîπ 2.3. Engine vs Host: Division of Concerns">üîπ 2.3. <strong>Engine vs Host: Division of Concerns</strong></a><ul><li><a href=#-literal-meaning-2 aria-label="‚úÖ Literal meaning:">‚úÖ Literal meaning:</a></li><li><a href=#-why-this-matters aria-label="üß† Why this matters:">üß† Why this matters:</a></li><li><a href=#-code-comparison aria-label="üß™ Code Comparison:">üß™ Code Comparison:</a></li><li><a href=#-gotcha-why-does-js-code-fail-in-node-but-not-in-the-browser aria-label="‚ö†Ô∏è Gotcha: ‚ÄúWhy does JS code fail in Node but not in the browser?‚Äù">‚ö†Ô∏è Gotcha: ‚ÄúWhy does JS code fail in Node but not in the browser?‚Äù</a></li><li><a href=#-related-concept-polyfills-and-environment-detection aria-label="üîó Related Concept: Polyfills and Environment Detection">üîó Related Concept: <strong>Polyfills and Environment Detection</strong></a></li></ul></li><li><a href=#-tldr-mental-model aria-label="üß† TL;DR Mental Model">üß† TL;DR Mental Model</a></li><li><a href=#-summary-table aria-label="üß© Summary Table">üß© Summary Table</a></li></ul></li><li><a href=#3--agent-execution-model--the-secret-engine-behind-javascripts-run-time aria-label="3. üß† Agent Execution Model ‚Äî The Secret Engine Behind JavaScript‚Äôs Run-Time">3. üß† Agent Execution Model ‚Äî The Secret Engine Behind JavaScript‚Äôs Run-Time</a></li><li><a href=#31--what-is-an-agent aria-label="3.1 üöÄ What is an Agent?">3.1 üöÄ What is an Agent?</a><ul><li><a href=#-think-of-an-agent-as aria-label="üß† Think of an agent as:">üß† Think of an agent as:</a></li><li><a href=#-metaphor aria-label="üî¨ Metaphor:">üî¨ Metaphor:</a></li></ul></li><li><a href=#32--agent-data-structures-the-triad aria-label="3.2 ‚öôÔ∏è Agent Data Structures: The Triad">3.2 ‚öôÔ∏è Agent Data Structures: The Triad</a><ul><li><a href=#-1-heap aria-label="üß† 1. Heap">üß† 1. <strong>Heap</strong></a></li><li><a href=#-2-call-stack aria-label="üß† 2. Call Stack">üß† 2. <strong>Call Stack</strong></a></li><li><a href=#-3-jobtask-queue aria-label="üß† 3. Job/Task Queue">üß† 3. <strong>Job/Task Queue</strong></a></li><li><a href=#-all-together aria-label="üî¨ All Together:">üî¨ All Together:</a></li></ul></li><li><a href=#33--agent-lifecycle--how-code-actually-runs aria-label="3.3 ‚è≥ Agent Lifecycle ‚Äî How Code Actually Runs">3.3 ‚è≥ Agent Lifecycle ‚Äî How Code <em>Actually</em> Runs</a><ul><li><a href=#-step-1-a-job-begins aria-label="üîÑ Step 1: A Job Begins">üîÑ Step 1: A Job Begins</a></li><li><a href=#-step-2-stack-fills-up aria-label="üìà Step 2: Stack Fills Up">üìà Step 2: Stack Fills Up</a></li><li><a href=#-step-3-stack-empties aria-label="üìâ Step 3: Stack Empties">üìâ Step 3: Stack Empties</a></li><li><a href=#-step-4-idle-or-re-entry aria-label="üí§ Step 4: Idle or Re-entry">üí§ Step 4: Idle or Re-entry</a></li><li><a href=#-why-it-matters aria-label="üß† Why It Matters">üß† Why It Matters</a></li></ul></li><li><a href=#-bonus-multi-agent-systems aria-label="üí° Bonus: Multi-Agent Systems">üí° Bonus: Multi-Agent Systems</a></li><li><a href=#-recap-agent-model-mental-picture aria-label="‚úÖ Recap: Agent Model Mental Picture">‚úÖ Recap: Agent Model Mental Picture</a></li><li><a href=#-real-world-debugging-tip aria-label="‚ú® Real-World Debugging Tip">‚ú® Real-World Debugging Tip</a></li><li><a href=#4--execution-contexts--call-stack aria-label="4. üì¶ Execution Contexts & Call Stack">4. üì¶ <strong>Execution Contexts & Call Stack</strong></a><ul><li><a href=#41--what-is-an-execution-context aria-label="4.1. üß† What is an Execution Context?">4.1. üß† <strong>What is an Execution Context?</strong></a><ul><li><a href=#-it-contains aria-label="üîç It contains:">üîç It contains:</a></li><li><a href=#-mental-model-1 aria-label="üß¨ Mental Model:">üß¨ Mental Model:</a></li><li><a href=#-example-1 aria-label="üíª Example:">üíª Example:</a></li></ul></li><li><a href=#-lexical-environment aria-label="üß© Lexical Environment">üß© Lexical Environment</a><ul><li><a href=#-closures aria-label="üîÅ Closures:">üîÅ Closures:</a></li></ul></li><li><a href=#-realm-association aria-label="üåê Realm Association">üåê Realm Association</a><ul><li><a href=#-gotcha aria-label="‚ö†Ô∏è Gotcha:">‚ö†Ô∏è Gotcha:</a></li></ul></li><li><a href=#-this-arguments-and-bindings aria-label="‚öôÔ∏è this, arguments, and Bindings">‚öôÔ∏è <code>this</code>, <code>arguments</code>, and Bindings</a></li><li><a href=#42--function-invocation--stack-frames aria-label="4.2. üîÅ Function Invocation & Stack Frames">4.2. üîÅ <strong>Function Invocation & Stack Frames</strong></a><ul><li><a href=#-when-the-function-finishes aria-label="üì§ When the function finishes:">üì§ When the function finishes:</a></li><li><a href=#-code-trace aria-label="üíª Code Trace:">üíª Code Trace:</a></li><li><a href=#-key-behaviors aria-label="üéØ Key behaviors:">üéØ Key behaviors:</a></li></ul></li><li><a href=#-43-tail-call-optimization-tco aria-label="‚ö° 4.3. Tail Call Optimization (TCO)">‚ö° 4.3. <strong>Tail Call Optimization (TCO)</strong></a><ul><li><a href=#-benefits aria-label="üéØ Benefits:">üéØ Benefits:</a></li><li><a href=#-example-ideal-for-tco aria-label="üî• Example (ideal for TCO):">üî• Example (ideal for TCO):</a></li><li><a href=#-engine-support-caveats aria-label="‚ö†Ô∏è Engine Support Caveats:">‚ö†Ô∏è Engine Support Caveats:</a></li></ul></li><li><a href=#-summary-table-1 aria-label="üß† Summary Table">üß† Summary Table</a></li></ul></li><li><a href=#5--understanding-realms-the-hidden-worlds-of-javascript-execution aria-label="5. üåÄ Understanding Realms: The Hidden Worlds of JavaScript Execution">5. üåÄ Understanding Realms: The Hidden Worlds of JavaScript Execution</a></li><li><a href=#-what-is-a-realm aria-label="üì¶ What Is a Realm?">üì¶ What Is a Realm?</a><ul><li><a href=#-mental-model-2 aria-label="üß† Mental Model:">üß† Mental Model:</a></li><li><a href=#-real-world-examples aria-label="üí° Real-World Examples:">üí° Real-World Examples:</a></li></ul></li><li><a href=#-realm-internals aria-label="üî¨ Realm Internals">üî¨ Realm Internals</a><ul><li><a href=#1--intrinsic-objects aria-label="1. üß¨ Intrinsic Objects">1. üß¨ Intrinsic Objects</a></li><li><a href=#-gotcha-instanceof-fails-across-realms aria-label="‚ö†Ô∏è Gotcha: instanceof fails across realms">‚ö†Ô∏è Gotcha: <code>instanceof</code> fails across realms</a></li><li><a href=#2--global-object-and-globalthis aria-label="2. ü™ê Global Object and globalThis">2. ü™ê Global Object and <code>globalThis</code></a></li><li><a href=#3--template-literal-cache aria-label="3. üß† Template Literal Cache">3. üß† Template Literal Cache</a></li></ul></li><li><a href=#-realms-vs-agents aria-label="üß© Realms vs Agents">üß© Realms vs Agents</a><ul><li><a href=#-realms-can-talk-if-in-same-agent aria-label="üîÅ Realms Can Talk (if in same agent)">üîÅ Realms Can Talk (if in same agent)</a></li></ul></li><li><a href=#-why-realms-matter-in-the-real-world aria-label="üîê Why Realms Matter in the Real World">üîê Why Realms Matter in the Real World</a><ul><li><a href=#1-security-and-isolation aria-label="1. Security and Isolation">1. <strong>Security and Isolation</strong></a></li><li><a href=#2-framework--testing-tooling aria-label="2. Framework & Testing Tooling">2. <strong>Framework & Testing Tooling</strong></a></li><li><a href=#3-micro-frontend-architecture aria-label="3. Micro-frontend Architecture">3. <strong>Micro-frontend Architecture</strong></a></li><li><a href=#4-cross-realm-bugs aria-label="4. Cross-Realm Bugs">4. <strong>Cross-Realm Bugs</strong></a></li></ul></li><li><a href=#-takeaways aria-label="üß† Takeaways">üß† Takeaways</a></li><li><a href=#-bonus-shadowrealm-tc39-stage-3 aria-label="üìå Bonus: ShadowRealm (TC39 Stage 3)">üìå Bonus: ShadowRealm (TC39 Stage 3)</a></li><li><a href=#-final-word aria-label="‚úçÔ∏è Final Word">‚úçÔ∏è Final Word</a></li><li><a href=#6--agent-types-in-the-web-platform aria-label="6. üåê Agent Types in the Web Platform">6. üåê <strong>Agent Types in the Web Platform</strong></a><ul><li><a href=#61-main-window-agent aria-label="6.1. Main Window Agent">6.1. Main Window Agent</a></li><li><a href=#62-dedicated-worker-agent aria-label="6.2. Dedicated Worker Agent">6.2. Dedicated Worker Agent</a></li><li><a href=#63-shared-worker-agent aria-label="6.3. Shared Worker Agent">6.3. Shared Worker Agent</a></li><li><a href=#64-service-worker-agent aria-label="6.4. Service Worker Agent">6.4. Service Worker Agent</a></li><li><a href=#65-worklet-agent aria-label="6.5. Worklet Agent">6.5. Worklet Agent</a></li></ul></li><li><a href=#6--agent-types-in-the-web-platform-1 aria-label="6. üåê Agent Types in the Web Platform">6. üåê <strong>Agent Types in the Web Platform</strong></a><ul><li><a href=#61--main-window-agent aria-label="6.1 ü™ü Main Window Agent">6.1 ü™ü <strong>Main Window Agent</strong></a></li><li><a href=#62--dedicated-worker-agent aria-label="6.2 üë∑ Dedicated Worker Agent">6.2 üë∑ <strong>Dedicated Worker Agent</strong></a></li><li><a href=#63--shared-worker-agent aria-label="6.3 ü§ù Shared Worker Agent">6.3 ü§ù <strong>Shared Worker Agent</strong></a></li><li><a href=#64--service-worker-agent aria-label="6.4 üõ∞ Service Worker Agent">6.4 üõ∞ <strong>Service Worker Agent</strong></a></li><li><a href=#65--worklet-agent aria-label="6.5 üé® Worklet Agent">6.5 üé® <strong>Worklet Agent</strong></a></li><li><a href=#-all-agent-types-have aria-label="üß¨ All Agent Types Have:">üß¨ All Agent Types Have:</a></li><li><a href=#-summary-table-2 aria-label="üß† Summary Table">üß† Summary Table</a></li><li><a href=#-related-concepts aria-label="üîó Related Concepts:">üîó Related Concepts:</a></li></ul></li><li><a href=#7--job-queue--event-loop aria-label="7. üîÅ Job Queue & Event Loop">7. üîÅ <strong>Job Queue & Event Loop</strong></a><ul><li><a href=#71--what-is-a-job aria-label="7.1 üîß What is a Job?">7.1 üîß What is a Job?</a></li><li><a href=#72--event-loop-the-scheduler-in-chief aria-label="7.2 üîÑ Event Loop: The Scheduler-in-Chief">7.2 üîÑ Event Loop: The Scheduler-in-Chief</a></li><li><a href=#73--microtasks-vs-macrotasks aria-label="7.3 ‚öñÔ∏è Microtasks vs Macrotasks">7.3 ‚öñÔ∏è Microtasks vs Macrotasks</a></li><li><a href=#74--blocking-vs-non-blocking aria-label="7.4 üßµ Blocking vs Non-Blocking">7.4 üßµ Blocking vs Non-Blocking</a></li><li><a href=#-final-mental-model aria-label="üí° Final Mental Model">üí° Final Mental Model</a></li></ul></li><li><a href=#8--concurrency--memory-sharing aria-label="8. üß† Concurrency & Memory Sharing">8. üß† <strong>Concurrency & Memory Sharing</strong></a><ul><li><a href=#81--agent-clusters-who-can-share-memory-with-whom aria-label="8.1 ‚ö° Agent Clusters: Who Can Share Memory with Whom?">8.1 ‚ö° <strong>Agent Clusters: Who Can Share Memory with Whom?</strong></a><ul><li><a href=#-in-the-same-cluster-can-share-memory aria-label="‚úÖ In the Same Cluster (can share memory):">‚úÖ In the Same Cluster (can share memory):</a></li><li><a href=#-different-clusters-cant-share-memory aria-label="‚ùå Different Clusters (can‚Äôt share memory):">‚ùå Different Clusters (can‚Äôt share memory):</a></li></ul></li><li><a href=#82--shared-memory-with-sharedarraybuffer aria-label="8.2 üß† Shared Memory with SharedArrayBuffer">8.2 üß† <strong>Shared Memory with SharedArrayBuffer</strong></a><ul><li><a href=#-how-it-works aria-label="üîó How It Works:">üîó How It Works:</a></li></ul></li><li><a href=#83--synchronizing-with-atomics aria-label="8.3 üîí Synchronizing with Atomics">8.3 üîí <strong>Synchronizing with Atomics</strong></a><ul><li><a href=#-tools-in-the-atomics-toolbox aria-label="üõ† Tools in the Atomics toolbox:">üõ† Tools in the <code>Atomics</code> toolbox:</a></li></ul></li><li><a href=#84--memory-consistency-and-data-races aria-label="8.4 üìè Memory Consistency and Data Races">8.4 üìè <strong>Memory Consistency and Data Races</strong></a><ul><li><a href=#-whats-a-data-race aria-label="‚ö†Ô∏è What‚Äôs a Data Race?">‚ö†Ô∏è What‚Äôs a Data Race?</a></li><li><a href=#-example-of-value-tearing aria-label="üß™ Example of value tearing:">üß™ Example of value tearing:</a></li><li><a href=#-rule-of-thumb aria-label="üîí Rule of Thumb:">üîí Rule of Thumb:</a></li></ul></li><li><a href=#-why-this-matters-1 aria-label="üß† Why This Matters">üß† Why This Matters</a></li><li><a href=#-in-summary aria-label="üì¶ In Summary">üì¶ In Summary</a></li><li><a href=#-final-thought aria-label="üí≠ Final Thought">üí≠ Final Thought</a></li></ul></li><li><a href=#9--cluster-lifecycle--blocking aria-label="9. üöß Cluster Lifecycle & Blocking">9. üöß Cluster Lifecycle & Blocking</a><ul><li><a href=#91--blocking-apis-atomicswait aria-label="9.1. üß± Blocking APIs (Atomics.wait)">9.1. üß± Blocking APIs (<code>Atomics.wait</code>)</a><ul><li><a href=#-what-does-blocking-actually-mean-in-javascript aria-label="üß† What does &ldquo;blocking&rdquo; actually mean in JavaScript?">üß† What does &ldquo;blocking&rdquo; <em>actually</em> mean in JavaScript?</a></li><li><a href=#-promise--async-yield aria-label="‚úÖ Promise = async yield">‚úÖ Promise = async yield</a></li><li><a href=#-atomicswait--sync-block aria-label="‚ùå Atomics.wait = sync block">‚ùå Atomics.wait = sync block</a></li></ul></li><li><a href=#92--forward-progress-guarantees aria-label="9.2. üõ° Forward Progress Guarantees">9.2. üõ° Forward Progress Guarantees</a><ul><li><a href=#-fairness-by-design aria-label="üí° Fairness by design:">üí° Fairness by design:</a></li><li><a href=#-why-this-matters-2 aria-label="üì¶ Why this matters:">üì¶ Why this matters:</a></li></ul></li><li><a href=#93--agent-termination-the-cluster-is-a-single-failure-domain aria-label="9.3. üí• Agent Termination: The Cluster Is a Single Failure Domain">9.3. üí• Agent Termination: The Cluster Is a Single Failure Domain</a><ul><li><a href=#-if-agents-share-memory-theyre-in-the-same-cluster aria-label="‚úÖ If agents share memory, they‚Äôre in the same cluster.">‚úÖ If agents share memory, they‚Äôre in the same cluster.</a></li><li><a href=#-if-one-crashes-they-all-go-down aria-label="üî• If one crashes, they all go down.">üî• If one crashes, they <em>all</em> go down.</a></li><li><a href=#-what-about-fault-tolerance aria-label="üß™ What about fault-tolerance?">üß™ What about fault-tolerance?</a></li></ul></li></ul></li><li><a href=#-takeaways-for-system-builders aria-label="‚ö†Ô∏è Takeaways for System Builders">‚ö†Ô∏è Takeaways for System Builders</a></li><li><a href=#-10-putting-it-all-together aria-label="üîó 10. Putting It All Together">üîó 10. <strong>Putting It All Together</strong></a><ul><li><a href=#-why-this-section-matters aria-label="üéØ Why this section matters:">üéØ Why this section matters:</a></li><li><a href=#101--full-execution-trace aria-label="10.1 ‚öôÔ∏è Full Execution Trace">10.1 ‚öôÔ∏è <strong>Full Execution Trace</strong></a><ul><li><a href=#-code-example aria-label="üíª Code Example:">üíª Code Example:</a></li></ul></li><li><a href=#-execution-timeline aria-label="üîÅ Execution Timeline">üîÅ Execution Timeline</a></li><li><a href=#-metaphor-1 aria-label="üß† Metaphor:">üß† Metaphor:</a></li><li><a href=#-connections aria-label="üîó Connections">üîó Connections</a></li><li><a href=#-subtle-gotchas aria-label="üß¨ Subtle Gotchas">üß¨ Subtle Gotchas</a></li><li><a href=#102--mental-models--visuals aria-label="10.2 üß† Mental Models & Visuals">10.2 üß† <strong>Mental Models & Visuals</strong></a></li><li><a href=#-timeline-diagram aria-label="üìä Timeline Diagram">üìä Timeline Diagram</a></li><li><a href=#-stackheapqueue-visualization aria-label="üß© Stack‚ÄìHeap‚ÄìQueue Visualization">üß© Stack‚ÄìHeap‚ÄìQueue Visualization</a></li><li><a href=#-cross-realm--agent-flowchart aria-label="üß≠ Cross-Realm & Agent Flowchart">üß≠ Cross-Realm & Agent Flowchart</a></li><li><a href=#-interview-insight aria-label="üéØ Interview Insight">üéØ Interview Insight</a></li></ul></li><li><a href=#-final-thought-1 aria-label="‚úÖ Final Thought">‚úÖ Final Thought</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=how-javascript-really-runs-from-engines-to-event-loop-execution-model-deep-dive>How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive)<a hidden class=anchor aria-hidden=true href=#how-javascript-really-runs-from-engines-to-event-loop-execution-model-deep-dive>#</a></h1><hr><h2 id=-what-this-series-will-teach-you>üöÄ What This Series Will Teach You<a hidden class=anchor aria-hidden=true href=#-what-this-series-will-teach-you>#</a></h2><p>This blog post is the first step of a <strong>multi-part deep dive</strong> into the JS execution model. You‚Äôll learn:</p><ul><li>How JavaScript handles synchronous and asynchronous code</li><li>What the call stack, job queue, microtasks, and event loop really are</li><li>How realms, agents, and execution contexts work together</li><li>How engines like V8 optimize while staying spec-compliant</li><li>Why seemingly simple code can behave unexpectedly ‚Äî and how to reason through it</li></ul><p>Each section will build your mental model ‚Äî with visuals, real code traces, intuitive metaphors, and runtime behavior breakdowns.</p><blockquote><p>üìå Whether you&rsquo;re building a single-page app, debugging race conditions, or writing high-performance server-side JS ‚Äî knowing <em>how JS really runs</em> is your ultimate superpower.</p></blockquote><hr><h2 id=1--introduction-what-is-the-javascript-execution-model>1. üéØ Introduction: What is the JavaScript Execution Model?<a hidden class=anchor aria-hidden=true href=#1--introduction-what-is-the-javascript-execution-model>#</a></h2><p>JavaScript might <em>look</em> simple ‚Äî you write <code>let x = 10</code>, it runs. You call a function, it executes. But under the hood, a sophisticated system choreographs every line you write. That system is called the <strong>JavaScript execution model</strong>.</p><h3 id=-so-what-is-it>üß† So‚Ä¶ what <em>is</em> it?<a hidden class=anchor aria-hidden=true href=#-so-what-is-it>#</a></h3><p>At its core, the JavaScript execution model defines <strong>how JavaScript code runs</strong>:</p><ul><li>How the engine interprets your code</li><li>How memory is allocated and freed</li><li>How functions get stacked and unstacked</li><li>How asynchronous code (like <code>setTimeout</code> or <code>fetch</code>) is managed</li><li>How multiple ‚Äúthreads‚Äù (agents) interact ‚Äî or don‚Äôt</li></ul><p>It‚Äôs like the <strong>operating system of JavaScript</strong> ‚Äî the abstract machine that governs how your code behaves, step-by-step.</p><hr><h2 id=-why-should-developers-care>üß© Why should developers care?<a hidden class=anchor aria-hidden=true href=#-why-should-developers-care>#</a></h2><p>You don‚Äôt need to know every VM optimization trick to write JavaScript‚Ä¶<br>But if you want to:</p><ul><li><strong>Fix timing bugs</strong></li><li><strong>Master Promises, async/await, and the event loop</strong></li><li><strong>Avoid race conditions and memory leaks</strong></li><li><strong>Write responsive apps that never freeze the UI</strong></li><li><strong>Debug async issues like ‚ÄúWhy does this log after that?‚Äù</strong></li></ul><p>&mldr;then understanding the execution model isn&rsquo;t optional ‚Äî it‚Äôs essential.</p><p>It‚Äôs the foundation beneath everything from simple loops to complex front-end architectures to performance-critical backends.</p><hr><h2 id=-spec-vs-reality-goals-of-the-execution-model>üÜö Spec vs Reality: Goals of the Execution Model<a hidden class=anchor aria-hidden=true href=#-spec-vs-reality-goals-of-the-execution-model>#</a></h2><p>The <strong>ECMAScript specification</strong> (the official language definition) defines the execution model in a <strong>platform-neutral</strong>, abstract way.</p><p>This spec outlines the <strong>rules all JavaScript engines must follow</strong>, regardless of environment:</p><ul><li>Browsers (Chrome/V8, Firefox/SpiderMonkey, Safari/JavaScriptCore)</li><li>Servers (Node.js, Deno)</li><li>Embedded runtimes (e.g. IoT devices)</li></ul><p>However, <strong>real engines are free to optimize</strong> ‚Äî just like how chess players can use different tactics, but must follow the same rules.</p><p>For example:</p><ul><li>V8 (Chrome/Node.js) uses Just-In-Time (JIT) compilation, inline caching, and memory optimizations.</li><li>But it still follows the logical model the spec describes: same rules, different execution speed.</li></ul><blockquote><p>üí° <strong>TL;DR</strong>: The spec defines <em>what must happen</em>, not <em>how fast</em> or <em>how exactly</em> an engine does it.</p></blockquote><hr><h2 id=-real-world-metaphor-actor-stage-script>üé≠ Real-World Metaphor: Actor, Stage, Script<a hidden class=anchor aria-hidden=true href=#-real-world-metaphor-actor-stage-script>#</a></h2><p>Let‚Äôs break it down with a metaphor:</p><ul><li><strong>Your code</strong> = the <em>script</em></li><li><strong>The JavaScript engine</strong> = the <em>actor</em></li><li><strong>The host environment (browser, Node)</strong> = the <em>stage, lighting, props, audience</em></li><li><strong>The execution model</strong> = the <em>stage manager</em> ‚Äî orchestrating who enters when, what lines are spoken, and how long each actor gets to perform</li></ul><p>The actor (engine) can‚Äôt improvise wildly ‚Äî it must follow the script (your code) ‚Äî but the stage manager decides when scenes start, what props are ready, and how long each act lasts.</p><p>And just like in theater: no actor can speak two lines at the same time. JavaScript, too, is single-threaded ‚Äî one line at a time, unless you start spinning off background actors (Web Workers, Service Workers).</p><hr><h2 id=-2-core-architecture-of-javascript-runtime>üß© 2. <strong>Core Architecture of JavaScript Runtime</strong><a hidden class=anchor aria-hidden=true href=#-2-core-architecture-of-javascript-runtime>#</a></h2><p>To understand <em>how</em> JavaScript runs your code, we need to dissect <strong>what components make up the JS runtime</strong>.<br>At the core, JavaScript doesn&rsquo;t run in a vacuum ‚Äî it needs an <strong>engine</strong> to interpret the code, and a <strong>host environment</strong> to provide real-world capabilities like networking, timers, and file access.</p><p>Let‚Äôs peel this layer by layer.</p><hr><h3 id=-21-the-javascript-engine>üîπ 2.1. <strong>The JavaScript Engine</strong><a hidden class=anchor aria-hidden=true href=#-21-the-javascript-engine>#</a></h3><h4 id=-literal-meaning>‚úÖ Literal meaning:<a hidden class=anchor aria-hidden=true href=#-literal-meaning>#</a></h4><p>The <strong>engine</strong> is the heart of the JavaScript runtime. It&rsquo;s the software that understands and executes ECMAScript ‚Äî the official JavaScript language specification.</p><h4 id=-what-it-provides>üß† What it provides:<a hidden class=anchor aria-hidden=true href=#-what-it-provides>#</a></h4><ul><li><strong>Parsing</strong>: Reads and interprets JS source code (e.g., turns <code>function foo() {}</code> into a syntax tree).</li><li><strong>Execution</strong>: Runs your code step-by-step, managing memory, stack, scopes, etc.</li><li><strong>Optimization</strong>: Applies techniques like JIT (Just-In-Time) compilation, inline caching, dead code elimination for speed.</li></ul><h4 id=-examples-of-engines>üõ† Examples of engines:<a hidden class=anchor aria-hidden=true href=#-examples-of-engines>#</a></h4><ul><li><strong>V8</strong> (Chrome, Node.js)</li><li><strong>SpiderMonkey</strong> (Firefox)</li><li><strong>JavaScriptCore</strong> (Safari)</li><li><strong>Chakra</strong> (deprecated, formerly in Edge)</li></ul><h4 id=-mental-model>üß¨ Mental model:<a hidden class=anchor aria-hidden=true href=#-mental-model>#</a></h4><p>Think of the engine like a <strong>brain</strong> that knows how to read JavaScript, understand it, and run it ‚Äî but it‚Äôs stuck in a box. It can&rsquo;t talk to the outside world unless someone wires it up.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// This is purely engine territory:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>x</span> <span class=o>=</span> <span class=mi>5</span> <span class=o>+</span> <span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>doubled</span> <span class=o>=</span> <span class=nx>x</span> <span class=o>*</span> <span class=mi>2</span><span class=p>;</span>
</span></span></code></pre></div><p>No DOM. No timers. No file I/O. Just language-level stuff.</p><hr><h3 id=-22-the-host-environment>üîπ 2.2. <strong>The Host Environment</strong><a hidden class=anchor aria-hidden=true href=#-22-the-host-environment>#</a></h3><h4 id=-literal-meaning-1>‚úÖ Literal meaning:<a hidden class=anchor aria-hidden=true href=#-literal-meaning-1>#</a></h4><p>This is the <strong>external system</strong> embedding the JS engine.<br>It provides <strong>platform-specific APIs</strong> and functionalities that the engine alone cannot offer.</p><h4 id=-common-host-environments>üåç Common host environments:<a hidden class=anchor aria-hidden=true href=#-common-host-environments>#</a></h4><ul><li><strong>Web browsers</strong>: Chrome, Firefox, Safari</li><li><strong>Node.js</strong>: Server-side JS runtime</li><li><strong>Deno</strong>: Secure, modern runtime for JS/TS</li><li><strong>React Native</strong>: JS inside mobile apps</li><li><strong>Adobe After Effects</strong>: JS for scripting animation!</li></ul><h4 id=-host-provided-apis>üõ† Host-provided APIs:<a hidden class=anchor aria-hidden=true href=#-host-provided-apis>#</a></h4><p>These aren‚Äôt part of the JS language ‚Äî they‚Äôre provided by the host:</p><table><thead><tr><th>API / Feature</th><th>Provided by</th></tr></thead><tbody><tr><td><code>setTimeout()</code></td><td>Browser / Node</td></tr><tr><td><code>document.querySelector()</code></td><td>Browser</td></tr><tr><td><code>fs.readFile()</code></td><td>Node.js</td></tr><tr><td><code>fetch()</code></td><td>Browser / Node (polyfilled)</td></tr><tr><td><code>postMessage()</code></td><td>Web Worker context</td></tr><tr><td><code>navigator.geolocation</code></td><td>Browser</td></tr></tbody></table><h4 id=-example>üíª Example:<a hidden class=anchor aria-hidden=true href=#-example>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Hello&#34;</span><span class=p>);</span> <span class=c1>// Host provides the &#39;console&#39; object
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>alert</span><span class=p>(</span><span class=s2>&#34;Hi&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>},</span> <span class=mi>1000</span><span class=p>);</span> <span class=c1>// &#39;setTimeout&#39; is NOT part of JS ‚Äî it&#39;s host API
</span></span></span></code></pre></div><h4 id=-real-world-analogy>üß¨ Real-world analogy:<a hidden class=anchor aria-hidden=true href=#-real-world-analogy>#</a></h4><ul><li>The <strong>JS engine</strong> is the <strong>actor</strong>.</li><li>The <strong>host environment</strong> is the <strong>stage</strong>, <strong>lighting</strong>, <strong>props</strong>, and <strong>audience</strong>.</li></ul><p>The actor can memorize lines (JavaScript), but can&rsquo;t <strong>do</strong> anything ‚Äî like turn on a spotlight or play sound ‚Äî unless the stage supports it.</p><hr><h3 id=-23-engine-vs-host-division-of-concerns>üîπ 2.3. <strong>Engine vs Host: Division of Concerns</strong><a hidden class=anchor aria-hidden=true href=#-23-engine-vs-host-division-of-concerns>#</a></h3><h4 id=-literal-meaning-2>‚úÖ Literal meaning:<a hidden class=anchor aria-hidden=true href=#-literal-meaning-2>#</a></h4><p>JavaScript engines and host environments play <strong>distinct but collaborative roles</strong>.</p><table><thead><tr><th>Concern</th><th>Handled by</th></tr></thead><tbody><tr><td><code>let</code>, <code>const</code>, <code>class</code>, <code>=></code></td><td>JavaScript Engine</td></tr><tr><td><code>console.log</code>, <code>setTimeout</code></td><td>Host Environment</td></tr><tr><td><code>document.getElementById</code></td><td>Host (Browser)</td></tr><tr><td><code>fs.readFileSync</code></td><td>Host (Node.js)</td></tr></tbody></table><h4 id=-why-this-matters>üß† Why this matters:<a hidden class=anchor aria-hidden=true href=#-why-this-matters>#</a></h4><ul><li>JavaScript <strong>isn‚Äôt ‚Äúbrowser-only‚Äù</strong> ‚Äî it‚Äôs a language, not a platform.</li><li>This is why you can run JS in:<ul><li>a browser (with DOM),</li><li>a server (Node.js),</li><li>an embedded device (e.g. Espruino),</li><li>or even in a text editor plugin (VS Code extensions).</li></ul></li></ul><p>Each context offers <strong>different tools</strong> ‚Äî but the <strong>engine stays the same</strong>.</p><hr><h4 id=-code-comparison>üß™ Code Comparison:<a hidden class=anchor aria-hidden=true href=#-code-comparison>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// Runs in browser
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Hi&#34;</span><span class=p>),</span> <span class=mi>1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nb>document</span><span class=p>.</span><span class=nx>body</span><span class=p>.</span><span class=nx>style</span><span class=p>.</span><span class=nx>background</span> <span class=o>=</span> <span class=s2>&#34;black&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Runs in Node
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Hi&#34;</span><span class=p>),</span> <span class=mi>1000</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>fs</span> <span class=o>=</span> <span class=nx>require</span><span class=p>(</span><span class=s2>&#34;fs&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>fs</span><span class=p>.</span><span class=nx>readFileSync</span><span class=p>(</span><span class=s2>&#34;./file.txt&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>Same JS engine (V8), totally different <strong>capabilities</strong>, because of the host.</p><hr><h4 id=-gotcha-why-does-js-code-fail-in-node-but-not-in-the-browser>‚ö†Ô∏è Gotcha: ‚ÄúWhy does JS code fail in Node but not in the browser?‚Äù<a hidden class=anchor aria-hidden=true href=#-gotcha-why-does-js-code-fail-in-node-but-not-in-the-browser>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// This fails in Node.js:
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>document</span><span class=p>.</span><span class=nx>getElementById</span><span class=p>(</span><span class=s2>&#34;app&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p>Because <code>document</code> is a <strong>host-provided object</strong>, and Node doesn‚Äôt include a DOM.</p><blockquote><p>üí° Same JavaScript. Different host. Different powers.</p></blockquote><hr><h4 id=-related-concept-polyfills-and-environment-detection>üîó Related Concept: <strong>Polyfills and Environment Detection</strong><a hidden class=anchor aria-hidden=true href=#-related-concept-polyfills-and-environment-detection>#</a></h4><p>Because hosts vary:</p><ul><li>We need <strong>feature detection</strong> (<code>typeof window</code>, <code>if ('fetch' in globalThis)</code>)</li><li>We write <strong>polyfills</strong> (e.g., implement <code>fetch</code> in Node if it‚Äôs missing)</li></ul><hr><h3 id=-tldr-mental-model>üß† TL;DR Mental Model<a hidden class=anchor aria-hidden=true href=#-tldr-mental-model>#</a></h3><table><thead><tr><th>Layer</th><th>Role</th></tr></thead><tbody><tr><td>JavaScript Engine</td><td>Understands and executes ECMAScript code</td></tr><tr><td>Host Environment</td><td>Provides platform-specific capabilities</td></tr><tr><td>JS Runtime</td><td>Combination of engine + host (aka ‚ÄúJS in the wild‚Äù)</td></tr></tbody></table><hr><h3 id=-summary-table>üß© Summary Table<a hidden class=anchor aria-hidden=true href=#-summary-table>#</a></h3><table><thead><tr><th>Concept</th><th>Engine or Host?</th><th>Example</th></tr></thead><tbody><tr><td><code>Promise</code>, <code>Map</code></td><td>Engine</td><td>ECMAScript features</td></tr><tr><td><code>setTimeout()</code></td><td>Host</td><td>Timer API (browser/Node)</td></tr><tr><td><code>document</code></td><td>Host (Browser)</td><td>Web page interaction</td></tr><tr><td><code>fs</code></td><td>Host (Node.js)</td><td>File system access</td></tr><tr><td><code>console</code></td><td>Host</td><td>Logging (defined per host)</td></tr><tr><td><code>function</code>, <code>=></code></td><td>Engine</td><td>Language-level syntax</td></tr></tbody></table><hr><h2 id=3--agent-execution-model--the-secret-engine-behind-javascripts-run-time>3. üß† Agent Execution Model ‚Äî The Secret Engine Behind JavaScript‚Äôs Run-Time<a hidden class=anchor aria-hidden=true href=#3--agent-execution-model--the-secret-engine-behind-javascripts-run-time>#</a></h2><p>JavaScript may <em>look</em> like a language, but it <strong>runs</strong> like a machine. Under the hood, every line of your JavaScript code is managed by a tiny execution engine called an <strong>agent</strong>.</p><p>Let‚Äôs crack open the hood and understand:</p><ul><li>What an <strong>agent</strong> actually is</li><li>The key <strong>data structures</strong> that power it</li><li>The <strong>lifecycle</strong> that makes async, generators, and tasks tick</li></ul><hr><h2 id=31--what-is-an-agent>3.1 üöÄ What is an Agent?<a hidden class=anchor aria-hidden=true href=#31--what-is-an-agent>#</a></h2><p>In the JavaScript spec, an <strong>agent</strong> is a self-contained execution environment ‚Äî like a virtual CPU.</p><ul><li>It has its <strong>own memory (heap)</strong></li><li>Its own <strong>call stack</strong></li><li>Its own <strong>event/job queue</strong></li></ul><p>If you&rsquo;re running JavaScript in a browser tab, that&rsquo;s an agent.<br>If you&rsquo;re running a Web Worker, that‚Äôs <strong>another agent</strong>.<br>Each agent is <strong>isolated</strong> from the others (unless explicitly connected via <code>SharedArrayBuffer</code>).</p><h3 id=-think-of-an-agent-as>üß† Think of an agent as:<a hidden class=anchor aria-hidden=true href=#-think-of-an-agent-as>#</a></h3><blockquote><p>A single <strong>thread of execution</strong> with all the gears it needs to process JavaScript independently.</p></blockquote><h3 id=-metaphor>üî¨ Metaphor:<a hidden class=anchor aria-hidden=true href=#-metaphor>#</a></h3><p>If your code is a cooking recipe, an <strong>agent</strong> is the chef executing it ‚Äî with its own kitchen, ingredients, and clipboard of instructions.</p><hr><h2 id=32--agent-data-structures-the-triad>3.2 ‚öôÔ∏è Agent Data Structures: The Triad<a hidden class=anchor aria-hidden=true href=#32--agent-data-structures-the-triad>#</a></h2><p>Every agent internally runs three major data structures ‚Äî the holy trinity of JS execution:</p><h3 id=-1-heap>üß† 1. <strong>Heap</strong><a hidden class=anchor aria-hidden=true href=#-1-heap>#</a></h3><blockquote><p>üì¶ Where objects and functions live ‚Äî long-term storage.</p></blockquote><ul><li>Every time you create an object (<code>{}</code>), array (<code>[]</code>), or function, it‚Äôs allocated on the <strong>heap</strong>.</li><li>Think of the heap as your <strong>warehouse of live objects</strong>.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>user</span> <span class=o>=</span> <span class=p>{</span> <span class=nx>name</span><span class=o>:</span> <span class=s2>&#34;Ada&#34;</span> <span class=p>};</span> <span class=c1>// lives in the heap
</span></span></span></code></pre></div><p>This is <strong>unstructured memory</strong> ‚Äî managed automatically by the garbage collector.</p><hr><h3 id=-2-call-stack>üß† 2. <strong>Call Stack</strong><a hidden class=anchor aria-hidden=true href=#-2-call-stack>#</a></h3><blockquote><p>üßæ Where functions are executed, tracked, and returned ‚Äî one frame at a time.</p></blockquote><ul><li>JavaScript uses a <strong>stack</strong> (LIFO) to manage <strong>function calls</strong>.</li><li>Each function call creates an <strong>execution context</strong> (aka stack frame).</li><li>When a function finishes, the frame is <strong>popped off</strong>.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>outer</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>inner</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>inner</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Hi&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>outer</span><span class=p>();</span>
</span></span></code></pre></div><p><strong>Stack:</strong></p><ol><li><code>outer()</code></li><li><code>inner()</code></li><li><code>console.log(...)</code></li><li>Return, return, done ‚úÖ</li></ol><p>üî¨ Metaphor: Like opening nested boxes. You can‚Äôt close box A until you‚Äôve closed box B inside it.</p><hr><h3 id=-3-jobtask-queue>üß† 3. <strong>Job/Task Queue</strong><a hidden class=anchor aria-hidden=true href=#-3-jobtask-queue>#</a></h3><blockquote><p>üïì A FIFO queue of pending <strong>asynchronous callbacks</strong> to run when the stack is empty.</p></blockquote><ul><li>Used by async actions: <code>setTimeout</code>, <code>fetch</code>, Promises</li><li>Part of the <strong>event loop</strong> mechanism</li><li>Each ‚Äújob‚Äù is a callback waiting to be pulled onto the stack</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;A&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;B&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;C&#34;</span><span class=p>);</span>
</span></span></code></pre></div><p><strong>Output:</strong> A ‚Üí C ‚Üí B<br>Because <code>setTimeout</code> schedules <code>B</code> on the <strong>task queue</strong>, which runs after the current stack empties.</p><hr><h3 id=-all-together>üî¨ All Together:<a hidden class=anchor aria-hidden=true href=#-all-together>#</a></h3><table><thead><tr><th>Structure</th><th>Type</th><th>Role</th></tr></thead><tbody><tr><td><strong>Heap</strong></td><td>Memory</td><td>Stores all objects, functions</td></tr><tr><td><strong>Stack</strong></td><td>LIFO</td><td>Tracks current function calls</td></tr><tr><td><strong>Queue</strong></td><td>FIFO</td><td>Stores async jobs to run next</td></tr></tbody></table><hr><h2 id=33--agent-lifecycle--how-code-actually-runs>3.3 ‚è≥ Agent Lifecycle ‚Äî How Code <em>Actually</em> Runs<a hidden class=anchor aria-hidden=true href=#33--agent-lifecycle--how-code-actually-runs>#</a></h2><p>The life of a JavaScript agent is a predictable cycle:</p><hr><h3 id=-step-1-a-job-begins>üîÑ Step 1: A Job Begins<a hidden class=anchor aria-hidden=true href=#-step-1-a-job-begins>#</a></h3><ul><li>A new <strong>job</strong> is pulled from the <strong>queue</strong> (e.g., a <code>setTimeout</code> callback)</li><li>A <strong>new execution context</strong> is pushed onto the <strong>stack</strong></li><li>JS starts running the code in that callback</li></ul><hr><h3 id=-step-2-stack-fills-up>üìà Step 2: Stack Fills Up<a hidden class=anchor aria-hidden=true href=#-step-2-stack-fills-up>#</a></h3><ul><li>The function may call other functions</li><li>More execution contexts are added</li><li>The <strong>call stack grows</strong></li></ul><hr><h3 id=-step-3-stack-empties>üìâ Step 3: Stack Empties<a hidden class=anchor aria-hidden=true href=#-step-3-stack-empties>#</a></h3><ul><li>Each function finishes and returns</li><li>The stack <strong>pops</strong> back down to empty</li><li>Once empty, the agent picks the <strong>next job</strong> from the queue</li></ul><hr><h3 id=-step-4-idle-or-re-entry>üí§ Step 4: Idle or Re-entry<a hidden class=anchor aria-hidden=true href=#-step-4-idle-or-re-entry>#</a></h3><ul><li>If the queue is empty ‚Üí agent waits</li><li>If the code <strong>yields</strong> (e.g. with a generator or async function), the context is <strong>paused</strong></li><li>It can later be <strong>resumed</strong> with the same state</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span><span class=o>*</span> <span class=nx>steps</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Start&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>yield</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Resumed&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>g</span> <span class=o>=</span> <span class=nx>steps</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=nx>g</span><span class=p>.</span><span class=nx>next</span><span class=p>();</span> <span class=c1>// Start
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>g</span><span class=p>.</span><span class=nx>next</span><span class=p>();</span> <span class=c1>// Resumed
</span></span></span></code></pre></div><p>üß† The function isn‚Äôt restarted ‚Äî it‚Äôs <em>resumed from where it left off</em>.</p><hr><h3 id=-why-it-matters>üß† Why It Matters<a hidden class=anchor aria-hidden=true href=#-why-it-matters>#</a></h3><p>Understanding the <strong>agent model</strong> gives you deep insight into:</p><ul><li>Why JS is single-threaded (per agent)</li><li>Why async functions return promises</li><li>Why <code>await</code> doesn&rsquo;t block the thread</li><li>Why stack overflows happen (<code>Recursion</code>!)</li></ul><hr><h2 id=-bonus-multi-agent-systems>üí° Bonus: Multi-Agent Systems<a hidden class=anchor aria-hidden=true href=#-bonus-multi-agent-systems>#</a></h2><ul><li>You can have <strong>multiple agents</strong> running concurrently (e.g., Web Workers)</li><li>Each has <strong>its own stack, heap, and queue</strong></li><li>They can only communicate via:<ul><li><code>postMessage</code> (copying data)</li><li><code>SharedArrayBuffer + Atomics</code> (shared memory)</li></ul></li></ul><hr><h2 id=-recap-agent-model-mental-picture>‚úÖ Recap: Agent Model Mental Picture<a hidden class=anchor aria-hidden=true href=#-recap-agent-model-mental-picture>#</a></h2><table><thead><tr><th>Part</th><th>Role</th><th>Behavior</th></tr></thead><tbody><tr><td><strong>Agent</strong></td><td>The JS ‚Äúruntime engine‚Äù</td><td>Runs JS code sequentially</td></tr><tr><td><strong>Heap</strong></td><td>Stores objects</td><td>Grows dynamically, managed by GC</td></tr><tr><td><strong>Stack</strong></td><td>Manages function calls</td><td>LIFO ‚Äî grows and shrinks</td></tr><tr><td><strong>Queue</strong></td><td>Schedules async jobs</td><td>FIFO ‚Äî drives the event loop</td></tr><tr><td><strong>Lifecycle</strong></td><td>Pull job ‚Üí execute ‚Üí finish ‚Üí repeat</td><td>Enables async flow</td></tr></tbody></table><hr><h2 id=-real-world-debugging-tip>‚ú® Real-World Debugging Tip<a hidden class=anchor aria-hidden=true href=#-real-world-debugging-tip>#</a></h2><p>When your UI freezes or <code>console.log</code> appears out of order ‚Äî you‚Äôre seeing the <strong>agent lifecycle in action</strong>.<br>If you understand how the stack and queue interact, you can <strong>predict and control</strong> the timing of your code.</p><hr><h2 id=4--execution-contexts--call-stack>4. üì¶ <strong>Execution Contexts & Call Stack</strong><a hidden class=anchor aria-hidden=true href=#4--execution-contexts--call-stack>#</a></h2><hr><h3 id=41--what-is-an-execution-context>4.1. üß† <strong>What is an Execution Context?</strong><a hidden class=anchor aria-hidden=true href=#41--what-is-an-execution-context>#</a></h3><p>An <strong>execution context</strong> (also called a <em>stack frame</em>) is the smallest unit of JS code execution.<br>Whenever JavaScript runs any code‚Äîbe it global, a function, or an eval‚Äîit wraps it in an execution context.</p><h4 id=-it-contains>üîç It contains:<a hidden class=anchor aria-hidden=true href=#-it-contains>#</a></h4><ul><li>üßæ The currently executing <strong>function or script</strong></li><li>üì¶ Its <strong>Lexical Environment</strong> (all its declared variables, parameters, inner functions)</li><li>üîó The associated <strong>Realm</strong> (global scope + intrinsics like <code>Array</code>)</li><li>üí¨ Special bindings like <code>this</code>, <code>arguments</code>, and <code>super</code></li><li>üß≠ The <strong>return address</strong> (where to go back once the function completes)</li></ul><h4 id=-mental-model-1>üß¨ Mental Model:<a hidden class=anchor aria-hidden=true href=#-mental-model-1>#</a></h4><blockquote><p>Like a stack of sticky notes: each time a function is called, a new note (context) is added. It tracks what to do and where to return. Once done, it peels off.</p></blockquote><h4 id=-example-1>üíª Example:<a hidden class=anchor aria-hidden=true href=#-example-1>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>add</span><span class=p>(</span><span class=nx>a</span><span class=p>,</span> <span class=nx>b</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>a</span> <span class=o>+</span> <span class=nx>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>compute</span><span class=p>(</span><span class=nx>x</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>y</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>add</span><span class=p>(</span><span class=nx>x</span><span class=p>,</span> <span class=nx>y</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>compute</span><span class=p>(</span><span class=mi>5</span><span class=p>);</span> <span class=c1>// Execution Contexts created: global -&gt; compute -&gt; add
</span></span></span></code></pre></div><p>Each function call creates a new context with its own scope, <code>this</code>, and state.</p><hr><h3 id=-lexical-environment>üß© Lexical Environment<a hidden class=anchor aria-hidden=true href=#-lexical-environment>#</a></h3><p>Every execution context has a <strong>Lexical Environment</strong>, which stores:</p><ul><li>Local variable bindings (<code>let</code>, <code>const</code>, <code>var</code>)</li><li>Function declarations</li><li>Inner scopes (closures)</li></ul><p>It&rsquo;s called <em>lexical</em> because it&rsquo;s determined by <strong>where the code is written</strong>, not how it is called.</p><h4 id=-closures>üîÅ Closures:<a hidden class=anchor aria-hidden=true href=#-closures>#</a></h4><p>When a function is defined, it &ldquo;remembers&rdquo; the Lexical Environment it was created in. This is what powers closures:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>outer</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kd>let</span> <span class=nx>count</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=kd>function</span> <span class=nx>inner</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nx>count</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nx>count</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The <code>inner</code> function holds on to the <code>outer</code>&rsquo;s lexical environment even after <code>outer</code> has returned.</p><hr><h3 id=-realm-association>üåê Realm Association<a hidden class=anchor aria-hidden=true href=#-realm-association>#</a></h3><p>Each execution context is tied to a <strong>Realm</strong>, which determines:</p><ul><li>The version of intrinsics like <code>Array</code>, <code>Function</code>, etc.</li><li>The <code>globalThis</code> value</li><li>Identity rules (e.g., <code>x instanceof Array</code> fails across realms)</li></ul><h4 id=-gotcha>‚ö†Ô∏è Gotcha:<a hidden class=anchor aria-hidden=true href=#-gotcha>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// If `arr` is created in iframe
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>arr</span> <span class=k>instanceof</span> <span class=nb>Array</span><span class=p>;</span> <span class=c1>// ‚ùå false (different realm&#39;s Array)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>Array</span><span class=p>.</span><span class=nx>isArray</span><span class=p>(</span><span class=nx>arr</span><span class=p>);</span>   <span class=c1>// ‚úÖ works (uses internal tag)
</span></span></span></code></pre></div><hr><h3 id=-this-arguments-and-bindings>‚öôÔ∏è <code>this</code>, <code>arguments</code>, and Bindings<a hidden class=anchor aria-hidden=true href=#-this-arguments-and-bindings>#</a></h3><p>Each context stores runtime-bound values:</p><ul><li><code>this</code> ‚Äî depends on how the function is called (object method, arrow, etc.)</li><li><code>arguments</code> ‚Äî array-like object for parameters (non-arrow functions)</li><li><code>super</code> ‚Äî relevant in class methods</li><li>New private class fields/methods also bind per context</li></ul><hr><h3 id=42--function-invocation--stack-frames>4.2. üîÅ <strong>Function Invocation & Stack Frames</strong><a hidden class=anchor aria-hidden=true href=#42--function-invocation--stack-frames>#</a></h3><p>When a function is invoked:</p><ol><li>JS creates a new <strong>execution context</strong> (stack frame)</li><li>Pushes it onto the <strong>call stack</strong></li><li>Begins executing it</li></ol><h4 id=-when-the-function-finishes>üì§ When the function finishes:<a hidden class=anchor aria-hidden=true href=#-when-the-function-finishes>#</a></h4><ul><li>It <strong>returns</strong> a value or throws an error</li><li>Its frame is <strong>popped</strong> off the stack</li><li>Execution continues where it left off</li></ul><h4 id=-code-trace>üíª Code Trace:<a hidden class=anchor aria-hidden=true href=#-code-trace>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>foo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kr>const</span> <span class=nx>x</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>bar</span><span class=p>(</span><span class=nx>x</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kd>function</span> <span class=nx>bar</span><span class=p>(</span><span class=nx>n</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>n</span> <span class=o>+</span> <span class=mi>5</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>foo</span><span class=p>();</span>
</span></span></code></pre></div><p>üß± Stack trace:</p><pre tabindex=0><code>[global]
‚Üí foo()          ‚Üê pushed
‚Üí bar(10)        ‚Üê pushed
‚Üê return 15      ‚Üê bar popped
‚Üê return 15      ‚Üê foo popped
</code></pre><h4 id=-key-behaviors>üéØ Key behaviors:<a hidden class=anchor aria-hidden=true href=#-key-behaviors>#</a></h4><ul><li><strong>Return</strong> unwinds one frame</li><li><strong>Throw</strong> can unwind multiple frames up the stack (via try/catch or crash)</li><li><strong>Recursion</strong> builds up frames until base case or overflow</li></ul><hr><h3 id=-43-tail-call-optimization-tco>‚ö° 4.3. <strong>Tail Call Optimization (TCO)</strong><a hidden class=anchor aria-hidden=true href=#-43-tail-call-optimization-tco>#</a></h3><p><strong>Tail Call</strong> = when a function returns the result of <em>calling another function directly</em><br>(i.e., no more work left to do after the call).</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>a</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>b</span><span class=p>();</span> <span class=c1>// ‚Üê tail position
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>If supported, JS engines can <strong>reuse the current stack frame</strong> rather than creating a new one.</p><hr><h4 id=-benefits>üéØ Benefits:<a hidden class=anchor aria-hidden=true href=#-benefits>#</a></h4><ul><li>Prevents stack overflow in <strong>tail-recursive</strong> functions</li><li>Improves memory efficiency for deeply nested calls</li></ul><h4 id=-example-ideal-for-tco>üî• Example (ideal for TCO):<a hidden class=anchor aria-hidden=true href=#-example-ideal-for-tco>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>factorial</span><span class=p>(</span><span class=nx>n</span><span class=p>,</span> <span class=nx>acc</span> <span class=o>=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=nx>n</span> <span class=o>&lt;=</span> <span class=mi>1</span><span class=p>)</span> <span class=k>return</span> <span class=nx>acc</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=nx>factorial</span><span class=p>(</span><span class=nx>n</span> <span class=o>-</span> <span class=mi>1</span><span class=p>,</span> <span class=nx>acc</span> <span class=o>*</span> <span class=nx>n</span><span class=p>);</span> <span class=c1>// tail call
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><p>üîÅ Without TCO ‚Üí Stack grows with <code>n</code><br>‚úÖ With TCO ‚Üí Constant memory usage</p><hr><h4 id=-engine-support-caveats>‚ö†Ô∏è Engine Support Caveats:<a hidden class=anchor aria-hidden=true href=#-engine-support-caveats>#</a></h4><ul><li><strong>ECMAScript 2015</strong> specifies proper TCO.</li><li><strong>Only Safari</strong> implements it (as of now).</li><li><strong>V8, SpiderMonkey, Chakra</strong> do <strong>not</strong> support it due to debugging & stack trace concerns.</li></ul><hr><h3 id=-summary-table-1>üß† Summary Table<a hidden class=anchor aria-hidden=true href=#-summary-table-1>#</a></h3><table><thead><tr><th>Concept</th><th>Meaning & Purpose</th></tr></thead><tbody><tr><td>Execution Context</td><td>Metadata + bindings for running code</td></tr><tr><td>Stack Frame</td><td>Unit of execution pushed onto the call stack</td></tr><tr><td>Lexical Environment</td><td>Local scope: variables, closures, declarations</td></tr><tr><td>Realm</td><td>JS &ldquo;universe&rdquo; for built-ins, <code>globalThis</code>, etc.</td></tr><tr><td>Call Stack</td><td>LIFO structure tracking nested calls</td></tr><tr><td>Return / Throw</td><td>Unwinds stack frames (1 or more)</td></tr><tr><td>Tail Call Optimization</td><td>Reuses stack frame for tail calls (not widely supported)</td></tr></tbody></table><hr><h2 id=5--understanding-realms-the-hidden-worlds-of-javascript-execution>5. üåÄ Understanding Realms: The Hidden Worlds of JavaScript Execution<a hidden class=anchor aria-hidden=true href=#5--understanding-realms-the-hidden-worlds-of-javascript-execution>#</a></h2><p>When we talk about JavaScript execution, we often focus on the call stack, the event loop, or async jobs. But there‚Äôs a <strong>deeper architectural layer</strong> that rarely gets discussed‚Äî<strong>Realms</strong>.</p><p>Think of realms as <strong>self-contained universes</strong> within a single JavaScript agent. If you&rsquo;re debugging why <code>instanceof</code> mysteriously returns <code>false</code>, or why your iframe‚Äôs <code>Array</code> behaves strangely, you&rsquo;re bumping up against <strong>realms</strong>‚Äîwithout even knowing it.</p><p>Let‚Äôs unpack this critical concept with surgical depth and practical clarity.</p><hr><h2 id=-what-is-a-realm>üì¶ What Is a Realm?<a hidden class=anchor aria-hidden=true href=#-what-is-a-realm>#</a></h2><blockquote><p>A <strong>realm</strong> is a sandboxed execution environment in JavaScript.<br>Each realm has its <strong>own global object</strong> and <strong>its own copies of built-in constructors</strong> like <code>Object</code>, <code>Array</code>, <code>Function</code>, and so on.</p></blockquote><p>In simpler terms:</p><ul><li>A realm is a <strong>complete JS world</strong>‚Äîwith its own set of laws (built-ins), and its own sky (global object).</li><li>It exists <strong>within an agent</strong> (a JS thread), and multiple realms can coexist inside a single agent.</li></ul><h3 id=-mental-model-2>üß† Mental Model:<a hidden class=anchor aria-hidden=true href=#-mental-model-2>#</a></h3><blockquote><p>üßµ <em>Agent</em> = one JS thread<br>üåç <em>Realm</em> = one JS environment (one <code>globalThis</code>)</p></blockquote><h3 id=-real-world-examples>üí° Real-World Examples:<a hidden class=anchor aria-hidden=true href=#-real-world-examples>#</a></h3><ul><li>Your main browser tab ‚Üí 1 realm.</li><li>A same-origin <code>&lt;iframe></code> ‚Üí another realm (but in the same agent).</li><li>A Web Worker ‚Üí a <strong>separate agent</strong> with its <strong>own realm</strong>.</li></ul><hr><h2 id=-realm-internals>üî¨ Realm Internals<a hidden class=anchor aria-hidden=true href=#-realm-internals>#</a></h2><p>Let‚Äôs zoom into what makes up a realm:</p><h3 id=1--intrinsic-objects>1. üß¨ Intrinsic Objects<a hidden class=anchor aria-hidden=true href=#1--intrinsic-objects>#</a></h3><p>Each realm creates <strong>fresh copies</strong> of all intrinsic JS constructors and prototypes:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nb>Array</span> <span class=o>!==</span> <span class=nx>iframe</span><span class=p>.</span><span class=nx>contentWindow</span><span class=p>.</span><span class=nb>Array</span><span class=p>;</span> <span class=c1>// ‚úÖ true
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>Object</span> <span class=o>!==</span> <span class=nx>iframe</span><span class=p>.</span><span class=nx>contentWindow</span><span class=p>.</span><span class=nb>Object</span><span class=p>;</span> <span class=c1>// ‚úÖ true
</span></span></span></code></pre></div><p>These aren&rsquo;t just shallow copies ‚Äî they‚Äôre entirely different objects in memory. This is what leads to one of the most notorious bugs in cross-realm JS‚Ä¶</p><h3 id=-gotcha-instanceof-fails-across-realms>‚ö†Ô∏è Gotcha: <code>instanceof</code> fails across realms<a hidden class=anchor aria-hidden=true href=#-gotcha-instanceof-fails-across-realms>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>iframeArray</span> <span class=o>=</span> <span class=nx>iframe</span><span class=p>.</span><span class=nx>contentWindow</span><span class=p>.</span><span class=nb>eval</span><span class=p>(</span><span class=s2>&#34;[]&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>iframeArray</span> <span class=k>instanceof</span> <span class=nb>Array</span><span class=p>;</span> <span class=c1>// ‚ùå false
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>Array</span><span class=p>.</span><span class=nx>isArray</span><span class=p>(</span><span class=nx>iframeArray</span><span class=p>);</span>   <span class=c1>// ‚úÖ true
</span></span></span></code></pre></div><p><strong>Why?</strong> Because <code>iframeArray</code>&rsquo;s prototype chain points to <strong>iframe‚Äôs</strong> <code>Array.prototype</code>, not yours.</p><p>This is why you should <strong>always use</strong>:</p><ul><li><code>Array.isArray(obj)</code></li><li><code>Object.prototype.toString.call(obj)</code></li></ul><p>‚Ä¶and never rely on <code>instanceof</code> when realms might be involved.</p><hr><h3 id=2--global-object-and-globalthis>2. ü™ê Global Object and <code>globalThis</code><a hidden class=anchor aria-hidden=true href=#2--global-object-and-globalthis>#</a></h3><p>Each realm gets its own <strong>global object</strong>, which defines the top-level scope.</p><p>Depending on the context, this global object could be:</p><ul><li>A <code>Window</code> (in a tab or iframe)</li><li>A <code>WorkerGlobalScope</code> (in a worker)</li><li>A <code>WorkletGlobalScope</code> (in an audio or paint worklet)</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nb>window</span><span class=p>.</span><span class=nx>globalThis</span> <span class=o>===</span> <span class=nb>window</span><span class=p>;</span> <span class=c1>// ‚úÖ in a tab
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>self</span><span class=p>.</span><span class=nx>globalThis</span> <span class=o>===</span> <span class=nx>self</span><span class=p>;</span>     <span class=c1>// ‚úÖ in a worker
</span></span></span></code></pre></div><p>Each realm has a unique <code>globalThis</code> ‚Äî they don‚Äôt bleed into each other.</p><hr><h3 id=3--template-literal-cache>3. üß† Template Literal Cache<a hidden class=anchor aria-hidden=true href=#3--template-literal-cache>#</a></h3><p>Tagged template literals reuse the same <strong>array object</strong> on repeated calls <strong>within the same realm</strong>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kd>function</span> <span class=nx>tag</span><span class=p>(</span><span class=nx>strings</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=nx>strings</span><span class=p>);</span> <span class=c1>// same object each time
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=nx>tag</span><span class=sb>`hello`</span><span class=p>;</span> <span class=c1>// strings === [&#34;hello&#34;]
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>tag</span><span class=sb>`hello`</span><span class=p>;</span> <span class=c1>// strings is the same object
</span></span></span></code></pre></div><p>But that cache is <strong>per-realm</strong>. Use a different realm (like an iframe), and you&rsquo;ll get a different array object, even with the same template.</p><hr><h2 id=-realms-vs-agents>üß© Realms vs Agents<a hidden class=anchor aria-hidden=true href=#-realms-vs-agents>#</a></h2><p>Let‚Äôs clarify the distinction:</p><table><thead><tr><th>Concept</th><th>Realm</th><th>Agent</th></tr></thead><tbody><tr><td>What it is</td><td>A JS environment with its own global scope & built-ins</td><td>A JS <strong>thread</strong> (executor of code)</td></tr><tr><td>Count</td><td>Multiple per agent</td><td>One per thread</td></tr><tr><td>Global object</td><td>Unique per realm (<code>window</code>, <code>self</code>, etc.)</td><td>Not shared across agents</td></tr><tr><td>Memory</td><td>Shared heap (within same agent)</td><td>Isolated between agents unless using SharedArrayBuffer</td></tr></tbody></table><h3 id=-realms-can-talk-if-in-same-agent>üîÅ Realms Can Talk (if in same agent)<a hidden class=anchor aria-hidden=true href=#-realms-can-talk-if-in-same-agent>#</a></h3><p>If you have:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=o>&lt;</span><span class=nx>iframe</span> <span class=nx>src</span><span class=o>=</span><span class=s2>&#34;same-origin.html&#34;</span><span class=o>&gt;&lt;</span><span class=err>/iframe&gt;</span>
</span></span></code></pre></div><p>You can synchronously access the iframe‚Äôs realm:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>iframe</span><span class=p>.</span><span class=nx>contentWindow</span><span class=p>.</span><span class=nb>document</span><span class=p>.</span><span class=nx>title</span><span class=p>;</span> <span class=c1>// ‚úÖ works
</span></span></span></code></pre></div><p>But remember: it&rsquo;s a <strong>different realm</strong>. So be cautious with identity checks.</p><hr><h2 id=-why-realms-matter-in-the-real-world>üîê Why Realms Matter in the Real World<a hidden class=anchor aria-hidden=true href=#-why-realms-matter-in-the-real-world>#</a></h2><h3 id=1-security-and-isolation>1. <strong>Security and Isolation</strong><a hidden class=anchor aria-hidden=true href=#1-security-and-isolation>#</a></h3><ul><li>Realms provide containment: Each realm is sandboxed with its own set of built-ins and globals.</li><li>Cross-origin iframes get different agents <em>and</em> different realms, enforcing strict separation.</li></ul><h3 id=2-framework--testing-tooling>2. <strong>Framework & Testing Tooling</strong><a hidden class=anchor aria-hidden=true href=#2-framework--testing-tooling>#</a></h3><ul><li>Tools like Jest, JSDOM, or sandboxed evaluators often run code in isolated realms to prevent global pollution.</li></ul><h3 id=3-micro-frontend-architecture>3. <strong>Micro-frontend Architecture</strong><a hidden class=anchor aria-hidden=true href=#3-micro-frontend-architecture>#</a></h3><ul><li>In advanced front-end architectures, teams load independent apps in iframes or ShadowRealms to prevent conflicts.</li></ul><h3 id=4-cross-realm-bugs>4. <strong>Cross-Realm Bugs</strong><a hidden class=anchor aria-hidden=true href=#4-cross-realm-bugs>#</a></h3><ul><li>If you&rsquo;re building libraries, especially polyfills or type-checking utils, <strong>you must account for realm differences</strong>.<div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// Anti-pattern
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>value</span> <span class=k>instanceof</span> <span class=nb>Object</span><span class=p>;</span> <span class=c1>// ‚ùå not safe across realms
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// Safe alternative
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nb>Object</span><span class=p>.</span><span class=nx>prototype</span><span class=p>.</span><span class=nx>toString</span><span class=p>.</span><span class=nx>call</span><span class=p>(</span><span class=nx>value</span><span class=p>)</span> <span class=o>===</span> <span class=s2>&#34;[object Object]&#34;</span><span class=p>;</span> <span class=c1>// ‚úÖ
</span></span></span></code></pre></div></li></ul><hr><h2 id=-takeaways>üß† Takeaways<a hidden class=anchor aria-hidden=true href=#-takeaways>#</a></h2><ul><li><strong>A realm is a self-contained JS universe</strong> ‚Äî with its own global scope and its own versions of built-in types.</li><li>Realms can coexist inside a single agent, but their built-ins and identity checks <strong>do not overlap</strong>.</li><li>Always prefer <strong>realm-safe methods</strong> (<code>Array.isArray</code>, <code>Object.prototype.toString.call</code>) over <code>instanceof</code>.</li><li>Understand realms if you&rsquo;re working with:<ul><li>iframes</li><li>workers</li><li>multi-app frontends</li><li>testing sandboxes</li><li>serialization/deserialization across origins</li></ul></li></ul><hr><h2 id=-bonus-shadowrealm-tc39-stage-3>üìå Bonus: ShadowRealm (TC39 Stage 3)<a hidden class=anchor aria-hidden=true href=#-bonus-shadowrealm-tc39-stage-3>#</a></h2><p>A new JS feature, <code>ShadowRealm</code>, allows you to <strong>create a new realm programmatically</strong> without using iframes:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>realm</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>ShadowRealm</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=kr>const</span> <span class=nx>result</span> <span class=o>=</span> <span class=nx>realm</span><span class=p>.</span><span class=nx>evaluate</span><span class=p>(</span><span class=sb>`1 + 1`</span><span class=p>);</span> <span class=c1>// 2
</span></span></span></code></pre></div><p>This is <strong>realm-level isolation</strong>, but <strong>still within the same agent</strong>. Great for security, testing, or plugin systems.</p><hr><h2 id=-final-word>‚úçÔ∏è Final Word<a hidden class=anchor aria-hidden=true href=#-final-word>#</a></h2><p>JavaScript realms are like alternate realities ‚Äî isolated yet interconnected in subtle ways. They influence how your objects behave, how identity is checked, and how memory is managed.</p><p>Understanding realms is a <strong>superpower</strong> ‚Äî especially if you‚Äôre debugging strange prototype issues or building frameworks and platforms. Master this layer, and you‚Äôre one step closer to mastering the entire JavaScript execution model.</p><hr><h2 id=6--agent-types-in-the-web-platform>6. üåê <strong>Agent Types in the Web Platform</strong><a hidden class=anchor aria-hidden=true href=#6--agent-types-in-the-web-platform>#</a></h2><h3 id=61-main-window-agent>6.1. Main Window Agent<a hidden class=anchor aria-hidden=true href=#61-main-window-agent>#</a></h3><h3 id=62-dedicated-worker-agent>6.2. Dedicated Worker Agent<a hidden class=anchor aria-hidden=true href=#62-dedicated-worker-agent>#</a></h3><h3 id=63-shared-worker-agent>6.3. Shared Worker Agent<a hidden class=anchor aria-hidden=true href=#63-shared-worker-agent>#</a></h3><h3 id=64-service-worker-agent>6.4. Service Worker Agent<a hidden class=anchor aria-hidden=true href=#64-service-worker-agent>#</a></h3><h3 id=65-worklet-agent>6.5. Worklet Agent<a hidden class=anchor aria-hidden=true href=#65-worklet-agent>#</a></h3><ul><li>Each has its own heap, stack, queue</li><li>Communication model (<code>postMessage</code>, SharedArrayBuffer)</li></ul><hr><h2 id=6--agent-types-in-the-web-platform-1>6. üåê <strong>Agent Types in the Web Platform</strong><a hidden class=anchor aria-hidden=true href=#6--agent-types-in-the-web-platform-1>#</a></h2><p>The web isn&rsquo;t just one giant thread where all JavaScript code runs together. Instead, it&rsquo;s composed of multiple <strong>agents</strong> ‚Äî isolated, independent runtimes that can each execute JS code with their own <strong>heap</strong>, <strong>call stack</strong>, and <strong>event loop</strong>. Understanding these agent types is crucial for mastering concurrency, memory isolation, and performance design patterns in modern web development.</p><p>Let‚Äôs break down the main types of agents and why they matter:</p><hr><h3 id=61--main-window-agent>6.1 ü™ü <strong>Main Window Agent</strong><a hidden class=anchor aria-hidden=true href=#61--main-window-agent>#</a></h3><p>This is the agent you interact with most ‚Äî the <strong>tab</strong> in your browser running HTML, CSS, and JavaScript. It includes:</p><ul><li>The global <code>window</code> object</li><li>Access to the DOM</li><li>Full access to browser APIs (e.g., <code>document</code>, <code>alert</code>, <code>fetch</code>)</li></ul><p>Multiple same-origin iframes can <em>share</em> the same agent, meaning they share the <strong>call stack</strong> and can synchronously call each other‚Äôs functions and access each other‚Äôs memory (within security limits).</p><p>üìå <strong>Key traits</strong>:</p><ul><li>Has direct DOM access</li><li>Can synchronously communicate with same-origin iframes</li><li>Cannot be blocked via <code>Atomics.wait()</code></li></ul><p>üß† <strong>Mental model</strong>: A control room managing user interaction, UI rendering, and input events ‚Äî all on one thread.</p><hr><h3 id=62--dedicated-worker-agent>6.2 üë∑ <strong>Dedicated Worker Agent</strong><a hidden class=anchor aria-hidden=true href=#62--dedicated-worker-agent>#</a></h3><p>Created via <code>new Worker()</code>, a <strong>Dedicated Worker</strong> runs JS in a completely separate agent ‚Äî its own isolated thread. It doesn‚Äôt have access to the DOM, but can perform heavy computations without blocking the main thread.</p><p>üì¶ <strong>Separate agent = separate memory</strong>:</p><ul><li>Own heap</li><li>Own call stack</li><li>Own event loop</li></ul><p>üß† Think of it like spawning a specialized assistant: you give it instructions via <code>postMessage()</code>, and it replies asynchronously.</p><p>‚úÖ Can use <code>SharedArrayBuffer</code> for shared memory (with proper CORS and COOP/COEP headers)</p><p>üíª</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>worker</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Worker</span><span class=p>(</span><span class=s2>&#34;worker.js&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>worker</span><span class=p>.</span><span class=nx>postMessage</span><span class=p>({</span> <span class=nx>task</span><span class=o>:</span> <span class=s2>&#34;compute&#34;</span> <span class=p>});</span>
</span></span></code></pre></div><hr><h3 id=63--shared-worker-agent>6.3 ü§ù <strong>Shared Worker Agent</strong><a hidden class=anchor aria-hidden=true href=#63--shared-worker-agent>#</a></h3><p>Shared Workers are like Dedicated Workers, but <strong>shared across multiple same-origin contexts</strong> ‚Äî tabs, iframes, or windows. They persist beyond a single page and can maintain shared state (like a single WebSocket connection).</p><p>üìå <strong>Key distinction</strong>: They <strong>do not</strong> share memory with their clients. All communication is through <code>postMessage()</code> using <strong>structured cloning</strong>.</p><p>üß† Metaphor: A shared database or message bus multiple clients talk to, but no one can directly poke into its memory.</p><hr><h3 id=64--service-worker-agent>6.4 üõ∞ <strong>Service Worker Agent</strong><a hidden class=anchor aria-hidden=true href=#64--service-worker-agent>#</a></h3><p>A <strong>Service Worker</strong> is a proxy-like agent that sits between your web app and the network. It doesn‚Äôt have a UI and cannot touch the DOM, but it can:</p><ul><li>Intercept network requests</li><li>Serve cached assets</li><li>Enable offline experiences</li><li>Run even when the page is closed</li></ul><p>üì¶ It has its own agent ‚Äî its own heap, stack, and event queue ‚Äî and doesn‚Äôt share memory with any window.</p><p>üß† Think of it as a background daemon that acts as a programmable router.</p><p>üí° Bonus: Service workers are essential for building Progressive Web Apps (PWAs).</p><hr><h3 id=65--worklet-agent>6.5 üé® <strong>Worklet Agent</strong><a hidden class=anchor aria-hidden=true href=#65--worklet-agent>#</a></h3><p><strong>Worklets</strong> are ultra-lightweight, low-latency agents used for frame-by-frame operations in:</p><ul><li><strong>AudioWorklet</strong> (real-time DSP)</li><li><strong>PaintWorklet</strong> (CSS custom painting)</li><li><strong>LayoutWorklet</strong> (custom layout logic)</li></ul><p>These agents are stripped down for speed ‚Äî no DOM, no network access, but real-time-safe execution.</p><p>üß† Imagine a tiny artist or sound engineer working just fast enough to keep up with your browser‚Äôs 60FPS heartbeat.</p><p>üìå They run inside their own agent and can be memory-shared with their creators using <code>SharedArrayBuffer</code>.</p><hr><h3 id=-all-agent-types-have>üß¨ All Agent Types Have:<a hidden class=anchor aria-hidden=true href=#-all-agent-types-have>#</a></h3><p>‚úÖ Their <strong>own execution context</strong>:</p><ul><li><strong>Heap</strong>: where objects live</li><li><strong>Call stack</strong>: for function execution</li><li><strong>Job queue</strong>: for async callbacks (event loop)</li></ul><p>‚úÖ Communication model:</p><ul><li>üîÅ <code>postMessage()</code> for asynchronous messaging (structured cloning)</li><li>üîó <code>SharedArrayBuffer</code> + <code>Atomics</code> for shared memory and synchronization (if in the same agent cluster)</li></ul><hr><h3 id=-summary-table-2>üß† Summary Table<a hidden class=anchor aria-hidden=true href=#-summary-table-2>#</a></h3><table><thead><tr><th>Agent Type</th><th>DOM Access</th><th>Memory Sharing</th><th>Shared Across Tabs?</th><th>Use Case</th></tr></thead><tbody><tr><td><strong>Main Window Agent</strong></td><td>‚úÖ Yes</td><td>‚úÖ with same-origin iframes</td><td>‚ùå</td><td>UI logic, DOM interaction</td></tr><tr><td><strong>Dedicated Worker</strong></td><td>‚ùå No</td><td>‚úÖ via <code>SharedArrayBuffer</code></td><td>‚ùå</td><td>Heavy computation, parallel tasks</td></tr><tr><td><strong>Shared Worker</strong></td><td>‚ùå No</td><td>‚ùå</td><td>‚úÖ</td><td>Cross-tab state sync, WebSocket hub</td></tr><tr><td><strong>Service Worker</strong></td><td>‚ùå No</td><td>‚ùå</td><td>‚úÖ</td><td>Offline support, request caching</td></tr><tr><td><strong>Worklet</strong></td><td>‚ùå No</td><td>‚úÖ (when configured)</td><td>‚ùå</td><td>Real-time audio/visual processing</td></tr></tbody></table><hr><h3 id=-related-concepts>üîó Related Concepts:<a hidden class=anchor aria-hidden=true href=#-related-concepts>#</a></h3><ul><li><strong>Agent Cluster</strong>: A group of agents that can share memory (<code>SharedArrayBuffer</code>) and synchronize with <code>Atomics</code>.</li><li><strong>Structured Cloning</strong>: Default communication method ‚Äî objects are <em>copied</em>, not shared.</li><li><strong>Heap / Stack / Queue</strong>: Every agent gets their own ‚Äî enabling safe, parallel, isolated execution.</li></ul><hr><p>üì£ <strong>Takeaway</strong>:<br>Modern JavaScript isn‚Äôt single-threaded anymore ‚Äî <strong>it‚Äôs multi-agent</strong>.<br>You, as a developer, control which type of agent runs your code ‚Äî and how they communicate. Choose wisely based on memory safety, responsiveness, and your app‚Äôs architecture.</p><hr><h2 id=7--job-queue--event-loop>7. üîÅ <strong>Job Queue & Event Loop</strong><a hidden class=anchor aria-hidden=true href=#7--job-queue--event-loop>#</a></h2><p>Modern JavaScript feels synchronous ‚Äî but behaves asynchronously. That paradox is powered by one of the most elegant constructs in programming: the <strong>event loop</strong>.</p><p>Let‚Äôs dive deep into how JavaScript keeps your code <em>non-blocking</em>, <em>predictable</em>, and <em>responsive</em> ‚Äî using <strong>jobs</strong>, <strong>queues</strong>, and a beautiful bit of choreography called the <strong>run-to-completion model</strong>.</p><hr><h3 id=71--what-is-a-job>7.1 üîß What is a Job?<a hidden class=anchor aria-hidden=true href=#71--what-is-a-job>#</a></h3><blockquote><p><strong>Callback + Execution Context = Job</strong></p></blockquote><p>Every time your code hands off a function to be called later ‚Äî say, via <code>setTimeout</code>, a Promise, or a DOM event ‚Äî you&rsquo;re scheduling a <strong>job</strong>. Think of it as a <strong>tiny program</strong> JS will run once it‚Äôs done with the current one.</p><p>These jobs are stored in queues and executed one at a time, with guaranteed order and isolation.</p><p>üß† <strong>Mental Model</strong>:<br>Each job is like a fully wrapped meal order ‚Äî a recipe (<code>callback</code>) bundled with ingredients (<code>execution context</code>). JS cooks them one-by-one, never two at once.</p><hr><h3 id=72--event-loop-the-scheduler-in-chief>7.2 üîÑ Event Loop: The Scheduler-in-Chief<a hidden class=anchor aria-hidden=true href=#72--event-loop-the-scheduler-in-chief>#</a></h3><p>At the heart of this system is the <strong>event loop</strong>, the mechanism that:</p><ol><li><strong>Waits</strong> for the stack to be empty</li><li><strong>Pulls the next job</strong> from the queue</li><li><strong>Executes</strong> it entirely before moving on</li></ol><p>This is the <strong>run-to-completion guarantee</strong>.</p><p>üí° <strong>Why it matters</strong>:</p><ul><li>No two callbacks ever run at the same time</li><li>Shared variables are safe during a job</li><li>Your program stays predictable and easy to reason about</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;A&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;B&#34;</span><span class=p>),</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;C&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Output:
</span></span></span><span class=line><span class=cl><span class=c1>// A
</span></span></span><span class=line><span class=cl><span class=c1>// C
</span></span></span><span class=line><span class=cl><span class=c1>// B
</span></span></span></code></pre></div><p>üîç Even though the timer is 0ms, it gets queued as a <em>job</em> and only runs <em>after</em> current code finishes.</p><hr><h3 id=73--microtasks-vs-macrotasks>7.3 ‚öñÔ∏è Microtasks vs Macrotasks<a hidden class=anchor aria-hidden=true href=#73--microtasks-vs-macrotasks>#</a></h3><p>Not all jobs are equal. The queue is actually two queues:</p><table><thead><tr><th>Type</th><th>Examples</th><th>Priority</th></tr></thead><tbody><tr><td><strong>Microtasks</strong></td><td><code>Promise.then</code>, <code>queueMicrotask()</code></td><td>üî• High (drained first)</td></tr><tr><td><strong>Macrotasks</strong></td><td><code>setTimeout</code>, <code>setInterval</code>, DOM events</td><td>‚è≥ Lower</td></tr></tbody></table><p>After every job (macro or otherwise), the event loop <strong>drains all microtasks</strong> before running the next macro task.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Start&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Timeout&#34;</span><span class=p>),</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nb>Promise</span><span class=p>.</span><span class=nx>resolve</span><span class=p>().</span><span class=nx>then</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Promise&#34;</span><span class=p>));</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;End&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Output:
</span></span></span><span class=line><span class=cl><span class=c1>// Start
</span></span></span><span class=line><span class=cl><span class=c1>// End
</span></span></span><span class=line><span class=cl><span class=c1>// Promise
</span></span></span><span class=line><span class=cl><span class=c1>// Timeout
</span></span></span></code></pre></div><p>üìå <strong>Microtasks are prioritized</strong> ‚Äî even over timers.</p><p>üß† <strong>Metaphor</strong>:<br>Microtasks are sticky notes on your desk. Macrotasks are meetings. After finishing a job (macro), JS clears all sticky notes (micro) before going to the next meeting.</p><hr><h3 id=74--blocking-vs-non-blocking>7.4 üßµ Blocking vs Non-Blocking<a hidden class=anchor aria-hidden=true href=#74--blocking-vs-non-blocking>#</a></h3><p>JS&rsquo;s single-threaded nature means <strong>blocking is dangerous</strong> ‚Äî if your code stalls, your UI freezes, your app becomes unresponsive.</p><p>‚úÖ Async I/O ‚Äî like <code>fetch</code>, <code>setTimeout</code>, <code>readFile</code> ‚Äî is non-blocking by design.</p><p>üö´ But legacy APIs can <em>block the agent</em> entirely:</p><table><thead><tr><th>API</th><th>Behavior</th></tr></thead><tbody><tr><td><code>alert()</code></td><td>Blocks entire tab</td></tr><tr><td><code>confirm()</code></td><td>Blocking</td></tr><tr><td><code>XMLHttpRequest</code> (sync)</td><td>Blocking</td></tr></tbody></table><p>üí° Even <code>while(true){}</code> loops will freeze your app.</p><p>üîç <strong>Modern JavaScript avoids blocking at all costs</strong> by using:</p><ul><li>The <strong>event loop</strong></li><li>The <strong>job queue</strong></li><li>And a <strong>non-blocking I/O model</strong></li></ul><hr><h3 id=-final-mental-model>üí° Final Mental Model<a hidden class=anchor aria-hidden=true href=#-final-mental-model>#</a></h3><p>Visualize JavaScript as a factory:</p><ul><li>üèóÔ∏è <strong>Call Stack</strong>: The active workstation (only one at a time)</li><li>üì¨ <strong>Job Queue</strong>: A mailbox full of tasks to run</li><li>üîÅ <strong>Event Loop</strong>: A robot that:<ul><li>Waits for the workstation to be free</li><li>Picks the next job from the mailbox</li><li>Ensures no job starts until the last one finishes</li></ul></li></ul><p>And among the jobs:</p><ul><li>üìù <strong>Microtasks</strong> are urgent memos ‚Äî always read before any new mail.</li><li>‚è∞ <strong>Macrotasks</strong> are full packages ‚Äî scheduled deliveries that wait their turn.</li></ul><p>This model gives JS its magic mix of <strong>simplicity + power</strong>:</p><ul><li>Single-threaded but never frozen (if you follow the rules)</li><li>Predictable execution with async capabilities</li><li>Safe by default, powerful when needed</li></ul><hr><p>Next time you wonder <em>why Promises beat timers</em>, or <em>why your UI freezes</em>, or <em>why <code>console.log</code> shows up before your <code>setTimeout</code></em>, remember:<br>You‚Äôre not just writing code ‚Äî you‚Äôre orchestrating a symphony of jobs in a beautifully synchronized single-threaded engine.</p><hr><h2 id=8--concurrency--memory-sharing>8. üß† <strong>Concurrency & Memory Sharing</strong><a hidden class=anchor aria-hidden=true href=#8--concurrency--memory-sharing>#</a></h2><p>In the world of JavaScript, we often talk about <em>single-threaded execution</em>, the <em>event loop</em>, and <em>asynchronous callbacks</em>. But what happens when multiple threads‚Äî<em>agents</em>, in ECMAScript speak‚Äîneed to <strong>share memory and coordinate</strong>? That‚Äôs where <strong>agent clusters</strong>, <strong>shared memory</strong>, and <strong>atomic operations</strong> come in.</p><p>This section dives into JavaScript‚Äôs <em>low-level concurrency primitives</em>, showing how modern engines manage <strong>parallelism</strong> safely using shared memory, and how developers can reason about memory consistency, data races, and synchronization.</p><hr><h3 id=81--agent-clusters-who-can-share-memory-with-whom>8.1 ‚ö° <strong>Agent Clusters: Who Can Share Memory with Whom?</strong><a hidden class=anchor aria-hidden=true href=#81--agent-clusters-who-can-share-memory-with-whom>#</a></h3><p>In JavaScript, every independent execution context‚Äîlike a tab, worker, or iframe‚Äîis called an <strong>agent</strong>. But not all agents are created equal. Only some can <strong>share memory</strong>.</p><p>Agents that can share memory form what&rsquo;s called an <strong>agent cluster</strong>.</p><blockquote><p>üß† <strong>Core Rule:</strong> If two agents can share a <code>SharedArrayBuffer</code>, they belong to the same cluster. If not, they are <strong>completely isolated</strong>.</p></blockquote><h4 id=-in-the-same-cluster-can-share-memory>‚úÖ In the Same Cluster (can share memory):<a hidden class=anchor aria-hidden=true href=#-in-the-same-cluster-can-share-memory>#</a></h4><ul><li>A <strong>Window</strong> and the <strong>Dedicated Worker</strong> it creates</li><li>A <strong>Worker</strong> and the <strong>Dedicated Worker</strong> it spawns</li><li>A <strong>Window</strong> and a <strong>same-origin iframe</strong></li><li>A <strong>Window</strong> and a <strong>same-origin opener window</strong></li><li>A <strong>Window</strong> and its <strong>Worklet</strong></li></ul><h4 id=-different-clusters-cant-share-memory>‚ùå Different Clusters (can‚Äôt share memory):<a hidden class=anchor aria-hidden=true href=#-different-clusters-cant-share-memory>#</a></h4><ul><li>A <strong>Window</strong> and a <strong>SharedWorker</strong></li><li>A <strong>Window</strong> and a <strong>ServiceWorker</strong></li><li>A <strong>Worker</strong> and a <strong>SharedWorker</strong></li><li>Two <strong>unrelated</strong> same-origin <code>Window</code> objects</li><li>A <strong>Window</strong> and a <strong>cross-origin iframe</strong></li></ul><p>Think of <strong>agent clusters</strong> like secure bubbles. If two agents are in the same bubble, they can point to the same memory. If not, even passing a reference is forbidden.</p><hr><h3 id=82--shared-memory-with-sharedarraybuffer>8.2 üß† <strong>Shared Memory with SharedArrayBuffer</strong><a hidden class=anchor aria-hidden=true href=#82--shared-memory-with-sharedarraybuffer>#</a></h3><p>JavaScript is traditionally <strong>copy-by-value</strong> when agents communicate. That‚Äôs how <code>postMessage()</code> works: it sends a <strong>structured clone</strong> of the data.</p><p>But there‚Äôs one exception: <strong><code>SharedArrayBuffer</code></strong>.</p><blockquote><p>üß¨ Metaphor: Normally, you&rsquo;re emailing someone a <em>photocopy</em> of your notebook. With <code>SharedArrayBuffer</code>, you&rsquo;re giving them the <em>same notebook</em>, and now you both can write in it‚Äîsimultaneously.</p></blockquote><h4 id=-how-it-works>üîó How It Works:<a hidden class=anchor aria-hidden=true href=#-how-it-works>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=kr>const</span> <span class=nx>sab</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>SharedArrayBuffer</span><span class=p>(</span><span class=mi>1024</span><span class=p>);</span> <span class=c1>// shared memory
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kr>const</span> <span class=nx>view</span> <span class=o>=</span> <span class=k>new</span> <span class=nx>Int32Array</span><span class=p>(</span><span class=nx>sab</span><span class=p>);</span>        <span class=c1>// typed view
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=nx>worker</span><span class=p>.</span><span class=nx>postMessage</span><span class=p>(</span><span class=nx>sab</span><span class=p>);</span> <span class=c1>// no clone ‚Äî both now point to the same memory
</span></span></span></code></pre></div><p>Now both the main thread and the worker share that memory. But shared access means <strong>concurrent access</strong>, and that leads us to‚Ä¶</p><hr><h3 id=83--synchronizing-with-atomics>8.3 üîí <strong>Synchronizing with Atomics</strong><a hidden class=anchor aria-hidden=true href=#83--synchronizing-with-atomics>#</a></h3><p>Just because memory is shared doesn‚Äôt mean it‚Äôs safe.</p><blockquote><p>üß† Regular JS assignments like <code>arr[0] = arr[0] + 1</code> are <strong>not atomic</strong> and can be torn apart when run from two agents at once.</p></blockquote><p>That‚Äôs why ECMAScript gives us <strong><code>Atomics</code></strong>: a namespace of operations that <strong>guarantee safe, lock-free memory coordination</strong>.</p><h4 id=-tools-in-the-atomics-toolbox>üõ† Tools in the <code>Atomics</code> toolbox:<a hidden class=anchor aria-hidden=true href=#-tools-in-the-atomics-toolbox>#</a></h4><ul><li><code>Atomics.load(view, index)</code> ‚Äî safely read</li><li><code>Atomics.store(view, index, value)</code> ‚Äî safely write</li><li><code>Atomics.add</code>, <code>sub</code>, <code>and</code>, <code>or</code>, <code>xor</code>, etc. ‚Äî read-modify-write</li><li><code>Atomics.wait(view, index, value)</code> ‚Äî <strong>block</strong> until value changes</li><li><code>Atomics.notify(view, index, count)</code> ‚Äî wake up blocked agents</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// Thread 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>while</span> <span class=p>(</span><span class=nx>Atomics</span><span class=p>.</span><span class=nx>load</span><span class=p>(</span><span class=nx>view</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span> <span class=o>!==</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>Atomics</span><span class=p>.</span><span class=nx>wait</span><span class=p>(</span><span class=nx>view</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span> <span class=c1>// wait until someone sets it to 1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Thread 2
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>Atomics</span><span class=p>.</span><span class=nx>store</span><span class=p>(</span><span class=nx>view</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=nx>Atomics</span><span class=p>.</span><span class=nx>notify</span><span class=p>(</span><span class=nx>view</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span>
</span></span></code></pre></div><p>This pattern enables <strong>thread-style coordination</strong> between agents ‚Äî like building your own semaphores or locks.</p><blockquote><p>‚ö†Ô∏è Only <strong>dedicated</strong> or <strong>shared workers</strong> can be blocked using <code>Atomics.wait()</code>. Windows and service workers are never allowed to block.</p></blockquote><hr><h3 id=84--memory-consistency-and-data-races>8.4 üìè <strong>Memory Consistency and Data Races</strong><a hidden class=anchor aria-hidden=true href=#84--memory-consistency-and-data-races>#</a></h3><p>JavaScript‚Äôs memory model ensures <strong>predictable behavior</strong> only if you follow certain rules.</p><blockquote><p>‚úÖ <strong>Data race‚Äìfree = safe, consistent, sequential semantics</strong><br>‚ùå Data races = torn values, weird bugs, and undefined behavior</p></blockquote><h4 id=-whats-a-data-race>‚ö†Ô∏è What‚Äôs a Data Race?<a hidden class=anchor aria-hidden=true href=#-whats-a-data-race>#</a></h4><p>When <strong>two agents</strong> access the <strong>same memory location</strong> at the <strong>same time</strong>, and at least one of them writes, <em>without proper synchronization</em>.</p><h4 id=-example-of-value-tearing>üß™ Example of value tearing:<a hidden class=anchor aria-hidden=true href=#-example-of-value-tearing>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=c1>// One agent writes a 32-bit int
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nx>arr</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>=</span> <span class=mh>0x12345678</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Another agent reads only the first 16 bits mid-write
</span></span></span></code></pre></div><p>Result? You read a garbage value like <code>0x12340000</code>. That‚Äôs <strong>value tearing</strong>.</p><h4 id=-rule-of-thumb>üîí Rule of Thumb:<a hidden class=anchor aria-hidden=true href=#-rule-of-thumb>#</a></h4><ul><li>Always access shared memory via <strong><code>Atomics</code></strong>.</li><li>Use the <strong>same access size</strong> and <strong>typed array</strong> across all agents.</li><li>Avoid mixing atomic and non-atomic operations on the same memory cell.</li></ul><hr><h3 id=-why-this-matters-1>üß† Why This Matters<a hidden class=anchor aria-hidden=true href=#-why-this-matters-1>#</a></h3><p>Shared memory gives us <strong>high-performance parallelism</strong> in JavaScript ‚Äî without blocking the main thread.</p><p>But it comes with the responsibility of:</p><ul><li>Defining clear communication patterns</li><li>Designing for <strong>race-freedom</strong></li><li>Understanding that <code>postMessage()</code> ‚â† shared memory unless you use <code>SharedArrayBuffer</code></li><li>Avoiding subtle bugs from <strong>cross-agent memory inconsistencies</strong></li></ul><hr><h3 id=-in-summary>üì¶ In Summary<a hidden class=anchor aria-hidden=true href=#-in-summary>#</a></h3><table><thead><tr><th>Concept</th><th>Description</th></tr></thead><tbody><tr><td><strong>Agent Cluster</strong></td><td>Group of JS agents that can share memory</td></tr><tr><td><strong>SharedArrayBuffer</strong></td><td>Enables memory sharing between agents</td></tr><tr><td><strong>Atomics</strong></td><td>Enables safe, lock-free communication on shared memory</td></tr><tr><td><strong>Data Race</strong></td><td>When agents read/write same memory without sync</td></tr><tr><td><strong>Sequential Consistency</strong></td><td>All agents see memory changes in the same order if no races</td></tr></tbody></table><hr><h3 id=-final-thought>üí≠ Final Thought<a hidden class=anchor aria-hidden=true href=#-final-thought>#</a></h3><p>The introduction of shared memory and <code>Atomics</code> fundamentally changes what JavaScript is capable of ‚Äî enabling <strong>parallel algorithms</strong>, <strong>real-time audio processing</strong>, and <strong>high-throughput computation</strong>. But it also demands a new level of rigor. Just as <code>Promise</code> taught us to think about <strong>time</strong>, <code>SharedArrayBuffer</code> and <code>Atomics</code> teach us to think about <strong>space</strong> ‚Äî and how multiple minds can share the same thoughts without stepping on each other‚Äôs toes.</p><p>Welcome to the world of <strong>concurrent JavaScript</strong> ‚Äî where your variables can now live in more than one mind at once.</p><hr><h2 id=9--cluster-lifecycle--blocking>9. üöß Cluster Lifecycle & Blocking<a hidden class=anchor aria-hidden=true href=#9--cluster-lifecycle--blocking>#</a></h2><p>Modern JavaScript engines have evolved into distributed runtimes. And yet, most developers still think in terms of <em>&ldquo;single-threaded async code&rdquo;</em>. But under the hood, <strong>agents</strong>, <strong>clusters</strong>, and <strong>shared memory</strong> enable fine-grained concurrency.</p><p>This section explores what really happens when JS environments start talking ‚Äî and blocking ‚Äî across boundaries.</p><hr><h3 id=91--blocking-apis-atomicswait>9.1. üß± Blocking APIs (<code>Atomics.wait</code>)<a hidden class=anchor aria-hidden=true href=#91--blocking-apis-atomicswait>#</a></h3><h4 id=-what-does-blocking-actually-mean-in-javascript>üß† What does &ldquo;blocking&rdquo; <em>actually</em> mean in JavaScript?<a hidden class=anchor aria-hidden=true href=#-what-does-blocking-actually-mean-in-javascript>#</a></h4><p>We‚Äôre used to <code>await</code> yielding control ‚Äî letting the event loop breathe. But <code>Atomics.wait()</code>? That‚Äôs a different beast.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>Atomics</span><span class=p>.</span><span class=nx>wait</span><span class=p>(</span><span class=nx>int32Array</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span> <span class=c1>// üí• BLOCKS the agent
</span></span></span></code></pre></div><p>This is <strong>not like Promises</strong>. It <strong>completely freezes</strong> the thread.</p><h4 id=-promise--async-yield>‚úÖ Promise = async yield<a hidden class=anchor aria-hidden=true href=#-promise--async-yield>#</a></h4><ul><li>Returns control to the event loop</li><li>Lets other jobs run while waiting</li></ul><h4 id=-atomicswait--sync-block>‚ùå Atomics.wait = sync block<a hidden class=anchor aria-hidden=true href=#-atomicswait--sync-block>#</a></h4><ul><li>Halts everything in that agent (no event loop progress)</li><li>Nothing else in that thread runs until another agent calls <code>Atomics.notify</code></li></ul><p>üß¨ <strong>Mental Model</strong>:<br>A waiter (Promise) steps aside while the kitchen runs. A locked door (Atomics.wait) freezes the kitchen until someone unlocks it.</p><hr><h3 id=92--forward-progress-guarantees>9.2. üõ° Forward Progress Guarantees<a hidden class=anchor aria-hidden=true href=#92--forward-progress-guarantees>#</a></h3><p>Concurrency is dangerous ‚Äî race conditions, deadlocks, and starvation are real risks.</p><p>That‚Äôs why <strong>ECMAScript enforces forward progress</strong> guarantees, even in multi-agent systems.</p><blockquote><p>If multiple agents share the same thread, the runtime must ensure <strong>no agent starves forever.</strong></p></blockquote><h4 id=-fairness-by-design>üí° Fairness by design:<a hidden class=anchor aria-hidden=true href=#-fairness-by-design>#</a></h4><ul><li>The engine cannot ignore one agent just because another is busy.</li><li>Even if two agents are blocking each other via Atomics, the spec mandates that <em>some</em> agent makes progress.</li></ul><h4 id=-why-this-matters-2>üì¶ Why this matters:<a hidden class=anchor aria-hidden=true href=#-why-this-matters-2>#</a></h4><p>Imagine two workers sharing memory. If worker A holds a lock and gets suspended forever, and worker B is waiting to acquire it ‚Äî you‚Äôve just created a distributed deadlock.</p><p>The JavaScript memory model <strong>prevents</strong> that scenario by <strong>ensuring all agents in a cluster eventually get time to run</strong>.</p><p>üß† <strong>Intuition</strong>: Even in tight concurrency loops, JavaScript won‚Äôt let one agent monopolize the thread indefinitely.</p><hr><h3 id=93--agent-termination-the-cluster-is-a-single-failure-domain>9.3. üí• Agent Termination: The Cluster Is a Single Failure Domain<a hidden class=anchor aria-hidden=true href=#93--agent-termination-the-cluster-is-a-single-failure-domain>#</a></h3><blockquote><p>Terminate one agent in a cluster, and you <strong>kill them all</strong>.</p></blockquote><p>This is one of the lesser-known ‚Äî but crucial ‚Äî constraints of <strong>agent clusters</strong>.</p><h4 id=-if-agents-share-memory-theyre-in-the-same-cluster>‚úÖ If agents share memory, they‚Äôre in the same cluster.<a hidden class=anchor aria-hidden=true href=#-if-agents-share-memory-theyre-in-the-same-cluster>#</a></h4><h4 id=-if-one-crashes-they-all-go-down>üî• If one crashes, they <em>all</em> go down.<a hidden class=anchor aria-hidden=true href=#-if-one-crashes-they-all-go-down>#</a></h4><p>Why?</p><p>Because allowing a shared-memory cluster to continue operating with a missing participant would:</p><ul><li>Risk <strong>memory corruption</strong></li><li>Break <strong>lock semantics</strong></li><li>Violate <strong>deterministic state models</strong></li></ul><p>üß¨ <strong>System-level analogy</strong>: Imagine a nuclear power grid with interdependent control units. If one node goes offline during a write, the entire system must halt to avoid undefined behavior.</p><h4 id=-what-about-fault-tolerance>üß™ What about fault-tolerance?<a hidden class=anchor aria-hidden=true href=#-what-about-fault-tolerance>#</a></h4><p>Interestingly, the ECMAScript spec <em>mentions</em> a second strategy: detect a terminated agent and let others recover.</p><p>But:</p><ul><li>üîí It‚Äôs <strong>not implemented in any browser</strong></li><li>üõ† Still a theoretical model ‚Äî not production-grade yet</li></ul><hr><h2 id=-takeaways-for-system-builders>‚ö†Ô∏è Takeaways for System Builders<a hidden class=anchor aria-hidden=true href=#-takeaways-for-system-builders>#</a></h2><p>If you‚Äôre using <code>SharedArrayBuffer</code>, <code>Atomics</code>, or any worker model with shared memory:</p><ul><li>‚úÖ Understand <strong>agent clusters</strong>: memory sharing defines membership</li><li>üß† Don‚Äôt rely on <code>postMessage</code> for real concurrency ‚Äî use SAB + Atomics intentionally</li><li>üõë Avoid assuming you can recover from crashes inside a cluster ‚Äî you <em>can‚Äôt</em> (yet)</li><li>üßµ Be aware of blocking: Promises = cooperative, Atomics = hard locks</li></ul><hr><p>üìå <strong>Final Thought</strong>:<br>Shared memory brings <strong>power</strong> ‚Äî and <strong>responsibility</strong>. You‚Äôre no longer in JavaScript‚Äôs comfy async sandbox. You‚Äôre in systems-land now ‚Äî where deadlocks, race conditions, and cluster-wide failure are real threats.</p><p>Use the power. Know the cost.</p><hr><h2 id=-10-putting-it-all-together>üîó 10. <strong>Putting It All Together</strong><a hidden class=anchor aria-hidden=true href=#-10-putting-it-all-together>#</a></h2><hr><h3 id=-why-this-section-matters>üéØ Why this section matters:<a hidden class=anchor aria-hidden=true href=#-why-this-section-matters>#</a></h3><p>Everything we‚Äôve explored ‚Äî stacks, heaps, queues, jobs, realms, agents, workers, shared memory ‚Äî now comes together into a unified execution trace. This is where theory meets runtime. This is where <em>your intuition levels up</em>.</p><hr><h3 id=101--full-execution-trace>10.1 ‚öôÔ∏è <strong>Full Execution Trace</strong><a hidden class=anchor aria-hidden=true href=#101--full-execution-trace>#</a></h3><p>Let‚Äôs simulate a complete run of a JavaScript program involving:</p><ul><li>üß† <strong>Synchronous execution</strong> (stack)</li><li>‚è∞ <strong>setTimeout</strong> (macro-task queue)</li><li>üí¨ <strong>Promise</strong> (microtask queue)</li><li>üîÅ <strong>Nested function calls</strong></li><li>üîÑ <strong>Event loop orchestration</strong></li></ul><hr><h4 id=-code-example>üíª Code Example:<a hidden class=anchor aria-hidden=true href=#-code-example>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-js data-lang=js><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Start&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>setTimeout</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Timeout 1&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>},</span> <span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>Promise</span><span class=p>.</span><span class=nx>resolve</span><span class=p>().</span><span class=nx>then</span><span class=p>(()</span> <span class=p>=&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;Promise 1&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nx>console</span><span class=p>.</span><span class=nx>log</span><span class=p>(</span><span class=s2>&#34;End&#34;</span><span class=p>);</span>
</span></span></code></pre></div><hr><h3 id=-execution-timeline>üîÅ Execution Timeline<a hidden class=anchor aria-hidden=true href=#-execution-timeline>#</a></h3><table><thead><tr><th>Step</th><th>Stack</th><th>Microtask Queue</th><th>Task Queue</th><th>Output</th></tr></thead><tbody><tr><td>1</td><td><code>global()</code></td><td></td><td></td><td></td></tr><tr><td>2</td><td>log(&ldquo;Start&rdquo;)</td><td></td><td></td><td>Start</td></tr><tr><td>3</td><td>setTimeout(&mldr;)</td><td></td><td>[Timeout callback]</td><td></td></tr><tr><td>4</td><td>Promise.then(&mldr;)</td><td>[Promise callback]</td><td>[Timeout callback]</td><td></td></tr><tr><td>5</td><td>log(&ldquo;End&rdquo;)</td><td>[Promise callback]</td><td>[Timeout callback]</td><td>End</td></tr><tr><td>6</td><td>Execute microtask</td><td>[]</td><td>[Timeout callback]</td><td>Promise 1</td></tr><tr><td>7</td><td>Execute macro task</td><td>[]</td><td>[]</td><td>Timeout 1</td></tr></tbody></table><hr><h3 id=-metaphor-1>üß† Metaphor:<a hidden class=anchor aria-hidden=true href=#-metaphor-1>#</a></h3><ul><li><strong>Call stack</strong> is your desk ‚Äî only one function open at a time.</li><li><strong>Microtasks</strong> are sticky notes stuck to the monitor ‚Äî you handle them <strong>after the current task</strong>, but <strong>before</strong> picking a new one from the task queue.</li><li><strong>Macro-tasks (setTimeout)</strong> are tasks waiting in your inbox ‚Äî they only get attention <strong>after all microtasks are done</strong>.</li></ul><hr><h3 id=-connections>üîó Connections<a hidden class=anchor aria-hidden=true href=#-connections>#</a></h3><ul><li><strong>Stack</strong>: Tracks what code is currently running.</li><li><strong>Heap</strong>: Stores <code>Promise</code>, callback functions.</li><li><strong>Job Queue</strong>: Schedules promise callbacks (microtasks).</li><li><strong>Task Queue</strong>: Schedules <code>setTimeout</code>, events (macro-tasks).</li><li><strong>Event Loop</strong>: Pulls from microtask ‚Üí then macro ‚Üí repeat.</li></ul><hr><h3 id=-subtle-gotchas>üß¨ Subtle Gotchas<a hidden class=anchor aria-hidden=true href=#-subtle-gotchas>#</a></h3><ul><li><code>Promise.then</code> always runs <strong>before</strong> <code>setTimeout</code>, even if <code>setTimeout</code> has 0ms delay.</li><li>This is because <strong>microtask queue</strong> is prioritized over <strong>macro-task queue</strong>.</li></ul><hr><h3 id=102--mental-models--visuals>10.2 üß† <strong>Mental Models & Visuals</strong><a hidden class=anchor aria-hidden=true href=#102--mental-models--visuals>#</a></h3><hr><h3 id=-timeline-diagram>üìä Timeline Diagram<a hidden class=anchor aria-hidden=true href=#-timeline-diagram>#</a></h3><pre tabindex=0><code>Time ‚Üí
| Stack: log(&#34;Start&#34;)      ‚Üí log(&#34;End&#34;)        ‚Üí [Empty]
| Microtask:               ‚Üí Promise.then()    ‚Üí [Empty]
| Task:     setTimeout()   ‚Üí                  ‚Üí setTimeout()
Output:
Start
End
Promise 1
Timeout 1
</code></pre><hr><h3 id=-stackheapqueue-visualization>üß© Stack‚ÄìHeap‚ÄìQueue Visualization<a hidden class=anchor aria-hidden=true href=#-stackheapqueue-visualization>#</a></h3><pre tabindex=0><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      Call Stack      ‚îÇ ‚Üê Runs synchronous code (one frame at a time)
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ   Global Execution   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ        Heap          ‚îÇ ‚Üê Stores objects, closures, promises
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Promise, callbacks‚Ä¶  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     Microtask Q      ‚îÇ ‚Üê Promise callbacks (then, catch)
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ () =&gt; console.log‚Ä¶   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ     Task Queue       ‚îÇ ‚Üê Timers, UI events
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ setTimeout cb‚Ä¶       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre><hr><h3 id=-cross-realm--agent-flowchart>üß≠ Cross-Realm & Agent Flowchart<a hidden class=anchor aria-hidden=true href=#-cross-realm--agent-flowchart>#</a></h3><pre tabindex=0><code>[ Window (Agent A) ]
     ‚îÇ
     ‚îú‚îÄ setTimeout()        ‚Üí Task Queue
     ‚îú‚îÄ Promise.then()      ‚Üí Microtask Queue
     ‚îú‚îÄ Web Worker (Agent B)
     ‚îÇ     ‚îú‚îÄ Own Heap
     ‚îÇ     ‚îú‚îÄ Own Stack
     ‚îÇ     ‚îî‚îÄ Communicates via postMessage or SharedArrayBuffer
     ‚îÇ
     ‚îî‚îÄ iframe (Realm B, same agent)
           ‚îú‚îÄ Own GlobalThis
           ‚îî‚îÄ Shared Stack/Queue (if same-origin)
</code></pre><hr><h3 id=-interview-insight>üéØ Interview Insight<a hidden class=anchor aria-hidden=true href=#-interview-insight>#</a></h3><p>If you truly understand this unified flow, you can:</p><ul><li>Predict async code output reliably.</li><li>Avoid callback hell and race conditions.</li><li>Understand Node.js concurrency patterns.</li><li>Handle shared memory in web workers safely.</li></ul><hr><h2 id=-final-thought-1>‚úÖ Final Thought<a hidden class=anchor aria-hidden=true href=#-final-thought-1>#</a></h2><p>JavaScript isn‚Äôt just ‚Äúsingle-threaded.‚Äù<br>It‚Äôs a <strong>coordinated choreography</strong> of:</p><ul><li>Agents (runners)</li><li>Realms (universes)</li><li>Heaps (long-term memory)</li><li>Stacks (call trace)</li><li>Queues (scheduling)</li><li>Event loop (the director)</li></ul><p>Master this mental model, and you&rsquo;re not just writing JS ‚Äî you&rsquo;re <strong>orchestrating time</strong>.</p><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://archit15singh.github.io/tags/javascript/>JavaScript</a></li><li><a href=https://archit15singh.github.io/tags/technical-deep-dive/>Technical Deep Dive</a></li></ul><nav class=paginav><a class=prev href=https://archit15singh.github.io/posts/minimal-test-post/><span class=title>¬´ Prev Page</span><br><span>Minimal Test Post</span>
</a><a class=next href=https://archit15singh.github.io/posts/2022-07-29-test-post/><span class=title>Next Page ¬ª</span><br><span>Test Post</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive) on twitter" href="https://twitter.com/intent/tweet/?text=How%20JavaScript%20Really%20Runs%3a%20From%20Engines%20to%20Event%20Loop%20%28Execution%20Model%20Deep%20Dive%29&amp;url=https%3a%2f%2farchit15singh.github.io%2fposts%2f2022-07-29-js-execution-model-in-depth%2f&amp;hashtags=JavaScript%2cTechnicalDeepDive"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive) on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2farchit15singh.github.io%2fposts%2f2022-07-29-js-execution-model-in-depth%2f&amp;title=How%20JavaScript%20Really%20Runs%3a%20From%20Engines%20to%20Event%20Loop%20%28Execution%20Model%20Deep%20Dive%29&amp;summary=How%20JavaScript%20Really%20Runs%3a%20From%20Engines%20to%20Event%20Loop%20%28Execution%20Model%20Deep%20Dive%29&amp;source=https%3a%2f%2farchit15singh.github.io%2fposts%2f2022-07-29-js-execution-model-in-depth%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive) on reddit" href="https://reddit.com/submit?url=https%3a%2f%2farchit15singh.github.io%2fposts%2f2022-07-29-js-execution-model-in-depth%2f&title=How%20JavaScript%20Really%20Runs%3a%20From%20Engines%20to%20Event%20Loop%20%28Execution%20Model%20Deep%20Dive%29"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive) on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2farchit15singh.github.io%2fposts%2f2022-07-29-js-execution-model-in-depth%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive) on whatsapp" href="https://api.whatsapp.com/send?text=How%20JavaScript%20Really%20Runs%3a%20From%20Engines%20to%20Event%20Loop%20%28Execution%20Model%20Deep%20Dive%29%20-%20https%3a%2f%2farchit15singh.github.io%2fposts%2f2022-07-29-js-execution-model-in-depth%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share How JavaScript Really Runs: From Engines to Event Loop (Execution Model Deep Dive) on telegram" href="https://telegram.me/share/url?text=How%20JavaScript%20Really%20Runs%3a%20From%20Engines%20to%20Event%20Loop%20%28Execution%20Model%20Deep%20Dive%29&amp;url=https%3a%2f%2farchit15singh.github.io%2fposts%2f2022-07-29-js-execution-model-in-depth%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><div class=container><div class="content has-text-centered"><p><strong>Archit's Space</strong> - Sharing knowledge one post at a time.<br>Crafted with ‚ù§Ô∏è by Archit Singh</a>.<br>Connect with me on
<a href=https://github.com/archit15singh target=_blank>GitHub</a>,
<a href=https://www.linkedin.com/in/archit15singh target=_blank>LinkedIn</a>,
and <a href=https://twitter.com/archit15singh target=_blank>Twitter</a>.</p></div></div></footer><script data-goatcounter=https://architsingh.goatcounter.com/count async src=//gc.zgo.at/count.js></script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>